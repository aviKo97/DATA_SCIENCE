{
  "subreddit": "computerscience",
  "collection_date": "2025-06-05T14:00:04.821397",
  "total_posts_with_comments": 187,
  "total_comments": 1169,
  "comments": {
    "1l3fu4x": [
      {
        "id": "mw0j9pz",
        "body": "[Programming Languages - Google Scholar](https://scholar.google.ca/scholar?as_ylo=2021&q=Programming+Languages&hl=en&as_sdt=0,5)\n\nIf there is something that can be researched, then people are doing research. It isn't my area of expertise, but there's a link to Google Scholar for works since 2021 (which is generally the outer limit for recent). You can start there are start narrowing things down.",
        "author": "Magdaki",
        "created_utc": 1749068313,
        "score": 11,
        "parent_id": "t3_1l3fu4x",
        "depth": 0
      },
      {
        "id": "mw0xpl0",
        "body": "Join me in lurking on /r/ProgrammingLanguages",
        "author": "EatThatPotato",
        "created_utc": 1749072468,
        "score": 7,
        "parent_id": "t3_1l3fu4x",
        "depth": 0
      },
      {
        "id": "mw0xoc5",
        "body": "PL is broad with many different areas. Some examples would be type systems, compiler optimizations, formal verification, language design and much more. If you want to look at some recent research I would suggest looking at publications at conferences such as POPL or ECOOP.",
        "author": "Shrix_Eddy",
        "created_utc": 1749072457,
        "score": 7,
        "parent_id": "t3_1l3fu4x",
        "depth": 0
      }
    ],
    "1l37ofe": [
      {
        "id": "mvzbf5q",
        "body": "This is a bit of a ramble; apologies in advance.  I don't know how much of this would be useful to *directly* include in your course, but it's stuff that I think someone interested in computer history might find appealing and/or useful:\n\n# Books\n\n* Petzold's [*The Annotated Turing*](https://www.amazon.com/Annotated-Turing-Through-Historic-Computability/dp/0470229055), while not a history book, covers some background for Turing's *On Computable Numbers*, which might be interesting if you haven't seen it before.  I have not read it, but I have heard good things.\n* If you're interested in cryptography:\n   * Singh's [*The Code Book*](https://www.amazon.com/Code-Book-Science-Secrecy-Cryptography/dp/0385495323) is a nice history up through about the year 2000.\n   * As another \"I haven't read it, but I've heard good things\" book, Kahn's [*The Codebreakers*](https://www.amazon.com/Codebreakers-Comprehensive-History-Communication-Internet/dp/0684831309) is a more comprehensive history of cryptography up through the mid-late 1900s.\n* If you're interested in the history of specific algorithms, Knuth's [*Art of Computer Programming*](https://en.wikipedia.org/wiki/The_Art_of_Computer_Programming) (probably best used as a reference text and not a \"read cover-to-cover\") does a fantastic job of citing the earliest (or, rather, \"earliest known to Knuth\" ...which is quite usually \"the actual earliest\") use of a particular method.\n* Seibel's [*Coders At Work*](https://www.amazon.com/gp/product/1430219483) is a collection of interviews with an assortment of \"big names\" in the software development world.  At this point it's a bit historical bc it's so old; if you are looking for primary sources or first-person accounts, this is a good resource to look at.\n* Vise's [*The Google Story*](https://www.amazon.com/Google-Story-2018-Updated-Technology/dp/038534273X) is a \"biography\" of Google as a company; I've linked the 2018 edition, but the copy I read was from 2006.\n* Stoll's [*The Cuckoo's Egg*](https://www.amazon.com/Cuckoos-Egg-Tracking-Computer-Espionage/dp/1416507787) is an autobiographical account of discovering and fighting one of the first instances of international espionage conducted over a computer, in the days before \"hacking\" was even considered a crime.\n\n# Museums\n\nDepending on where you are in the world, there are computer history-related museums that could be interesting to visit.  For example:\n\n* [Computer History Museum](https://computerhistory.org/) in Mountain View - have not visited myself, but have heard good things\n* [National Cryptologic Museum](https://www.nsa.gov/museum/) in Fort Meade\n* [Centre for Computing History](https://www.computinghistory.org.uk/#) in Cambridge (UK, not Mass.) - have not visited myself, but have heard good things\n* [MIT Museum](https://mitmuseum.mit.edu/) in Boston\n* [Intel Museum](https://www.intel.com/content/www/us/en/company-overview/intel-museum.html) in Santa Clara\n\n(continued in comment)",
        "author": "apnorton",
        "created_utc": 1749055929,
        "score": 4,
        "parent_id": "t3_1l37ofe",
        "depth": 0
      },
      {
        "id": "mvzrvjl",
        "body": "This is super interesting, good luck! I encounter many people without any computer literacy whatsoever. I have been toying with the idea of producing a YouTube series on cryptography: basically 2 videos for every topic one that is a high level overview for the lay person or something who is just starting and then on with some of the mathematical formalism in it and possibly a mistakes round up at the end of the week. We will see how things go when I get a bit of time and if anyone is interested.",
        "author": "No-Yogurtcloset-755",
        "created_utc": 1749060474,
        "score": 2,
        "parent_id": "t3_1l37ofe",
        "depth": 0
      },
      {
        "id": "mvzx69u",
        "body": "For me, I have enjoyed watching every component start as a separate card/peripheral, and slowly start migrating to a part of the cpu\n\nMaths coprocessors\nSound cards\nVideo cards\nGPUs\nRAM\nWIFI \n\nall of these things started as separate bulky peripheral devices, and today can all be integrated into a single CPU die.",
        "author": "Ok-Seaworthiness9848",
        "created_utc": 1749061986,
        "score": 2,
        "parent_id": "t3_1l37ofe",
        "depth": 0
      }
    ],
    "1l1xgg5": [
      {
        "id": "mvr2wpp",
        "body": "The headline is clearly trying to be a \"Physicists, you're superior to CS grads\" thing, but the article itself is pretty sensible despite not having much to do with the headline\n\nNothing anyone here will be unaware of (computers are good at some things, bad at others, brute force only gets you so far), though\n\nWhat this article is *not* saying (despite the attempt to do so in the headline) is that Physics is *harder than CS*. Because Computer Science has a bunch of these \"hard\" problems too",
        "author": "audigex",
        "created_utc": 1748950265,
        "score": 18,
        "parent_id": "t3_1l1xgg5",
        "depth": 0
      },
      {
        "id": "mvqg7sx",
        "body": "From 2012, mind you. The article's link to the paper is now dead, but it appears to have been *[Extracting dynamical equations from experimental data is NP-hard](https://arxiv.org/pdf/1005.0005)* by Cubitt et al. — the first author being a fine example of nominative determinism.",
        "author": "lubutu",
        "created_utc": 1748937899,
        "score": 7,
        "parent_id": "t3_1l1xgg5",
        "depth": 0
      },
      {
        "id": "mvpx1c2",
        "body": "Lovely pun",
        "author": "DeGamiesaiKaiSy",
        "created_utc": 1748927250,
        "score": 2,
        "parent_id": "t3_1l1xgg5",
        "depth": 0
      }
    ],
    "1l1lb1s": [
      {
        "id": "mvlvh8q",
        "body": "Do you mean like system design or computer systems (comparch, OS, networks, etc.)?\n\n* For the latter, start with [R&L](https://books.google.co.uk/books?id=pyTFAAAACAAJ) covering all three topics I named together. You can start if you know a programming language (*ideally*, you should know some C/C++) and some fundamental algorithms. You can always follow up with more focused resources on a personal passion that you discover.\n* For the former, start [here](https://github.com/donnemartin/system-design-primer). Unlike computer systems, system design has nontrivial prerequisites. Some of what you study about networks, databases, and distributed systems will come in handy, but additionally, you will need to know more about what can be called more 'engineering concerns' (load balancing, scalability and bottlenecks), as well as UML (the language in which ideas are communicated). Depending on the resources you use, one or more of these may be assumed background knowledge, or covered briefly.",
        "author": "srsNDavis",
        "created_utc": 1748879622,
        "score": 6,
        "parent_id": "t3_1l1lb1s",
        "depth": 0
      }
    ],
    "1l15rta": [
      {
        "id": "mviyvj7",
        "body": "Write code in C, now you have to debug it because your code sucks - switch to the assembly view in the debugger and look around. Hmm. Registers. Hmm. Callstack. Hmm. Data breakpoints. Time to go read about these then come back and try things. Then read some more. Rinse and repeat.",
        "author": "undo777",
        "created_utc": 1748833201,
        "score": 74,
        "parent_id": "t3_1l15rta",
        "depth": 0
      },
      {
        "id": "mvjcabk",
        "body": "Reverse engineering is a skill that is only obtainable once you have obtained other skills. Like coding. Like learning how the OS and CPUs work. After that, you can dive into reverse engineering. Anything less and you’re just guessing",
        "author": "DatumInTheStone",
        "created_utc": 1748839221,
        "score": 18,
        "parent_id": "t3_1l15rta",
        "depth": 0
      },
      {
        "id": "mvj7bsc",
        "body": "for me its something everyone did to one level or another among the nerdy kids that used computers (this was before computers were de-facto part of your life).  Kids shared games, and for that you needed to remove the durrrr copy protection of the day, which generally consisted of answering a question from the user manual (eg what is word 3, paragraph 2 on page 32) so you just opened up the hex editor and told it that empty string was the right answer for everything, press enter to play, accepted.   Or you had games where you ran out of ammo or lives, you could change your lives in like asteroids from 3 to 20 and play longer, see more of it, or one game I remember (wizardry series) had these one-shot kill arrows but you only find like 5 here, 3 there... I gave myself a bag full of stacks of 255.   Later, on the job, those skills came into play every rare once in a while to fix something (like a bugged library that was no longer supported) or the like.  Most of the time, its days of work for a microscopic fix/change, if you can even DO what you wanted to.  It helped having assembly language and the ability to look up machine instructions etc.  Today, you have far better tools, but even the best dissassembler is going to spew pretty rough looking code that will take a massive investment to modify in any meaningful way.\n\nI guess I am saying that its a neat skill, and fun sometimes, but its really not the best place to spend your time.  The rewards are not worth the gains, and that is before you start talking about legality stuff (eg the password removal was bad, but at that time, it didn't register when everyone was doing it so casually... its hard to explain that era to younger people, but what we did was not right).  Modding stuff via hacks is more often accomplished a better way, for modern games, but back then, modding meant digging into the binary files more often than not.  A small # of games late in that era had text files so you could do things (alpha centauri comes to mind).  Even when you are just doing the most simple hacks, the TOS for a lot of modern stuff is written so that doing that is against the conditions.   One reason this isn't taught in depth in schools etc is that the most common uses are at best morally grey, and often outright illegal one way or another.\n\nIf you insist on this, your best bet is to write code yourself and then take apart the executable with the hex editor/disassembler, and compare that to the generated assembly from your original.   Those 4 sources (the hex, the reverse engineered asm, original asm, and original C or whatever code) will help you start to make sense of it.",
        "author": "Independent_Art_6676",
        "created_utc": 1748836864,
        "score": 13,
        "parent_id": "t3_1l15rta",
        "depth": 0
      },
      {
        "id": "mvlluig",
        "body": "I started learning with game cheats and mods (also in highschool, ~25 years ago), with very limited programming knowledge at the time. I knew a bit of Visual Basic 6. I picked up the other skills I needed along the way.\n\nThe first cheats I done were via CheatEngine. It let you monitor a process's memory for changes to values, and then poke at them to set them to whatever you want. A trivial example would be an infinite health cheat. You might have `1000` hit points in a game, so you search the process memory for `1000` (it searches in binary of course, not text), which would usually find may results. You'd then change your health in the game and go search again for the new value to narrow down the results, and after a couple of tries you would find the one that represents health. You could then poke at it and change it to some arbitrary value, and now you never run out of health. Repeat the process for other stats and you have an max-stat character.\n\nSometimes it wasn't that simple. Instead of mutating the health value, the game might reallocate it somewhere else, so you'd have to try and trace the pointer to the structure containing the health, and monitor that instead. I would then write a simple program in C++ (Using Visual Studio 6.0/Code::Blocks), which would run in the background to monitor and set the values as needed, with `WriteProcessMemoryEx` on Windows. There were some good tutorials around in game hacking forums that shown how to write these kind of cheats. I also learned how to use code caves and DLL injection techniques to insert the cheats directly into the game without needing an external process, and got familiar with the Win32 API.\n\nThe same principles were basically used for modifying game saves. You'd change some stat, save the game and inspect the game save to see what changed (with a binary diff), then just write a program that would modify the game save directly. The game data files were much the same - open up the files with a hex editor, figure out their structure, change values and see what effect they had in game, then write a tool to easily mod them. All trial-and-error. By this point Hexadecimal was basically my second language and I had little trouble extracting structure with little or no information.\n\nI began using OllyDbg to step through game code while it's running, and basically learned x86 by doing so. I quickly got pretty skilled with OllyDbg and could find code in online games which encrypts and decrypts network traffic and manually decompile it. I would modify process to connect to localhost by replacing the IP address, and wrote proxies which could intercept all the traffic, decrypt it, modify it, encrypt again and forward to the server. For some games I reverse engineered the whole network protocol via trial-and-error - basically by setting random values in packets and seeing what happened in the game, and once I had figured out the full protocol I wrote private servers. This is where I started picking up more practical programming skills besides trivial mods.\n\nBack then this was all pretty straightforward. Anti-cheat engines were not very sophisticated and were easy to bypass, but they started getting more difficult to work around, I had a few bans from subscription games due to silly mistakes, and I had moved onto other things. It's nearly 20 years since I messed with anything related to games, but the skills I learned by doing all that were invaluable. I mastered C and C++, x86, basic cryptography, learned how to write servers and use RDBMS without any formal training, and aside from C++ (which I didn't really keep up with after C++11), I still use those skills almost daily - though I'm more into theoretical CS now - I'm a compiler engineer, but still without any formal training - just the internet and books.\n\n---\n\nMy advice (in order):\n \n * Avoid \"AI\" - think through problems by yourself, and use a search engine to find information.\n\n * Learn the basics of C (not C++ for now) - but don't rely on an IDE to make your programs. Use a text editor, compiler, linker and Makefiles. Use an IDE only after you're already familiar with how it all works.\n\n * Familiarize yourself with boolean algebra, binary representations of numbers - in particular two's-complement, hexadecimal, little-and big-endianness, and floating-point representation. These should all become second-nature.\n\n * Learn how to use a debugger to step through your C programs.\n\n * Then learn X86_64 assembly, which you can use alongside C - either by embedding it, or linking it separately.\n\n * As a practical challenge to improve those skills, write a disassembler for an instruction set. Which instruction set does not matter - could be X86_64 itself, but more practically something simpler like a retro-game console processor. There's plenty of information around for these. Pick the one most interesting to you.\n\n * Learn regular expressions, lexing & parsing (flex & bison) - use them to implement an assembler for the same instruction set, and write some programs in it.\n\n * Write an emulator & debugger for your chosen instruction set.\n\nIf you get that far you're well on your way to proficiency.",
        "author": "WittyStick",
        "created_utc": 1748876859,
        "score": 3,
        "parent_id": "t3_1l15rta",
        "depth": 0
      },
      {
        "id": "mvkkalf",
        "body": "I learned python (or bash) first then fell into malware analysis and Android reverse engineering after I found an article about smali and started modifying apks. You'll need to know the basics of coding first, then you can just dive into it if you're really built like that.",
        "author": "experiencings",
        "created_utc": 1748863784,
        "score": 3,
        "parent_id": "t3_1l15rta",
        "depth": 0
      },
      {
        "id": "mvllnpi",
        "body": "By doing it.\n\nCrack mes are a pretty common on ramp.",
        "author": "monocasa",
        "created_utc": 1748876803,
        "score": 3,
        "parent_id": "t3_1l15rta",
        "depth": 0
      },
      {
        "id": "mvj0ojy",
        "body": "Get an Arduino kit!",
        "author": "burncushlikewood",
        "created_utc": 1748833954,
        "score": 2,
        "parent_id": "t3_1l15rta",
        "depth": 0
      },
      {
        "id": "mvsfokl",
        "body": "I would first recommend you learn x64 assembly including different sections such as text and data\n\n. Then what I did was learn the basics of C including how the stack and heap works.\n\nFinally I started with malware analysis, specifically windows malware. Practical malware analysis from Sikorski is a really good read. I also would recommend not using ai and try your best to follow along. If you are purely interested in reverse engineering, skip to the section on advanced static analysis since that will use disassemblers.",
        "author": "jabbajunior",
        "created_utc": 1748965933,
        "score": 2,
        "parent_id": "t3_1l15rta",
        "depth": 0
      },
      {
        "id": "mvw1t9j",
        "body": "Read this book before I knew anything about anything. It was an amazing eye opener.\n\nhttps://bunniefoo.com/nostarch/HackingTheXbox_Free.pdf\n\nJust realized the subtitle \"an introduction to reverse engineering\" !!\n\nCan't tell you how influential this was to me at the time.",
        "author": "DootDootWootWoot",
        "created_utc": 1749007301,
        "score": 2,
        "parent_id": "t3_1l15rta",
        "depth": 0
      },
      {
        "id": "mw3ump2",
        "body": "Very very hard without knowing programming",
        "author": "Chronopuddy",
        "created_utc": 1749116315,
        "score": 2,
        "parent_id": "t3_1l15rta",
        "depth": 0
      }
    ],
    "1l0mkz2": [
      {
        "id": "mvecmp7",
        "body": "The digital version of \"1-of-n key to open the gate\" is not interesting, as it can be just plaintext encrypted with multiple different keys.\n\nWhat's much more interesting, though, is \"all keys required to open the gate\", or more generally, \"k-of-n keys to open the gate\" for arbitrary number k.\n\nIt's called [secret sharing](https://en.wikipedia.org/wiki/Secret_sharing).",
        "author": "JiminP",
        "created_utc": 1748777466,
        "score": 11,
        "parent_id": "t3_1l0mkz2",
        "depth": 0
      },
      {
        "id": "mvebwqg",
        "body": "Public/private key",
        "author": "Past-Listen1446",
        "created_utc": 1748777113,
        "score": 5,
        "parent_id": "t3_1l0mkz2",
        "depth": 0
      },
      {
        "id": "mveevp1",
        "body": "Role based access.",
        "author": "Beautiful_Watch_7215",
        "created_utc": 1748778543,
        "score": 2,
        "parent_id": "t3_1l0mkz2",
        "depth": 0
      },
      {
        "id": "mvebpzg",
        "body": "Legal copy of any software",
        "author": "Die_Eisenwurst",
        "created_utc": 1748777019,
        "score": 3,
        "parent_id": "t3_1l0mkz2",
        "depth": 0
      },
      {
        "id": "mvec9y5",
        "body": "How tf will 15 and 18 open that gate?",
        "author": "Spokraket",
        "created_utc": 1748777293,
        "score": 3,
        "parent_id": "t3_1l0mkz2",
        "depth": 0
      },
      {
        "id": "mvedpcu",
        "body": "OR gate?",
        "author": "RealSataan",
        "created_utc": 1748777986,
        "score": 3,
        "parent_id": "t3_1l0mkz2",
        "depth": 0
      }
    ],
    "1l0jrkw": [
      {
        "id": "mvdw4vy",
        "body": "Have you asked your advisor (or a professor in your general area of interest, if you don’t formally have an advisor yet) about it? They’d have a good idea of whether anyone would be interested.",
        "author": "Terrible_Confidence",
        "created_utc": 1748768108,
        "score": 29,
        "parent_id": "t3_1l0jrkw",
        "depth": 0
      },
      {
        "id": "mvdsgfm",
        "body": "Submit it anyway and see if it gets accepted!",
        "author": "pioverpie",
        "created_utc": 1748765868,
        "score": 16,
        "parent_id": "t3_1l0jrkw",
        "depth": 0
      },
      {
        "id": "mvecjjr",
        "body": "A lot of theoretical work ends up being pretty minor because all the low hanging fruit is long gone. Having a theoretical application can be helpful. In other words, answer the question \"Why might this variant be useful? In what scenarios? Do those scenarios exist?\"\n\nThe two other big things are:\n\n1. Of course, make really really really sure it hasn't been done.\n2. Make sure it hasn't been done because it has been superseded. This happens more frequently than you might think, that an even better variant has already been found and so nobody has published your variant not due to not thinking of it but because it is strictly worse than the existing works. The best way to counter this is with what I provided above: \"In the case that blah blah blah, this variant works better than any other variant because blah blah blah. This case can occur when blah blah blah.\"",
        "author": "Magdaki",
        "created_utc": 1748777423,
        "score": 17,
        "parent_id": "t3_1l0jrkw",
        "depth": 0
      },
      {
        "id": "mvfmasx",
        "body": "if it is a simpler or more elegant variant, there is a conference called Simplicity in Algorithms:\n\nhttps://www.siam.org/conferences-events/siam-conferences/sosa26/",
        "author": "twoshedsyousay",
        "created_utc": 1748793417,
        "score": 4,
        "parent_id": "t3_1l0jrkw",
        "depth": 0
      }
    ],
    "1l072om": [
      {
        "id": "mvb7yew",
        "body": "Asymmetric encryption utilizes **one-way functions**. That means that it is very easy to encrypt a message using the known public key, but almost impossible to decrypt it again unless you have the private key.",
        "author": "Apfelkrenn",
        "created_utc": 1748726686,
        "score": 95,
        "parent_id": "t3_1l072om",
        "depth": 0
      },
      {
        "id": "mvb7m8y",
        "body": "The whole point of cryptography is that reversing certain functions is nearly impossible. Look into one way functions.",
        "author": "tejaswidp",
        "created_utc": 1748726575,
        "score": 53,
        "parent_id": "t3_1l072om",
        "depth": 0
      },
      {
        "id": "mvbajvx",
        "body": "Look up the math of how you encrypt things with the public key.\n\n\nTry to see if you can figure out how to reverse an encrypted message. 😛",
        "author": "FlipperBumperKickout",
        "created_utc": 1748727548,
        "score": 29,
        "parent_id": "t3_1l072om",
        "depth": 0
      },
      {
        "id": "mvbjzgj",
        "body": "Let's ignore all the number theory leading up to RSA and just focus on its underlying assumption:\n\nYou have a message m, a public key (e, n), and a private key d. You can encrypt with the public key, but need the public key and the private key to decrypt.\n\nThese numbers have already been selected such that (m^(e))^(d) (mod n) = m for any m. A user encrypts his message m by, using e and n, calculating m^(e) mod n.\n\nBecause (m^(e))^(d) mod n = ((m^(e)) mod n)^(d) mod n, the decrypting user can just take what has been calculated in the previous step, exponentiate by d, mod by n, and then get m.\n\nThe only way the encrypting user could \"undo\" what he encrypted if he forgot completely what that was is to either:\n\n1. Iterate over every possible message until you find it by sheer chance.\n2. Find a way to convert e^m mod n back into e. Calculating e^m mod n from e is very easy; it's just many, many multiplications. But calculating e from e^m requires asking \"under this modulo, what is the m-th root of e^(m)\"? And as we know, multiplying many numbers together is a lot easier than figuring out what those numbers actually were.\n3. Knowledge of the RSA algorithm tells us that we can find d, the decrypting key, if we know Euler's totient of n. Euler's totient function is the number of times a smaller positive number has no shared factors with the number in question. For example, the totient of 10 is 4, because 1, 3, 7, and 9 all have no common factors with 10. The RSA algorithm defines n as being the product of two primes p and q. You, the encryptor, do not get to know these primes. For prime numbers, finding the totient is easy: the totient of a prime p is just p-1, as all the positive numbers before it have no common factor by definition. For the product of numbers that do not share factors p, q, this is just totient(p) * totient(q), so for the product of primes (which never share factors) we have totient(n) = totient(pq) = totient(p)*totient(q) = (p-1)*(q-1).\n\nThis is how the person who made the keys found them: He used two large primes to create n, could quickly calculate the totient from these numbers, and then used the totient to find valid sets of (e, d). This forces you, the person without knowledge of p and q, to either brute force the totient of n (computationally infeasible), or determine the two primes that make up n. For large numbers there is no (known) good way to do this.",
        "author": "60hzcherryMXram",
        "created_utc": 1748730791,
        "score": 27,
        "parent_id": "t3_1l072om",
        "depth": 0
      },
      {
        "id": "mvbbdky",
        "body": "One way functions, of which math has tons of them.  For example, squaring a number is a trivial task -- take a number and multiply it by itself.  The complexity of the problem scales linearly with the size of the number.  Now try taking the square root.  A common method is to \"guess\" what the root is, square it and see how close you were.  Then make a new guess and repeat the operation until you get the right answer.  This is just an example, but math is full of these types of equations.  Public key encryption uses similar problem, except it's doing prime factorization instead of square roots.",
        "author": "bothunter",
        "created_utc": 1748727819,
        "score": 12,
        "parent_id": "t3_1l072om",
        "depth": 0
      },
      {
        "id": "mvbd0j9",
        "body": "I think you got that backwards. Asymmetric encryption requires public and private keys, because the encryption done by one key can only be undone by the other key.\n\nSymmetric encryption is where the same key is used for both encryption and decryption, so it must be kept private. Symmetric encryption cannot have public keys.",
        "author": "SufficientStudio1574",
        "created_utc": 1748728367,
        "score": 8,
        "parent_id": "t3_1l072om",
        "depth": 0
      },
      {
        "id": "mvbilhs",
        "body": "Key generation uses what's called a \"one way function\". That means something that is very fast and easy to do in one direction, but very slow in the other\n\nFor example, cracking one algorithm that's used (RSA-4096) basically (oversimplified) consists of \"This 4096-bit (1200 digit ish) number is a combination of multiplying two really big prime numbers... tell me which prime numbers they are, there is only one correct answer\"\n\nMultiplying the two prime numbers together is easy - it takes a couple of CPU cycles. Working out WHICH prime numbers were used is MUCH harder. You basically have to take every single prime number smaller than the 39-digit number, and then multiply it with every other prime number in the same set (give or take the ability to exclude numbers too large). This has to be done through trial and error.\n\nFor example let's say I picked 221 as the prime number. How would you guess it? You'd pick a prime number and then try it with others\n\n> 2, 3, 5, 7, 11, 13, 17, 19\n\n2*2 =4, nope 2*3 = 6, nope. 2*5 = 15, nope. 2*7 = 14, nope. 2*11 = 22, nope... etc etc until we get to 13 * 17.\n\nThat would take 75 attempts. Whereas I can *use* the key just by multiplying 13 * 17. And that's for a VERY short key length of 8-bit. The longest key that has been cracked (or at least, that we know of) is RSA-250 (829 bit) which took thousands of CPU-years\n\nSomething in the order of 10^150 attempts would be needed to crack RSA-4096, which would take all the computing power on the planet currently, trillions of years",
        "author": "audigex",
        "created_utc": 1748730301,
        "score": 5,
        "parent_id": "t3_1l072om",
        "depth": 0
      },
      {
        "id": "mvb7mxv",
        "body": "I don’t know the true math of this, but that’s why we use asymmetric encryption. With symmetric, yes you could do this - you’d need to keep your one key completely secret and only somehow share it with the other party. And at some point, a pattern may show up if you send enough messages with that same key. \n\nWith asymmetric, we use one algorithm to generate two sets of keys. One of each of those sets of two keys can be sent publicly to the other party. Any package sent out from someone encrypted with their private key could be decrypted by anyone with their public key (many people historically would put their public key on their websites). \n\nIn your example, when a message is encrypted with someone’s public key, only their private key can decrypt it, which supposedly only they have. So everyone always encrypts a message with the receiver’s public key, then it is encrypted the entire way. \n\nSome people, and protocols like TCP, take this a step farther and have the sender encrypt a message with the receiver’s public key, then with the sender’s private key - this last step provides identity. Anyone else can decrypt this outer layer, which presents gibberish until the receiver’s private key is used, but having to use the sender’s public key means that you know the message was encrypted by them. \n\nTo your mod question, yeah it’s something like that. Likely a bit more complex. As I said, I’m not really sure the details but I know the gist. Because that prime factor is very large, and the math is somewhat expensive, it takes a long time to reverse engineer it - this is why some people think quantum computing could start breaking encryption. QC can check for prime factors at a much faster ability than our current computers. And some algorithms add rolling encryption which makes this even harder to crack. ",
        "author": "alnyland",
        "created_utc": 1748726582,
        "score": 3,
        "parent_id": "t3_1l072om",
        "depth": 0
      },
      {
        "id": "mvc0h7k",
        "body": "I'm trying to give the worst correct answer possible, so answer is:\n\nbecause prime factorization is really really hard for conventionnal computers.",
        "author": "stereosensation",
        "created_utc": 1748736691,
        "score": 4,
        "parent_id": "t3_1l072om",
        "depth": 0
      },
      {
        "id": "mvbf3e4",
        "body": "For RSA, the way it works is that the private key is (essentially) two very large primes, and the public key is (essentially) the product of those two primes.\n\n\nIt's very easy to multiply the two primes to get the public key from the private, but finding out the two primes just from the product is NP hard, so we don't have a better general solution than just trying different options for primes.",
        "author": "monocasa",
        "created_utc": 1748729077,
        "score": 3,
        "parent_id": "t3_1l072om",
        "depth": 0
      },
      {
        "id": "mvbbcni",
        "body": "Look into RSA-Encryption.",
        "author": "B3d3vtvng69",
        "created_utc": 1748727811,
        "score": 2,
        "parent_id": "t3_1l072om",
        "depth": 0
      },
      {
        "id": "mvbxt1n",
        "body": "This is best explained by a challenge. I have picked a secret, which is a six digit number. I have also picked a private key, which similarly is a six digit number (larger than the message).\n\n\nFor my encryption, I have multiplied them together. The multiplication result is 94677597821 (around 94 billion). The challenge for you is whether you can figure out my key or my message (one suffices). Or more precisely, whether you can do so via a process better than trying all possibilities?\n\n\nThis problem is behind many encryption schemes, of course they have some more complicated math. But do read up on RSA, since the math behind it is not that much more complicated.",
        "author": "JoJoModding",
        "created_utc": 1748735692,
        "score": 2,
        "parent_id": "t3_1l072om",
        "depth": 0
      },
      {
        "id": "mvd174w",
        "body": "There are several different public key cryptography algorithms but let’s take the most popular one as an example which is RSA. The RSA public key consists of two numbers: e and n. When you encrypt a message m with the public key, what you get is c = m^e (mod n).\n\nWhen e and n are sufficiently large numbers (i.e. more than 300 digits) it is virtually impossible to reverse m^e and find the m when you only know c. This is called discrete logarithm problem, and the best algorithm we know is not much faster than trying every number under n until you find the right one. This is why it’s called one-way function.",
        "author": "kimhyunkang",
        "created_utc": 1748751120,
        "score": 2,
        "parent_id": "t3_1l072om",
        "depth": 0
      },
      {
        "id": "mvddslw",
        "body": "Here's how you will understand this.\n\nHand roll your own PKE library that implements the basic functionality, and encrypt some messages using some keys made from small prime numbers. (It's not that hard. The math is a bit fiddly but nothing you can just write.)\n\nNow just brute force decrypt them by going through all of the prime factorizations. Count the number of steps and output it to a log. Now increase the size of the primes used to create the keys, and repeat. Note the growth in the number of steps.\n\nIf you really want to solidly understand this, just do it. This is a great thing to do in this case because it's totally possible, it's a one person project that will probably only take you a couple of days' effort. (I had a colleague that did a reduced form of this for his daughter's math class, and the kids just did everything with paper and pencil. It's really not that bad.)",
        "author": "severoon",
        "created_utc": 1748757426,
        "score": 2,
        "parent_id": "t3_1l072om",
        "depth": 0
      },
      {
        "id": "mvduu3v",
        "body": "As others have pointed out, public key cryptography is based on something that is trivial to compute but difficult-to-impossible to reverse - factorization of large integers is completely impractical with classical computers, but may be possible to do with quantum computers (see Shor's algorithm). Elliptic Curve cryptography is based on multiplication (repeated application of the group addition operator), but division is undefined - the only way to reverse the multiplication is brute force factorization.\n\nThere are sometimes flaws in cryptography implementations that allow extraction of a private key. For example, in ECDSA, each signature uses an ephemeral key which must be unique for every message signed. If two messages are signed with the same ephemeral key, we can use the two messages and their signatures to reverse the process and obtain the private key. This has been exploited in the wild - the fail0verflow team used it to crack the PS3, because Sony were using the same ephemeral key to sign every game. To ensure this doesn't accidentally happen, a good implementation will use a HKDF to generate the ephemeral key from the message - making it extremely improbable that the same key will be used twice.",
        "author": "WittyStick",
        "created_utc": 1748767326,
        "score": 2,
        "parent_id": "t3_1l072om",
        "depth": 0
      }
    ],
    "1kz524j": [
      {
        "id": "mv2lpx6",
        "body": "Paper on arXiv, for people who want a direct link: [https://arxiv.org/abs/2412.07192](https://arxiv.org/abs/2412.07192)",
        "author": "apnorton",
        "created_utc": 1748614626,
        "score": 18,
        "parent_id": "t3_1kz524j",
        "depth": 0
      },
      {
        "id": "mv2oq4f",
        "body": "Wow turns out that all this corporate censoring is just slap dashed and built on a foundation of twigs.",
        "author": "ESHKUN",
        "created_utc": 1748615487,
        "score": 16,
        "parent_id": "t3_1kz524j",
        "depth": 0
      },
      {
        "id": "mv3ckam",
        "body": "Sounds amazing as a concept, but if we’re able to flip 25 bits, aren’t we kinda surely at this point just able to do…whatever? Flip a 1000 bits. Change the weights to our own etc.",
        "author": "DescriptorTablesx86",
        "created_utc": 1748622220,
        "score": 11,
        "parent_id": "t3_1kz524j",
        "depth": 0
      }
    ],
    "1kzanmy": [
      {
        "id": "mv4qxkk",
        "body": "I think it would be beneficial for you to study and implement some aspects of architectural simulators. This will allow you to implement some of the concepts you already have studied.",
        "author": "mohan-aditya05",
        "created_utc": 1748636706,
        "score": 2,
        "parent_id": "t3_1kzanmy",
        "depth": 0
      },
      {
        "id": "mvbx9ut",
        "body": "Start reading the Hennessy and Patterson book (Computer Architecture: A Quantitative Approach). If you feel like there's a gap in your knowledge, then switch to a more introductory book like Computer Systems: A Programmer's Perspective by Bryant and O'Hallaron or Patterson and Hennessey's Computer Organization and Design.",
        "author": "parallelprojection",
        "created_utc": 1748735496,
        "score": 2,
        "parent_id": "t3_1kzanmy",
        "depth": 0
      }
    ],
    "1kye7k5": [
      {
        "id": "muwlijm",
        "body": "Discrete mathematics.",
        "author": "planetoftheshrimps",
        "created_utc": 1748534720,
        "score": 50,
        "parent_id": "t3_1kye7k5",
        "depth": 0
      },
      {
        "id": "muwqmtt",
        "body": "If you're starting *completely* from nothing, what I'd recommend is the following:\n\n1. Learn *a* programming language (doesn't really matter which; my bias is towards Python or Java, but JavaScript or C are also frequent \"first languages\" in college courses) to some basic proficiency.  The reason for this is that a lot of resources in CS will assume you know basic ideas from programming (e.g. loops, variables, functions/procedures, recursion) as a sort of \"common jargon.\"\n2. Learn discrete math.  If you're into mathematical logic, you probably already have this covered, but most TCS books will expect you to have already seen basic proof methods (e.g. direct proof, contraposition, induction), basic set theory, etc.\n3. Work through *Theory of Computation* by Sipser, which is the \"usual\" undergraduate theory book.  Another good one is *Automata Theory, Languages, and Computation* by Hopcroft, Motwani, and Ullman.\n4. Consider doing some algorithms/data structure study --- this would give you a very concrete/applied view of TCS, especially when doing reductions of problems to prove NP-completeness.  \n5. Determine where you want to go from here/more specialized reading: [P ?= NP](https://www.scottaaronson.com/papers/pnp.pdf) (pdf warning) by Scott Aaronson is a good read and free. *Computational Complexity* by Arora and Barak is a book I've just recently added to my shelf to work through, but looks useful.",
        "author": "apnorton",
        "created_utc": 1748536178,
        "score": 51,
        "parent_id": "t3_1kye7k5",
        "depth": 0
      },
      {
        "id": "muwir0q",
        "body": "Start with Theory of Computation by Sipser",
        "author": "tango_telephone",
        "created_utc": 1748533939,
        "score": 32,
        "parent_id": "t3_1kye7k5",
        "depth": 0
      },
      {
        "id": "muwo51l",
        "body": "If you're interested in mathematical logic then you'd benefit from some understanding of decidability. Early on its helpful to know what it means that propositional logic is decidable and predicate logic is, in general, semi decidable (a special kind of undecidable).\n\nYou're unlikely to need deep understanding of decidability stuff. Existence proofs for undecidable functions, for example, are fun but you're unlikely to need to understand them in depth.\n\nBut a lot of the material on models of computation or complexity theory is unlikely to help you with your goals ... depending what those are.\n\nWhat are you interested in when it comes to mathematical logic? I'd suggest finding the shortest path to the stuff you're really interested in otherwise you're going to be swamped by a lot of irrelevant theory.",
        "author": "GreenExponent",
        "created_utc": 1748535470,
        "score": 3,
        "parent_id": "t3_1kye7k5",
        "depth": 0
      },
      {
        "id": "muxtyr1",
        "body": "For pure theoretical cs, math is totally enough",
        "author": "andgomes",
        "created_utc": 1748547219,
        "score": 3,
        "parent_id": "t3_1kye7k5",
        "depth": 0
      },
      {
        "id": "muwp140",
        "body": "When I was a computer science program in a top engineering school, the program was under the math dept, before it was moved to the engineering dept by my junior year. While there is significant math, it is not as bad as physics, and there are a lot of amazing concepts in computer science.",
        "author": "Quantumercifier",
        "created_utc": 1748535722,
        "score": 2,
        "parent_id": "t3_1kye7k5",
        "depth": 0
      },
      {
        "id": "muxzrpo",
        "body": "You don't need that much cs knowledge, it's very abstract and definitely more math than CS, although logic is obviously used in CS. \nAlso while you don't really need the background knowledge to do well, it's still extremely helpful to know what the problems are actually about. If you are good at logic/math its not that hard to understand and make automatons, grammars etc, it's basically logic puzzles. \nBut id strongly recommend learning what it's actual applications are just to put it into context, makes it more interesting",
        "author": "recordedManiac",
        "created_utc": 1748548887,
        "score": 2,
        "parent_id": "t3_1kye7k5",
        "depth": 0
      },
      {
        "id": "muzg7qf",
        "body": "Please read this! Theory of Comp by Sipser is fine, but if your focus is not on studying for an exam, it might be really boring. \n\nI suggest a book Epstein and Carnielli, Computability : computable functions, logic, and the foundations of mathematics. Its an amazing read and dives into the philosophy of CS. \n\nAlso Annotated Turing is probably the coolest theory of comp book ever, it goes trough the whole turing thesis explaining every necessary background knowledge.",
        "author": "moonflower_boy",
        "created_utc": 1748565358,
        "score": 2,
        "parent_id": "t3_1kye7k5",
        "depth": 0
      },
      {
        "id": "mv1ipkt",
        "body": "None.",
        "author": "Numerous_Topic_913",
        "created_utc": 1748599819,
        "score": 2,
        "parent_id": "t3_1kye7k5",
        "depth": 0
      }
    ],
    "1kyh2oo": [
      {
        "id": "mux7zkd",
        "body": "It would require two things: a succesful form of quantum computation that runs at room temperature and a widespread consumer application for quantum computing. Right now we have neither of those things.  There is some notable progress toward the former, but none toward the later.\n\nIf you get just the first thing, then nobody would want to buy one, and if you get just the second thing then they will be available via cloud computing, not personally owned devices.  Nobody can know the future, but I would bet that having a quantum computer in your house is not likely in our lifetimes.",
        "author": "Cryptizard",
        "created_utc": 1748540956,
        "score": 42,
        "parent_id": "t3_1kyh2oo",
        "depth": 0
      },
      {
        "id": "mux8oyl",
        "body": "This is kinda like asking if personal computers would ever be a thing in the 40s, where the only computers on earth occupied multiple floors of a building.  It's quite simply too early to tell.\n\nCost is an obvious factor, but we also don't know if technology will ever be developed such that a \"useful\" quantum computer could fit conveniently in a home.  There's also the issue of practicality --- right now, the limiting factor on the vast majority of personal computing workflows is \"how fast can you multiply matrices together to render graphics,\" and as far as I'm aware, we don't have any significant speedups in that area when using a quantum computer.",
        "author": "apnorton",
        "created_utc": 1748541148,
        "score": 7,
        "parent_id": "t3_1kyh2oo",
        "depth": 0
      },
      {
        "id": "muymi3i",
        "body": "I think they'll eventually be available. There's a rather long history of technology becoming better and more available.\n\n1. 1943 - Thomas Watson, president of IBM \"I think there is a world market for maybe five computers.\"\n\n2. When IBM produced their first PC, they predicted a sales of one million machines over three years, with two hundred thousand the first year.\n\n3. The computer used by the Apollo moon landing had a clock speed of only 43 KHz.\n\nand the list goes on and one....\n\nFrankly, technology is advancing far faster than many people comprehend. The smart phone you likely have in your pocket has more processing power than the Cray-1 super computer.",
        "author": "johndcochran",
        "created_utc": 1748555537,
        "score": 4,
        "parent_id": "t3_1kyh2oo",
        "depth": 0
      },
      {
        "id": "mv2rs0a",
        "body": "I think questions like these fundamentally misunderstand what quantum computers are or (foreseeably) will be.\n\nAlthough the popular terminology is 'quantum computers', it is far more realistic to think of quantum *accelerators* or quantum processing units (QPUs) in the same way you have GPUs or TPUs.\n\nIt is far more realistic to imagine a scenario where a classical computer delegates tasks that are best done with quantum algorithms to a QPU, then receiving the results for further processing.\n\nAs for being available to consumers locally, unless we develop means to run quantum computations at room temperatures, you will likely be accessing quantum processors remotely, effectively like cloud computing resources.\n\nNot being available locally, however, does not mean being exclusive to companies, governments, or researchers. In fact, IBM Quantum offers a generous free tier for hobbyists or anyone just dabbling with quantum computing (considering the current state of quantum computing).\n\nIn the years to come, I see the freemium model expand - there will likely be limits on, e.g., the number or perhaps the complexity of jobs that you can schedule, as well as on your priority against premium users, but it is highly likely that some quantum computational capabilities will be available affordably.",
        "author": "srsNDavis",
        "created_utc": 1748616358,
        "score": 3,
        "parent_id": "t3_1kyh2oo",
        "depth": 0
      },
      {
        "id": "muxarsy",
        "body": "They may never even exist",
        "author": "michaeljacoffey",
        "created_utc": 1748541717,
        "score": 2,
        "parent_id": "t3_1kyh2oo",
        "depth": 0
      }
    ],
    "1kxeexs": [
      {
        "id": "muoqkz0",
        "body": "If true, this can be huge.\n\nHas anyone analyzed the paper? Is it one of those \"We beat Dijkstra in some special edge cases\" paper, or is it a general solution?",
        "author": "According_Book5108",
        "created_utc": 1748434637,
        "score": 288,
        "parent_id": "t3_1kxeexs",
        "depth": 0
      },
      {
        "id": "mupmt4t",
        "body": "Time to ask job seekers to implement it in half an hour.",
        "author": "jubashun",
        "created_utc": 1748444870,
        "score": 116,
        "parent_id": "t3_1kxeexs",
        "depth": 0
      },
      {
        "id": "mup1im8",
        "body": "Not a big improvement Big O wise (m⁢log2/3⁡n vs m+𝑛⁢log⁡𝑛) for games, I think it won't be much of a practical interest unless we're taking very big numbers of nodes and edges. \nThat's from a cursory, diagonal look at the html version of the paper while riding in a decrepit subway tunnel, In a slightly better shape wagon ;)",
        "author": "Motor_Let_6190",
        "created_utc": 1748438470,
        "score": 93,
        "parent_id": "t3_1kxeexs",
        "depth": 0
      },
      {
        "id": "muosva3",
        "body": "I was just last week using Dijkstra’s algorithm as an example where it is conjectured to be optimal and had stood up to 75 years of scrutiny but hasn’t been proven. What a pleasant surprise. Not practical, but extremely theoretically interesting.",
        "author": "Cryptizard",
        "created_utc": 1748435486,
        "score": 73,
        "parent_id": "t3_1kxeexs",
        "depth": 0
      },
      {
        "id": "mup6mtp",
        "body": "What's the difference in implementation?",
        "author": "FinalNandBit",
        "created_utc": 1748440125,
        "score": 30,
        "parent_id": "t3_1kxeexs",
        "depth": 0
      },
      {
        "id": "muxwbw7",
        "body": "Surprised no one has mentioned this yet, but this paper actually won a Best Paper Award at STOC 2025, which is one of the most prestigious conferences in theoretical computer science.\n\nThey improve the general-case asymptotic time for single-source shortest paths in directed graphs—something people have been trying (and failing) to do for decades. The improvement comes from combining Dijkstra’s and Bellman-Ford with a clever new data structure that processes multiple nodes at once, effectively shrinking the priority queue overhead that dominates Dijkstra’s runtime.\n\nSure, asking about experiments and practical performance is reasonable, but this result is more about the theoretical breakthrough. It’s a new approach to a very old, very fundamental problem. Whether or not it’s fast in practice today, it opens up new directions and could eventually lead to more practical improvements.\n\nHere's the announcement from MPI:\nhttps://www.mpi-inf.mpg.de/news/detail/stoc-best-paper-award-how-to-find-the-shortest-path-faster",
        "author": "rs10rs10",
        "created_utc": 1748547901,
        "score": 15,
        "parent_id": "t3_1kxeexs",
        "depth": 0
      },
      {
        "id": "muqhbi1",
        "body": "Seems like this may be a repost of the paper? \n\nThe same white paper was put out under Duan Et Al back in 2023 and is already on Wikipedia under the SSSP problem. \n\nhttps://arxiv.org/abs/2307.04139",
        "author": "firemonkey555",
        "created_utc": 1748453707,
        "score": 4,
        "parent_id": "t3_1kxeexs",
        "depth": 0
      },
      {
        "id": "muwrx01",
        "body": "There is requirements: [https://arxiv.org/html/2504.17033v1#alg2](https://arxiv.org/html/2504.17033v1#alg2)",
        "author": "leofun01",
        "created_utc": 1748536542,
        "score": 3,
        "parent_id": "t3_1kxeexs",
        "depth": 0
      }
    ],
    "1kwyc4t": [
      {
        "id": "mul5fxv",
        "body": "Idempotency for software means that repeat identical actions should not have different effects. Deleting the same record twice should not result in something else being deleted. Getting data from the db or getting it from a cache is AFAIK always idempotent since you aren't changing anything (hopefully).",
        "author": "Pretagonist",
        "created_utc": 1748380505,
        "score": 38,
        "parent_id": "t3_1kwyc4t",
        "depth": 0
      },
      {
        "id": "mul7oag",
        "body": "I guess kinda yes as if you cached it you will for sure get the same outcome but that is kinda backwards.\n\nYou should only ever cache a function that is idempotent to begin with because if its not you will end up with unexpected and wrong results.",
        "author": "LARRY_Xilo",
        "created_utc": 1748381188,
        "score": 20,
        "parent_id": "t3_1kwyc4t",
        "depth": 0
      },
      {
        "id": "mul8031",
        "body": "Only if the function is pure. In which case it is idempotent by definition, no memozaition needed.\n\nIn your case, here is a counter example:\nYour function takes an integer as input. This integer represents a row in a DB. You then fetch the row and delete it from the DB. You then cache/memoize the pair (input, row) in memory and finally return it.",
        "author": "Zubzub343",
        "created_utc": 1748381289,
        "score": 7,
        "parent_id": "t3_1kwyc4t",
        "depth": 0
      },
      {
        "id": "muma297",
        "body": "Any deterministic function (for which its output depends only on its inputs) is idempotent. \n\nThis idempotency dealio only matters for operations with side-effects. It would be silly, practically speaking, to memoize an operation with a side effect.",
        "author": "Aggressive_Ad_5454",
        "created_utc": 1748393804,
        "score": 2,
        "parent_id": "t3_1kwyc4t",
        "depth": 0
      },
      {
        "id": "mul2diz",
        "body": "Mathematically idempotency means that a function  f satisfies f(f(x)) = f(x) for all x. I’m not sure how this relates to memoization. And also note that idempotency only makes sense when the function has the same domain and codomain.\n\nPerhaps you are saying the side effects of a function would only show up once if you run it twice? That would be a pretty weird behavior unless you have some call-by-need semantics",
        "author": "FantaSeahorse",
        "created_utc": 1748379586,
        "score": 2,
        "parent_id": "t3_1kwyc4t",
        "depth": 0
      }
    ],
    "1kwg74n": [
      {
        "id": "muhrubp",
        "body": "The next big gamechanger will be when people (especially business) realize that language models are nowhere near as impressive as the hype being pushed out by the companies creating them.\n\nThe other big gamechanger will be when a language model company declares they have AGI by defining AGI to be exactly what their language model can do. It will not be AGI. Everyone will fall for it.",
        "author": "Magdaki",
        "created_utc": 1748342445,
        "score": 99,
        "parent_id": "t3_1kwg74n",
        "depth": 0
      },
      {
        "id": "muhaibx",
        "body": "We don't even have mature post-quantum encryption to migrate to yet. Nobody really knows which algorithms are going to succeed the TLS suite. For example, supersingular isogenies were seen as one of the most promising candidates until a few years ago because they supported both signing (SIKE) and key exchange (SIDH) and could've been a drop-in replacement, but it has since been demonstrated that they can be broken rather trivially, even with a conventional computer. The attacks are specific to SIKE and SIDH and don't entirely rule out isogenies as a candidate, but it certainly weakens their position. Other potential PQ candidates may yet suffer similar weaknesses, and none of the other candidates, to my knowledge, support *both* signing and key exchange - they do one or the other.",
        "author": "WittyStick",
        "created_utc": 1748332169,
        "score": 15,
        "parent_id": "t3_1kwg74n",
        "depth": 0
      },
      {
        "id": "mujoxtz",
        "body": "Zero knowledge proofs. The ability to prove a computation while keeping inputs private will do wonders towards preserving user privacy in decentralized systems. Although I suppose betting on user privacy to win out over corporations owning all your data is a risky bet.",
        "author": "uap_gerd",
        "created_utc": 1748365621,
        "score": 10,
        "parent_id": "t3_1kwg74n",
        "depth": 0
      }
    ],
    "1kvsyex": [
      {
        "id": "muc08o8",
        "body": "https://arxiv.org/pdf/2404.08371\n\nPapers such as this are the state of the art.",
        "author": "_oOo_iIi_",
        "created_utc": 1748263346,
        "score": 9,
        "parent_id": "t3_1kvsyex",
        "depth": 0
      }
    ],
    "1kvfo27": [
      {
        "id": "mu95262",
        "body": "The interface of the abstract data type is the boundary line, up to some sense of an isomorphism (i.e. if I merely rename the operations, it's still the same data structure).\n\n\n\nFor example, a stack supports a push and a pop operation such that popping items returns them in the opposite order in which they were pushed (LIFO).  A queue supports an enqueue and a dequeue operation such that dequeue returns items in the same order in which they were enqueued (FIFO).\n\n\n\nTime complexity is an implementation detail, usually.",
        "author": "apnorton",
        "created_utc": 1748215075,
        "score": 70,
        "parent_id": "t3_1kvfo27",
        "depth": 0
      },
      {
        "id": "mu97tc6",
        "body": ">stacks, arrays, and queues are all udually implemented as arrays anyway\n\nWell, **everything** is implemented as a string of 0s and 1s in memory in the end. But is that a useful way to view things?\n\nOne big motivation behind defining different data structures is to allow us to access and edit data **quickly**. If you only have 100 pieces of data, just make it an array - who cares? But if you have a billion pieces of data, and you need to do complex operations to them, then you should store them in a way that makes those operations as quick and \"cheap\" as possible in terms of CPU operations.\n\nA simple example: let's suppose you have a huge list of numbers, and you need to be able to do things like add new values and delete old values. There's nothing stopping you implementing this as an array. But here are some considerations:\n\n* Do you need to search through the structure, e.g. to check whether a number is already in it or not? Reading a billion numbers from left to right is very slow. There are faster methods, such as binary search, but that involves you being able to put your data in order, and there are a million algorithms for **that**, and **that** might be very slow too.\n* Once you remove a value in the list, what happens then? Do you want to leave a blank space, or do you want to move all the subsequent values downwards in the list? Moving half a billion numbers in memory is very slow.\n* Suppose I'm coding a 3D game. In this game, I drop an apple. I want my collision detection algorithm to tell me that the apple collides with the floor. Unfortunately, I've stored all the game objects as an array, so now my game has to check whether the apple has collided with the floor **or** with my foot **or** with my headphones **or** with the Eiffel Tower **or** the moon, etc etc. That's obviously going to be very slow.\n\nEvery extra thing you want to be able to do will take time. That means that, when working with a lot of data, you want to slim down your data structure as much as possible so that it aligns with exactly what you want to do with it (and it does it as quickly as possible), and nothing else.\n\nTry a few dozen Project Euler exercises. You will quickly realise that everything **can** be brute-forced, but not necessarily before the heat death of the universe if you're not smart about it.",
        "author": "numeralbug",
        "created_utc": 1748216092,
        "score": 22,
        "parent_id": "t3_1kvfo27",
        "depth": 0
      },
      {
        "id": "mu94v2l",
        "body": "At the end of the day, data is stored using binary somewhere in memory using electronics. It’s all 1s and 0s under the hood \n\nHowever how we read that data and interpret it into something useful varies widely. Data structures determine how and most importantly where the data we are looking for lives. \n\nFor example, an array. In most (if not all) languages an array will be continuous memory. If you had an array of size 8, meaning there are 8 cells you could fill, and each cell could fit exactly one byte of info, you would have 8 bytes in a row. This is extremely useful for fast “random-access” memory. When you want to grab a specific value. You just need to know where the start of the array is in memory, say 0x024 and then you can add to this value however many cells over you want to go grab any specific value. \n\nHowever, let’s take a linked list. There is no guarantee where any of the elements live in memory. You have the first head nodes memory address saved but the only way to find anything else is to actually traverse the list. By loading the next node, reading where it points to next and repeating until you find what you are looking for \n\nBoth data structures have pros and cons. And because of how they live in memory their respective functions like pop or push look different. As well as sorting and searching. There are all sorts of data structures as well.",
        "author": "Reddragonking42",
        "created_utc": 1748215001,
        "score": 10,
        "parent_id": "t3_1kvfo27",
        "depth": 0
      },
      {
        "id": "mu96baq",
        "body": "I can answer this from a few perspectives: readability, hardware, and functionality. \n\nYes, a queue or a stack can be (and often is) implemented as a dynamically-sized array. But *calling* it a queue makes it clear that you're dealing with its entries in a FIFO fashion. For example, the only difference between depth-first search and breadth-first search is whether you use a queue or a stack, so if you declare upfront what you're using, it makes it clear to me what you're doing. Make it into a priority queue, and you've basically got Dijkstra's algorithm, even if the underlying implementation of your PQ class is arrays.\n\nFrom a hardware perspective, an array all lives in a contiguous block of memory, which can (optionally) be accessed at arbitrary indexes. Anything that has more than O(1) memory blocks would need pointers, which makes it linked-list-like, or at least array-of-list-like. By construction, those are pretty much the only two kinds of data structure from a hardware perspective: O(1) memory blocks and stuff that doesn't have that. \n\nThen last is functionality. This boils down to what operations you can do, how long they take (in big-O form, but constants can matter a lot), and how much memory your data structure takes up.",
        "author": "Adventurous_Art4009",
        "created_utc": 1748215541,
        "score": 5,
        "parent_id": "t3_1kvfo27",
        "depth": 0
      },
      {
        "id": "mu95uv6",
        "body": "It is how the data is structured. The nuance that I think you need to answer your question  is that data structures are how the data is organized, and are used to implement Abstract Data Types (ADTs). These are defined by the operations that can be done on them. So a queue would be an ADT, while the underlying data structure would be an array (naively) or a linked list (O(1) implementation for insert and delete if the linked list stores the head and tail). A heap is another ADT, while the data structure would be either a binary tree or an array.",
        "author": "FrosteeSwurl",
        "created_utc": 1748215370,
        "score": 4,
        "parent_id": "t3_1kvfo27",
        "depth": 0
      },
      {
        "id": "mu96lf5",
        "body": "each one has pros and cons that make it better suited to a job or not.  But this is a terribly grey area when rolling your own, as you can blenderize them into hybrids or use one to build another and so forth.  Eg a linked list is a pretty solid stack because adding and removing off the top of the list is O(1), you never iterate the list.   Just a few days ago I was talking about a skip tree (like a skip list)...  so yea, you can mix and match some of the features across each other and changes the pros and cons to suit your needs so all the pros help you and none of the cons hurt you. \n\nDon't confuse implementation details with concept.  If you punch out a tree inside an array, its still a tree.  That darn grey area lets you iterate the array or do other array things to it (eg, save the whole array in one stop to a binary file) but if most of the useage is tree like, then its still a tree, it just supports a bit extra.   Or if you take a hash table that pools up the collisions into linked lists... hey, what if the key were called a priority?  Hey, now its a priority queue!  That kind of implementation detail voodoo of building one thing from something else makes the subject confusing at first, but the key is in how the final product is used.  If its an array used as a graph, its a graph.  If its a linked list used as a stack, its a stack.  The usage is the answer to your question.  How you build it is irrelevant.",
        "author": "Independent_Art_6676",
        "created_utc": 1748215643,
        "score": 2,
        "parent_id": "t3_1kvfo27",
        "depth": 0
      },
      {
        "id": "mua4hur",
        "body": "Using the right data structures can mean the difference between a program that takes 12+ hours or less than a few seconds to execute.  Learning data structures is *not* optional. \n\n\nThe big O of each method is the most practical difference that you'll interact with. \n\nFor example O(n) to check whether a value is in a list, versus O(1) to check whether a value is in a set implemented using a hash map.\n\nFor large N, it is the difference between instantaneous computation and a completely non-usable piece of software",
        "author": "Zskills",
        "created_utc": 1748228464,
        "score": 2,
        "parent_id": "t3_1kvfo27",
        "depth": 0
      }
    ],
    "1kv6nds": [
      {
        "id": "mubmw4v",
        "body": "Makes me wonder how much knowledge has already been lost to the shredder that could not be saved.",
        "author": "GoofAckYoorsElf",
        "created_utc": 1748257318,
        "score": 3,
        "parent_id": "t3_1kv6nds",
        "depth": 0
      }
    ],
    "1ku38kw": [
      {
        "id": "mtyjap4",
        "body": "If your randint method is supposed to be generating a number between x and y that is incorrect. That is generating a number between x and x+y",
        "author": "FrosteeSwurl",
        "created_utc": 1748061330,
        "score": 88,
        "parent_id": "t3_1ku38kw",
        "depth": 0
      },
      {
        "id": "mtykc7k",
        "body": "Nice OP! If you want to speed up your algo, instead of storing each birthday, keep an array of size 365, set each birthday to 0 each outer iteration. Every time you get a birthday, increment, and if you get a 2, increment count and break early.",
        "author": "InDiGoOoOoOoOoOo",
        "created_utc": 1748061828,
        "score": 73,
        "parent_id": "t3_1ku38kw",
        "depth": 0
      },
      {
        "id": "mtyr6oz",
        "body": "Stay addicted.",
        "author": "Alternative_Path5848",
        "created_utc": 1748065422,
        "score": 11,
        "parent_id": "t3_1ku38kw",
        "depth": 0
      },
      {
        "id": "mtzgti9",
        "body": "I volunteer to TA a few high school computer science classes.\n\nAfter a few months of coding, they write a program that will find the greatest common denominator between two humbers after the class collectively decides on a few different ways to do it.  After they are done, i poont out “that is the first time you wrote a program to ask the computer a question you yourself don’t know the answer to”.\n\n\nThat moment hooks a lot of them. Good job, op, for self-motivating yourself to do the same thing. Feed that beast and you’ll go far.\n\nBy, the way, you just independently re-invented the Monte-Carlo method. If you could time travel back to 1945, that technique might be named the ChickenFeline Method.\n\n\nGo read the wikipedia entry on it.",
        "author": "bokmann",
        "created_utc": 1748080877,
        "score": 10,
        "parent_id": "t3_1ku38kw",
        "depth": 0
      },
      {
        "id": "mtykysv",
        "body": "Fantastic",
        "author": "ShotSquare9099",
        "created_utc": 1748062131,
        "score": 7,
        "parent_id": "t3_1ku38kw",
        "depth": 0
      },
      {
        "id": "mtymvxp",
        "body": "Love your work bro, keep it up.",
        "author": "Interesting-Ad-238",
        "created_utc": 1748063097,
        "score": 7,
        "parent_id": "t3_1ku38kw",
        "depth": 0
      },
      {
        "id": "mtz6sk7",
        "body": "Great. One piece of advice: don't use AI. If it was easy to learn, no one is going to pay you for that skill. It scares me how many engineers I see coming out of school now who can't do anything without AI. Your brain is a muscle and it needs to be exercised in order for you to learn. Cheers.",
        "author": "fomq",
        "created_utc": 1748074624,
        "score": 8,
        "parent_id": "t3_1ku38kw",
        "depth": 0
      },
      {
        "id": "mtz66ts",
        "body": "which OS is that? it looks similar to windows but after looking at its other feature, it looks different.",
        "author": "Such_Arugula4536",
        "created_utc": 1748074250,
        "score": 2,
        "parent_id": "t3_1ku38kw",
        "depth": 0
      },
      {
        "id": "mtzih5s",
        "body": "Just a tip for more potentially skilled people here,   \n[https://codeforces.com/blog/entry/61587](https://codeforces.com/blog/entry/61587)   \nFor a more \"random\" function.",
        "author": "FrequentTown3",
        "created_utc": 1748081882,
        "score": 2,
        "parent_id": "t3_1ku38kw",
        "depth": 0
      }
    ],
    "1kuhxok": [
      {
        "id": "mu1qbet",
        "body": "https://craftinginterpreters.com/ is a good place to start",
        "author": "d_chae",
        "created_utc": 1748110957,
        "score": 7,
        "parent_id": "t3_1kuhxok",
        "depth": 0
      },
      {
        "id": "mu1wkoe",
        "body": "personally i found this series of videos useful as a starting point https://youtube.com/playlist?list=PLHh55M_Kq4OAmzC6zR7NXhZT9z21NkRCa&si=yoAryxL_J5D8vCAC",
        "author": "custard130",
        "created_utc": 1748113027,
        "score": 3,
        "parent_id": "t3_1kuhxok",
        "depth": 0
      },
      {
        "id": "mu1on74",
        "body": "Compiletely immerse yourself in them",
        "author": "Ok_Rip_5960",
        "created_utc": 1748110409,
        "score": 2,
        "parent_id": "t3_1kuhxok",
        "depth": 0
      },
      {
        "id": "mu699lq",
        "body": "Another comment already mentioned [Crafting Interpreters](https://craftinginterpreters.com/). [Modern Compiler Implementation](https://www.cs.princeton.edu/~appel/modern/) is another good resource - the exercises are great practice for implementing the algorithms you study (and there are C, Java, and ML versions).\n\n[Cooper and Torczon](https://www.google.co.uk/books/edition/_/xcJrEAAAQBAJ) is the kind of book a university mod might use. I like its detailed treatment of the algorithms, including stepping through the execution.",
        "author": "srsNDavis",
        "created_utc": 1748182028,
        "score": 2,
        "parent_id": "t3_1kuhxok",
        "depth": 0
      }
    ],
    "1kubw3s": [
      {
        "id": "mu0dolm",
        "body": "If it is not something that you can dig into directly, e.g. a DLL, then you have to rely on documentation. If the documentation is poor, or doesn't exist, then there's not much you can do except:\n\n1. Get rid of it\n\n2. Bang on it with a hammer (send in different parameters & inputs) until you understand how it likely works, or it starts working.\n\nDefinitely experienced it, and it is a reason I avoid libraries unless they have excellent documentation and/or have stood the test of time. For example, I feel pretty confident that numpy works.",
        "author": "Magdaki",
        "created_utc": 1748095471,
        "score": 11,
        "parent_id": "t3_1kubw3s",
        "depth": 0
      },
      {
        "id": "mu0iicd",
        "body": "on linux, `strace`, `dmesg`, reading the stderr output, increasing verbosity and checking other logs. for network stuff, `tcpdump` and `wireshark`. if it's FOSS, reading the source code is usually enough, and if it isn't, `ghidra` or `binja` with `gdb`.\n\nusually I go through these steps in order, no idea on windows though, but some steps may be replicable with an equivalent windows tool. anything that helps follow the program execution through time will help :)\n\nedit: grammar and completion",
        "author": "kedisdead",
        "created_utc": 1748097062,
        "score": 8,
        "parent_id": "t3_1kubw3s",
        "depth": 0
      },
      {
        "id": "mu2ild5",
        "body": "It depends.\n\nFirst, some good logging would help ( a lot)\n\nSecond for different system tools, there are certain tools you could use, like gdb for core dump, and heap/thread dump for Java.\nStrace to trace all syscalls\n\n\nFor deeper os level, you could hook the syscalls but very costly,",
        "author": "AppearanceAny8756",
        "created_utc": 1748120569,
        "score": 2,
        "parent_id": "t3_1kubw3s",
        "depth": 0
      }
    ],
    "1ktfi35": [
      {
        "id": "mtt528p",
        "body": "C/C++ is still required in industry.\n\n\nBut for fun I would try writing in rust or elixir.\n\n\nIf you want experience of programming then any functional language should boost you levels ",
        "author": "firemark_pl",
        "created_utc": 1747994757,
        "score": 13,
        "parent_id": "t3_1ktfi35",
        "depth": 0
      },
      {
        "id": "mtt4d4j",
        "body": "Rust is a nice spot if you want to be future proof; and probably will make you learn more",
        "author": "The-Malix",
        "created_utc": 1747994370,
        "score": 7,
        "parent_id": "t3_1ktfi35",
        "depth": 0
      },
      {
        "id": "mtt3dd1",
        "body": "1. What do you know now\n2. What do you enjoy (use wise)\n3. How much time you have",
        "author": "EatThatPotato",
        "created_utc": 1747993815,
        "score": 5,
        "parent_id": "t3_1ktfi35",
        "depth": 0
      },
      {
        "id": "mtt4yni",
        "body": "C++ is a good start; obfuscates enough to save some hassle, yet still verbose enough to build a foundation that makes learning additional languages much easier.  Recommend _Deitel and Deitel How To Program C++_.  5th edition is what I learned from and costs $5, but it goes up to 10th edition these days.",
        "author": "Ghosttwo",
        "created_utc": 1747994702,
        "score": 3,
        "parent_id": "t3_1ktfi35",
        "depth": 0
      },
      {
        "id": "mtt38ch",
        "body": "I enjoyed studying Ruby and I think I should have learned Haskell.\n\nmaybe you like both.\n\n_o/",
        "author": "ofernandofilo",
        "created_utc": 1747993737,
        "score": 2,
        "parent_id": "t3_1ktfi35",
        "depth": 0
      },
      {
        "id": "mttn3va",
        "body": "There are many model of computing. Two that became fundamental of everyday programming language are Turing machine (imperative or the typical programming as you know) and lambda calculus (declarative or functional).\n\nIt would be fun to know from both world, so maybe learning some Haskell.",
        "author": "recursion_is_love",
        "created_utc": 1748002940,
        "score": 2,
        "parent_id": "t3_1ktfi35",
        "depth": 0
      },
      {
        "id": "mttqezr",
        "body": "Choose one high level and one low level programming language to dig deep into. It could be as others suggested C++ and Python.",
        "author": "HaroldAFG",
        "created_utc": 1748004136,
        "score": 2,
        "parent_id": "t3_1ktfi35",
        "depth": 0
      },
      {
        "id": "mtuo84i",
        "body": "Learn C, get an embedded system of some sort (arduino, esp32, whatever you can find easily and cheaply). Do dev work on that to see what you think of the embedded world. Learn how to use a 3d library on Windows with C/C++ and see what you think of that side. After 3 months exploring each path, spend the last 6 months of the year diving deeper into whichever you like more at the time. Understand that whatever you wind up liking to do can change and that's ok. With a toe dipped into the water on both sides, you can switch in the future if your preferences change.",
        "author": "gatling_gun_gary",
        "created_utc": 1748014460,
        "score": 2,
        "parent_id": "t3_1ktfi35",
        "depth": 0
      },
      {
        "id": "mtykh60",
        "body": "If you really   want to  understand low level things and wiling to go with  microprocessor and micro controllers etc I would suggest you to go with c  , choose one language and stick with don't jump to c then rust  and so on",
        "author": "Deadbrain0",
        "created_utc": 1748061895,
        "score": 2,
        "parent_id": "t3_1ktfi35",
        "depth": 0
      },
      {
        "id": "mtzd9d6",
        "body": "._. I think solid knowledge of C / C ++ is great but I’d also recommend learning Rust since it’s being used a lot more now.",
        "author": "Humble_Wash5649",
        "created_utc": 1748078665,
        "score": 2,
        "parent_id": "t3_1ktfi35",
        "depth": 0
      },
      {
        "id": "mu67tny",
        "body": "C/C++ is pretty much essential for low-level and systems stuff. Python is higher level and used a lot in scientific computing and the current hot topic - AI/ML.\n\nA formal CS education will likely teach you a language that's better suited to learning about computational constructs (usually, it's something like Haskell or Scheme/Lisp) - though this might vary by course (e.g., an SWE or IT degree might not cover this but a CS or maths and CS one almost certainly will).\n\nYou'll likely pick up other languages down the road, but treat them on a need-to-know basis.\n\n**For game development**: For building anything serious, you'll need to get acquainted with a game engine. For scripting in engines, C/C++ is supported by most industry tools, a big reason being performance. Unity uses C# for scripting (should be easy to pick up if you know C/C++).\n\n**Software development**: Large variation but Java remains a popular choice I haven't mentioned already. Microsoft's ecosystem likes C#, Apple's likes Swift and Objective-C. For anything web, you'll likely be working with at least some JavaScript.\n\n**Tip**: I'd go with Python and C/C++ (and definitely a functional language like Haskell if I'm more into computational structures) and pick up anything else as and when I need it. There's a lot to learn in CS/SWE/IT that isn't just programming languages.",
        "author": "srsNDavis",
        "created_utc": 1748181549,
        "score": 2,
        "parent_id": "t3_1ktfi35",
        "depth": 0
      },
      {
        "id": "mu734d4",
        "body": "C is a good base language to know. Especially if you eventually want to start learning kernel-level development. C++ is just C with some extra useful features like classes and easier error handling. I would learn C first and then move on to C++, as it's easier to move from C to C++ than vise versa. \n\nAs for all the people saying rust, it's the new hotness right now, but I have my doubts about it staying around. I remember when people were thinking Kotlin was going to overtake Java. But we all see how that went.",
        "author": "Kuro222",
        "created_utc": 1748191261,
        "score": 2,
        "parent_id": "t3_1ktfi35",
        "depth": 0
      },
      {
        "id": "mube2cx",
        "body": "My first language was cpp, my most used and favorite language now is C. Point is that they are so syntactically similar that if you understand one you can have a seamless transition to the other. The world practically runs on C, stay away from python or any heavily abstracted languages if you want to do anything with games or MCUs. When I was learning I often found that the abstractions from higher level languages confused me more.",
        "author": "Bold2003",
        "created_utc": 1748252378,
        "score": 2,
        "parent_id": "t3_1ktfi35",
        "depth": 0
      }
    ],
    "1ksd8sc": [
      {
        "id": "mtkjmjl",
        "body": "Sometimes, recursion is conceptually easier. Many times, the costly factor is not CPU time, but engineer time.\n\nThink about binary search in an array. You could write it as a loop and modify start and end index. But if your function looks like \\`find(data, item, start, end)\\`... why not use that? It's exactly what you need to dive into the correct subrange.",
        "author": "OddChoirboy",
        "created_utc": 1747872910,
        "score": 244,
        "parent_id": "t3_1ksd8sc",
        "depth": 0
      },
      {
        "id": "mtkk60k",
        "body": "The short answer is that a loop together with a stack is sufficient to emulate recursion (i.e. you don't *need* it to be Turing Complete).  However, recursion makes some programs simpler to write, so it's a helpful construct to have in a language.",
        "author": "apnorton",
        "created_utc": 1747873100,
        "score": 101,
        "parent_id": "t3_1ksd8sc",
        "depth": 0
      },
      {
        "id": "mtl53wv",
        "body": "Lots of good answers, but I don't think anyone has mentioned that recursion makes it easier to prove correctness by induction.",
        "author": "zenidam",
        "created_utc": 1747880427,
        "score": 99,
        "parent_id": "t3_1ksd8sc",
        "depth": 0
      },
      {
        "id": "mtkr47y",
        "body": "I find recursion just makes sense for problems where you would otherwise need to create your own stack manually. For example, inverting a binary tree is 2 lines if you use recursion. If you try to do it without recursion, you'll quickly find a simple while loop can't replace the recursion",
        "author": "ThaBroccoliDood",
        "created_utc": 1747875519,
        "score": 28,
        "parent_id": "t3_1ksd8sc",
        "depth": 0
      },
      {
        "id": "mtkn6lq",
        "body": "Personally, I found that after some practice, it was simpler to understand than iteration..",
        "author": "sacheie",
        "created_utc": 1747874165,
        "score": 18,
        "parent_id": "t3_1ksd8sc",
        "depth": 0
      },
      {
        "id": "mtl2euh",
        "body": "A loop requires mutable state, while recursion can solve the same problems with static single assignments.\n\n\nAlthough you might consider this a disadvantage if there is a lot of state, a lot of bugs in loops come from not updating each piece of state on each path of execution. With recursion and immutable variables, each piece of state is guaranteed to be updated exactly once, by the recursive call, and only then, never in between. The compiler will not allow you to update in two different places or forget to specify what any piece of the new state should be.\n\n\nMany compilers convert the intermediate representations of their code to either static single assignment form or continuation-passing style, and tail-recursion matches this structure closely.",
        "author": "DawnOnTheEdge",
        "created_utc": 1747879486,
        "score": 18,
        "parent_id": "t3_1ksd8sc",
        "depth": 0
      },
      {
        "id": "mtlisml",
        "body": "I use recursion in tree traversal.\n\nEssentially you are using the program stack as your \"stack\".\n\nIt makes it easier to develop and think about.",
        "author": "rupertavery",
        "created_utc": 1747885534,
        "score": 12,
        "parent_id": "t3_1ksd8sc",
        "depth": 0
      },
      {
        "id": "mtklsqc",
        "body": "Recursivity let you solve many problems very elegantly. They're often incredibly readable, because they break stuff down clearly into:\n\n1) A clear set of end conditions\n\n2) A way to solve the problem by making it smaller. \n\nYou also dismiss data structures, but that's kinda short sighted. Most functions operate on or in tandem with data structures. We use a ton that are inherently recursive; trees and graphs are incredibly common. Their structures often make recursion easier to conceptualize. \n\nThat said, iteration is preferred. It's much more flexible, as well as safer.",
        "author": "DTux5249",
        "created_utc": 1747873674,
        "score": 11,
        "parent_id": "t3_1ksd8sc",
        "depth": 0
      },
      {
        "id": "mtknurp",
        "body": "Recursion might be conceptually simpler for some cases. Fortran 77 did not have stack (data had separate area) so recursive calls did not have much penalty. For most other languages recursive calls add some performance penalty due to stack push/pop which simple loops don't have (loops can be optimized to simple compare and jump in assembly/machine code level). \n\nRecursion also has problem in that even though stack may grow there are still limits to how much it can grow: if you are not careful you can crash program due to too deep recursion.",
        "author": "ilep",
        "created_utc": 1747874397,
        "score": 7,
        "parent_id": "t3_1ksd8sc",
        "depth": 0
      },
      {
        "id": "mtkt3rf",
        "body": "Because recursion can be the simplest possible solution to a problem.  Take a look at depth-first or breadth-first search algorithms in their iterative and recursive solutions.",
        "author": "James-Kane",
        "created_utc": 1747876221,
        "score": 6,
        "parent_id": "t3_1ksd8sc",
        "depth": 0
      },
      {
        "id": "mtl9w7p",
        "body": "From a Formal Methods perspective, recursion makes mathematical formulations of functions significantly easier, and significantly simplifies proofs as it easily allows for induction. That is why functional languages love recursion, because that's how functions are modeled with lambda calculus",
        "author": "Character_Cap5095",
        "created_utc": 1747882132,
        "score": 5,
        "parent_id": "t3_1ksd8sc",
        "depth": 0
      },
      {
        "id": "mtltjo5",
        "body": "Probably the best example of using a recursive function is browsing a filesystem. \n\nYou make a function that scans a folder, and you call it on the root level of your disk. It makes a list of everything in that directly, it DOES use a while loop to loop through each item and do whatever it is you're trying to do. But every time you hit a folder, you need to call the recursive function again, on that NEW folder. Then in that folder you have to do the same thing. Theres no possible way to know ahead of time what the structure of the filesystem is going to be or even how many levels deep it will go. But with recursive functions, its very easy to search through the entire filesystem. Without that ability, it would be very difficult to do.",
        "author": "l008com",
        "created_utc": 1747890491,
        "score": 4,
        "parent_id": "t3_1ksd8sc",
        "depth": 0
      },
      {
        "id": "mtkto45",
        "body": "Recursion is the natural way many CS algorithms (binary search) and mathematical sets are defined. I can’t recall right now but there is a sorting algorithm that you can’t implement with a loop without using an explicit stack. At that point you are pretty much simulating recursion so might as well use recursion with the implicit call stack.",
        "author": "aka1027",
        "created_utc": 1747876419,
        "score": 2,
        "parent_id": "t3_1ksd8sc",
        "depth": 0
      },
      {
        "id": "mtmv9yp",
        "body": "I’ve seen folks mention tail calls here but wanted to also add that many compilers/interpreters can automatically use iterative behavior when they detect tail call recursion. It’s sometimes called Tail Call Optimization or Tail Call Elimination.\n\nhttps://en.wikipedia.org/wiki/Tail_call",
        "author": "eg_taco",
        "created_utc": 1747912000,
        "score": 2,
        "parent_id": "t3_1ksd8sc",
        "depth": 0
      },
      {
        "id": "mtn0lxo",
        "body": "There are some optimization algorithms (Bellman’s equations) that require recursion as part of the algorithm definition. Those equations are the foundation for reinforcement learning and markov decision processes",
        "author": "Streletzky",
        "created_utc": 1747914342,
        "score": 2,
        "parent_id": "t3_1ksd8sc",
        "depth": 0
      },
      {
        "id": "mtnzpbu",
        "body": "Sit down and try to complete the Towers of Hanoi problem. This is my personal favorite example for the usage of recursion. It will click once you understand the Towers of Hanoi.",
        "author": "scalesuite",
        "created_utc": 1747926118,
        "score": 2,
        "parent_id": "t3_1ksd8sc",
        "depth": 0
      }
    ],
    "1ks16n4": [
      {
        "id": "mths1a7",
        "body": "SICP — it introduced me to lisp, the exercises are fun, and it taught me how to think about computation, especially recursion.",
        "author": "sudobear",
        "created_utc": 1747843159,
        "score": 54,
        "parent_id": "t3_1ks16n4",
        "depth": 0
      },
      {
        "id": "mtiomff",
        "body": "\"Code: The Hidden Language of Computer Hardware and Software\" by Charles Petzold.",
        "author": "kusakka",
        "created_utc": 1747852443,
        "score": 29,
        "parent_id": "t3_1ks16n4",
        "depth": 0
      },
      {
        "id": "mtj6j2x",
        "body": "Crafting Interpreters by Robert Nystrom. I had created a few interpreters in the past, but I wrote them without any real foundation, just sort of figuring things out as I went. After reading this book, I feel like my most recent interpreter has a more coherent, solid foundation.\n\n\nOn top of that, the author writes in a very entertaining manner.",
        "author": "Dr_Bust-A-Loaf",
        "created_utc": 1747857599,
        "score": 25,
        "parent_id": "t3_1ks16n4",
        "depth": 0
      },
      {
        "id": "mthrcev",
        "body": "Love aho's books, \"Compilers: principles, techniques, and tools\" is a classic.",
        "author": "Interesting-Meet1321",
        "created_utc": 1747842962,
        "score": 19,
        "parent_id": "t3_1ks16n4",
        "depth": 0
      },
      {
        "id": "mtikoti",
        "body": "Sipser's Intro to Computation.\n\nWorking through this book really solidified my understanding of complexity. It's very formal and rigorous, which I like. Not everyone likes that.",
        "author": "fff1891",
        "created_utc": 1747851294,
        "score": 20,
        "parent_id": "t3_1ks16n4",
        "depth": 0
      },
      {
        "id": "mthwr3h",
        "body": "CLRS\n\n/s",
        "author": "pablo55s",
        "created_utc": 1747844532,
        "score": 14,
        "parent_id": "t3_1ks16n4",
        "depth": 0
      },
      {
        "id": "mtin7xb",
        "body": "I guess it depends on a lot of different variations as to what you define \"best\". I think that might be a relative term related to where a person is in their CS career. Like most (assumed) when you start out you tend to focus on learning the specifics of a language. Later you might realize the language does not matter s much as solid design skills. \n\nWhen I first started in CS (first real job), I was writing lots of low level C code on HPUX. Lots of network related coding. I found the books of Richard Stevens, \"TCP/IP Illustrated Vol1\", \"TCP/IP Illustrated Vol2\", \"UNIX Network programming - Interprocess Communications\", and \"Advanced Programming in the UNIX Environment\"  invaluable. I had two sets. One for the office and one for home. This was late 80s and early 90s. \n\nLater in my career I moved to less \"here are code examples\" to more educational and philosophical books like \"Design Patterns - Elements of Reusable Object-Oriented Software by Gamma, Helm, Johnson, and Vlissides (Gang of Four)\" and \"Algorithms\" by Sedgewick, and most of the books by Grady Booch on UML modeling helped me. \n\nMuch later, I found deeper, more esoteric leterature like Donald Knuth's books \"That Art of Computer Programming\" and one of my all time favorites \"A Philosophy of Software Design\" by John Osterhout.",
        "author": "Coderules",
        "created_utc": 1747852038,
        "score": 10,
        "parent_id": "t3_1ks16n4",
        "depth": 0
      },
      {
        "id": "mths0ay",
        "body": "Physically Based Rendering",
        "author": "laniva",
        "created_utc": 1747843152,
        "score": 9,
        "parent_id": "t3_1ks16n4",
        "depth": 0
      },
      {
        "id": "mthv5dc",
        "body": "All of W. Richard Stevens books.  \n\nThey aren't theoretical computer science, but rather the nuts and bolts of operating systems and networking internals and APIs.\n\nBut they are so well-written that they also help to shed light on basic principles.",
        "author": "pconrad0",
        "created_utc": 1747844067,
        "score": 6,
        "parent_id": "t3_1ks16n4",
        "depth": 0
      },
      {
        "id": "mtuck67",
        "body": "Operating Systems: Three Easy Pieces and Computer Systems: A Programmer’s Perspective",
        "author": "dancingelves33",
        "created_utc": 1748011155,
        "score": 6,
        "parent_id": "t3_1ks16n4",
        "depth": 0
      },
      {
        "id": "mti9bsz",
        "body": "Skeina and K&R",
        "author": "CreeperDrop",
        "created_utc": 1747848107,
        "score": 5,
        "parent_id": "t3_1ks16n4",
        "depth": 0
      },
      {
        "id": "mtie05f",
        "body": "The Cartoon Guide to Computer Science, by Larry Gonick.\n\nDespite being a cartoon book (and being a bit obsolete as it is from the 80's), it explains a broad range of topics: from the beginnings of computing, binary system, how to make general purpose logic circuits, how a CPU works, etc.",
        "author": "MasterGeekMX",
        "created_utc": 1747849404,
        "score": 4,
        "parent_id": "t3_1ks16n4",
        "depth": 0
      },
      {
        "id": "mtivj1t",
        "body": "I am still reading various CS books, like the classics everyone mentions, but I'm starting to feel an issue. Maybe it lies at the heart of pedagogy and teaching methods itself, especially those books geared toward teaching, but I find these types to be very frustrating. Books that are meant to be reference and a big overview are fine, but teaching and learning styles vary vastly from person to person. Someone picking up a book on topic X probably has some understanding of X and that's what inspired them to get that book. Maybe they implemented something about X and thought this will fill in any gaps. But the book tries teaching from the ground up, tries talking about suboptimal methods for the sake of it, it's frustrating.\n\nA lot of people teach dynamic programming as a method with the usual Fibonacci numbers -> the big tree -> recursion/top down -> memoization -> bottom up -> space optimized. \n\nBut this makes people think dp is meant for this, while dp is simply a mathematical optimization technique which works in any application with subproblems that can be optimized and built up without changing the internal constituents. You simply need to work through many problems to get better at it, simply reading a text isn't enough",
        "author": "Tight-Requirement-15",
        "created_utc": 1747854448,
        "score": 4,
        "parent_id": "t3_1ks16n4",
        "depth": 0
      },
      {
        "id": "mtoiw5x",
        "body": "Computer Organization Architecture, Parallel Programming, Data Structures Algorithms, relational databases, and Artificial Intelligence. Short answer, all of them. Thank you",
        "author": "jhernandez9274",
        "created_utc": 1747931688,
        "score": 5,
        "parent_id": "t3_1ks16n4",
        "depth": 0
      },
      {
        "id": "mtmgw4d",
        "body": "Godel Escher Bach\n\nAnd when I was younger, The Little Schemer",
        "author": "Deflator_Mouse7",
        "created_utc": 1747903981,
        "score": 3,
        "parent_id": "t3_1ks16n4",
        "depth": 0
      },
      {
        "id": "mtm2o1e",
        "body": "._. Introduction to Automata Theory, Languages, and Computation.",
        "author": "Humble_Wash5649",
        "created_utc": 1747895368,
        "score": 2,
        "parent_id": "t3_1ks16n4",
        "depth": 0
      },
      {
        "id": "mtm81xd",
        "body": "Graphics Gems volume IV. Just full of interesting code.",
        "author": "nanonan",
        "created_utc": 1747898492,
        "score": 2,
        "parent_id": "t3_1ks16n4",
        "depth": 0
      },
      {
        "id": "mtmne06",
        "body": "OS by tannenbaum",
        "author": "koxar",
        "created_utc": 1747907906,
        "score": 2,
        "parent_id": "t3_1ks16n4",
        "depth": 0
      },
      {
        "id": "mudk8td",
        "body": "Just sharing my point of view and not really answering the question... It feels so good to know that people have still held on to books even in today's overly dense YouTube-tutorials world. Books are king and will always be!",
        "author": "Competitive_Aside461",
        "created_utc": 1748281083,
        "score": 2,
        "parent_id": "t3_1ks16n4",
        "depth": 0
      }
    ],
    "1krv0xy": [
      {
        "id": "mtgc5yi",
        "body": "Ive never heard that x^0.5 is not a function. Think your book/slide is using some outdated or different definition of a function.",
        "author": "Twt97",
        "created_utc": 1747825775,
        "score": 29,
        "parent_id": "t3_1krv0xy",
        "depth": 0
      },
      {
        "id": "mtgi9tc",
        "body": "If  x^(0.5)  is not a function because it returns two values, how is  e^(x) a function, considering that it has e^(0.5)? That slide makes no sense.",
        "author": "JeLuF",
        "created_utc": 1747828468,
        "score": 25,
        "parent_id": "t3_1krv0xy",
        "depth": 0
      },
      {
        "id": "mtgyfjp",
        "body": "x^0.5 is the same as sqrt(x). The square root of any positive number has two answers, a positive one and a negative one. For example, the square root of 9 is 3 and -3. However, when we use it like this we usually are referring to the principal square root, in layman's terms just the positive number. So your book is wrong, x^0.5 is indeed a function.",
        "author": "fourteensoulsies",
        "created_utc": 1747834410,
        "score": 6,
        "parent_id": "t3_1krv0xy",
        "depth": 0
      },
      {
        "id": "mtgt61s",
        "body": "OMFG. I was wondering why we're people arguing x^0.5 was multivalued until I saw the name of the sub\n\nGuys, x^0.5 is just Sqrt(X)! Nothing more, nothing less",
        "author": "Xehanz",
        "created_utc": 1747832617,
        "score": 5,
        "parent_id": "t3_1krv0xy",
        "depth": 0
      },
      {
        "id": "mth53mo",
        "body": "Long & short, the definitions they give as to why it's not a function are piss-poorly specified.  Let's start with the fact that x\\^0.5 = sqrt( x ) — nothing fancy.  In its \"pure\" math form, sqrt(x), for any positive value x, returns **both** a positive, and a negative result (+/- y) — and *that* is what makes it not a function: A function must return **exactly** one result for each input value ( [https://en.wikipedia.org/wiki/Function\\_(mathematics)](https://en.wikipedia.org/wiki/Function_(mathematics)) ).\n\nabs( sqrt( x ) ) doesn't have the same problem, it'll always yield a singular positive value.\n\nThis is kinda bullshit from a CompSci perspective, since sqrt( x ) is defined as only ever returning the positive result, and is thus a function, but seems like your teacher wants to toss in pure maths to troll.",
        "author": "Silly_Guidance_8871",
        "created_utc": 1747836494,
        "score": 2,
        "parent_id": "t3_1krv0xy",
        "depth": 0
      }
    ],
    "1kr6pyj": [
      {
        "id": "mtbwwf5",
        "body": "Here's the PDF version of the essay: https://courses.cs.umbc.edu/471/papers/turing.pdf\n\nThe imitation game has now been conclusively solved, but whether machines can 'think' is still widely debated.",
        "author": "currentscurrents",
        "created_utc": 1747762468,
        "score": 7,
        "parent_id": "t3_1kr6pyj",
        "depth": 0
      }
    ],
    "1kr4rhv": [
      {
        "id": "mtarow6",
        "body": "With respect to data, you can buy tick-level trade data. There are a few different vendors out there.",
        "author": "Magdaki",
        "created_utc": 1747750427,
        "score": 2,
        "parent_id": "t3_1kr4rhv",
        "depth": 0
      },
      {
        "id": "mtat5yr",
        "body": "You want microsecond, not millisecond level resolution.\n\nLow latency in C++ is not that hard. Just follow good principles and be aware of latency and speed at every step of your architecture design. \n\nYour Networking, not your cpu, will almost always be your bottleneck. Unless you start doing the fancy stuff like kernel bypass networking, any decently designed architecture will get you acceptable, but not competitive, real time performance. \n\nIf you want to compete strictly on a latency basis in hft, that's a tall order and probably not worth your time. There lies the land of FPGAs, direct fiber or radio, and negative latency due to partial packet reads",
        "author": "Brambletail",
        "created_utc": 1747750880,
        "score": 2,
        "parent_id": "t3_1kr4rhv",
        "depth": 0
      }
    ],
    "1kqrqjc": [
      {
        "id": "mt7uixl",
        "body": "It's not limited by traditional computing speeds though. You are not trying to communicate with a normal computer. You already have the payloads and the encrypted messages on the quantum computer. I'd imagine every nation has been intercepting and storing petabytes of encrypted data for years now. When quantum computers are actually powerful enough to crack them, they will all be decrypted locally on the quantum computers. That's why we need to be encrypting everything with quantum resistant algorithms right now, not at some point in the future when the first quantum computers capable of cracking are running.",
        "author": "Aegan23",
        "created_utc": 1747701460,
        "score": 95,
        "parent_id": "t3_1kqrqjc",
        "depth": 0
      },
      {
        "id": "mt7ul04",
        "body": "Because in this scenario you _aren't_ limited by the devices being cracked.\n\nTake HTTPS as an example. When you connect to a website over HTTPS, the web server sends you its public cryptographic key. In theory, it may be possible to quickly derive the private key based on the public key with a quantum computer. You don't need to have any further communication with the web server after obtaining its public key, and can run the attack completely offline.",
        "author": "nuclear_splines",
        "created_utc": 1747701482,
        "score": 27,
        "parent_id": "t3_1kqrqjc",
        "depth": 0
      },
      {
        "id": "mt7veun",
        "body": "It isn’t limited by the speed of the device being cracked, that’s why.",
        "author": "Rolex_throwaway",
        "created_utc": 1747701788,
        "score": 7,
        "parent_id": "t3_1kqrqjc",
        "depth": 0
      },
      {
        "id": "mt85rh1",
        "body": "Your question shows you don’t understand the issue. Shor’s algorithm can be used to efficiently solve many difficult math problems upon which relies the security of many of the currently used crypto systems. Examples include RSA which relies on integer factorisation being difficult. And Shor’s algorithm can efficiently factor integers.",
        "author": "aka1027",
        "created_utc": 1747705637,
        "score": 7,
        "parent_id": "t3_1kqrqjc",
        "depth": 0
      },
      {
        "id": "mt7ty3h",
        "body": "https://www.reddit.com/r/QuantumComputing/s/WI9gzHhFRT",
        "author": "coolmint859",
        "created_utc": 1747701247,
        "score": 3,
        "parent_id": "t3_1kqrqjc",
        "depth": 0
      },
      {
        "id": "mt830q4",
        "body": "Because no hacker is entering passwords directly onto your phone using its UI. They open your phone, read the encrypted password and encryption key, and then brute force it on their own machines.",
        "author": "DTux5249",
        "created_utc": 1747704620,
        "score": 3,
        "parent_id": "t3_1kqrqjc",
        "depth": 0
      },
      {
        "id": "mt9k97f",
        "body": "Where did you get the idea that they're limited in the way you describe? They aren't. ",
        "author": "RavkanGleawmann",
        "created_utc": 1747731242,
        "score": 4,
        "parent_id": "t3_1kqrqjc",
        "depth": 0
      }
    ],
    "1kpu092": [
      {
        "id": "mt0k2kg",
        "body": "Me looking to find a perspective other my professor:\n\n\nIt's a linkedin post from my professor 🤦‍♂️",
        "author": "Awes12",
        "created_utc": 1747601575,
        "score": 533,
        "parent_id": "t3_1kpu092",
        "depth": 0
      },
      {
        "id": "mt0tzyx",
        "body": "Accurate! I have personally witnessed non developers create \"amazing\" (at first glance) apps using AI and tools that facilitate vibe coding. The issue becomes that they have no idea how to debug the code, they don't know what any of it means, if it's organized well, efficient or not, if it's secure, if they're using the best tool for the job, etc. it's like building a fence that looks nice but it's made of plywood and concrete superglued and ducttaped together, then painted over with acrylics.",
        "author": "MountainMommy69",
        "created_utc": 1747604813,
        "score": 232,
        "parent_id": "t3_1kpu092",
        "depth": 0
      },
      {
        "id": "mt0ow0k",
        "body": "Wait vibe coding is a serious thing and not just a meme?",
        "author": "Eagle_215",
        "created_utc": 1747603118,
        "score": 107,
        "parent_id": "t3_1kpu092",
        "depth": 0
      },
      {
        "id": "mt1amz8",
        "body": "Let them “vibe code”. It creates more jobs for us in the near future to clean up all the mess.",
        "author": "winterchainz",
        "created_utc": 1747610713,
        "score": 100,
        "parent_id": "t3_1kpu092",
        "depth": 0
      },
      {
        "id": "mt1vdlu",
        "body": "“In the beginning you always want results. In the end all you want is control.” - Eskil Steenberg.",
        "author": "ESHKUN",
        "created_utc": 1747618429,
        "score": 29,
        "parent_id": "t3_1kpu092",
        "depth": 0
      },
      {
        "id": "mt1cqcq",
        "body": "Guys if you’re looking for the next big field it’s QA",
        "author": "LaggySon",
        "created_utc": 1747611471,
        "score": 28,
        "parent_id": "t3_1kpu092",
        "depth": 0
      },
      {
        "id": "mt109so",
        "body": "I bet replies to this post contain a fair share of '... lol, if this guy were any good, he'd be working in industry, those who can't, teach', etc. etc.",
        "author": "Druben-hinterm-Dorfe",
        "created_utc": 1747606958,
        "score": 24,
        "parent_id": "t3_1kpu092",
        "depth": 0
      },
      {
        "id": "mt17b8c",
        "body": "Vibe coding might be dumb, but dismissing AI as the same as any of these tools is insane. The difference is *dramatic* between what those could do and what, say, gpt 4.1 can do. And this is still the infancy. \n\n\nI hate this word but..this comes off as either cope or this is a really dramatic example of a false equivalency.",
        "author": "ODaysForDays",
        "created_utc": 1747609501,
        "score": 18,
        "parent_id": "t3_1kpu092",
        "depth": 0
      },
      {
        "id": "mt12y9s",
        "body": "HyperCard was great. It was like Visual Basic if your programs ran in a PowerPoint presentation instead of a window.\n\nThe original Mac version of Myst was written in HyperCard.\n\nIf HyperCard was around today, people would be using it to write horny visual novels.",
        "author": "Robot_Graffiti",
        "created_utc": 1747607912,
        "score": 14,
        "parent_id": "t3_1kpu092",
        "depth": 0
      },
      {
        "id": "mt0l3yj",
        "body": "100% the current AI needs a human supervisor !\n\n  \nIt misunderstand the problem. Makes too much code in a mixed style.\n\n  \nUses objects , where simple functions could do the trick much better and faster.\n\n  \nUses hard coded variables, no global variable array.\n\n  \nAI code is messy. Best guess is to let it code in short segments , one function at the time.\n\n  \nFor that , the human supervisor is needed !",
        "author": "epSos-DE",
        "created_utc": 1747601904,
        "score": 13,
        "parent_id": "t3_1kpu092",
        "depth": 0
      },
      {
        "id": "mt167zi",
        "body": "The comparison between vibe coding and no-code tools is accurate for a regular user. Regular users get frustrated with no-code tools because it's WAY more work than they're anticipating, and you still need to have some technical ability. They learn this the hard way. And they end up just hiring someone to do it. This is despite the fact there is absolutely no coding involved, it's too difficult for a regular user.\n\nIt's the same thing with vibe coding, noobies get frustrated when AI runs in a loop, truncates files, makes mistakes and they have no version controlling. They don't even know how to prompt AI to get what they want and their requirements are too vague and might be conflicting. So days of prompting turn into weeks, weeks may turn into months. \n\nWhich noobies are going to do all this? None. They'll have to hire someone to do it. And that's not even mentioning hosting, security, and scaling the app.",
        "author": "RemoteChange2954",
        "created_utc": 1747609103,
        "score": 13,
        "parent_id": "t3_1kpu092",
        "depth": 0
      },
      {
        "id": "mt27f0n",
        "body": "It's lego coding, and it'll create garbage that'll hog resources. If that's what the market wanted, everything would have been Python by now.",
        "author": "TotalBismuth",
        "created_utc": 1747623027,
        "score": 12,
        "parent_id": "t3_1kpu092",
        "depth": 0
      },
      {
        "id": "mt1aia3",
        "body": "I want to say based based based based based but i am just afraid this post might just be confirmation bias for me\n\nSo i want other perspectives on the subject i a",
        "author": "Rainy_Wavey",
        "created_utc": 1747610667,
        "score": 9,
        "parent_id": "t3_1kpu092",
        "depth": 0
      },
      {
        "id": "mt17fqz",
        "body": "Am I just using the wrong AI? Free ChatGPT isn’t anywhere close to being able to build me anything more complex than a year 1 CS student exam question. It can help me debug snippets pretty well and I find it useful for boiling down documentation",
        "author": "FantasticEmu",
        "created_utc": 1747609548,
        "score": 4,
        "parent_id": "t3_1kpu092",
        "depth": 0
      },
      {
        "id": "mt4gw9n",
        "body": "A bunch of ignorant nonsense. Just because Borland Delphi was a fully-fledged, fairly low-level programming language (comparable to C++) with its own development environment. Yes, it had an advanced UI designer for its time, but developing in that language required no less programming knowledge than C++, and the learning curve was about the same. And it was successfully used to develop quite complex software products by the time (Total Commander, FL Studio, Skype, The Bat, etc.).  \nIt wasn’t even remotely close the no/low-code concept.\n\nThe author threw everything into one pile: Delphi as a programming language and Crystal Reports as a reporting tool (as if people today are generating reports using low-level code).",
        "author": "elite-data",
        "created_utc": 1747663618,
        "score": 4,
        "parent_id": "t3_1kpu092",
        "depth": 0
      },
      {
        "id": "mt1bifw",
        "body": "Honestly, the number of projects I’ve been on and said “honestly, this could be done in FileMaker for a lot cheaper” is pretty damn high. Many “serious businesses” spend a lot of time worrying about what will happen when they reach some point on the horizon where these tools will stop working for them while ignoring how they’ll actually get there.\n\nNot to say I disagree with the broader point, but comparing those tools to vibe coding isn’t 1:1.",
        "author": "WhiskyStandard",
        "created_utc": 1747611027,
        "score": 2,
        "parent_id": "t3_1kpu092",
        "depth": 0
      },
      {
        "id": "mt1me44",
        "body": "One difference is that no code tools were useless for experts, now, AI vibe coding actually has positive benefits for people who do know what they’re doing. \n\nThat said other tools were developed for experts to help them be more productive and efficient so the only real difference is that the same tool benefits, both population rather than needing different tools for each population.",
        "author": "solarmist",
        "created_utc": 1747615062,
        "score": 4,
        "parent_id": "t3_1kpu092",
        "depth": 0
      },
      {
        "id": "mt32u9y",
        "body": "I'm just looking forward to all the well paying consultant positions refactoring and bug fixing load bearing vibe code that starts failing.",
        "author": "Da_Di_Dum",
        "created_utc": 1747639336,
        "score": 3,
        "parent_id": "t3_1kpu092",
        "depth": 0
      },
      {
        "id": "mt1glg3",
        "body": "It's different this time\n\nSure, vibe coding doesn't deliver\n\nBut it enables programmers to do more in less time, so companies need less programmers than before",
        "author": "fig0o",
        "created_utc": 1747612888,
        "score": 2,
        "parent_id": "t3_1kpu092",
        "depth": 0
      },
      {
        "id": "mt1gpbg",
        "body": "These opinions always try to freeze time and run with the idea of \"this is the best it can do.\"\n\nTrue in context, but I see vibe coding as basically preparation to what AI assistants will (probably, hopefully) be able to do in few years.\n\nI do think that losing the deep know-how of how things work and get done in the future is quite a worrying prospect. I hope there will always be enough neuro-divergent people to meticulously study these things even when there's no need or reward to do so.",
        "author": "MostSharpest",
        "created_utc": 1747612927,
        "score": 2,
        "parent_id": "t3_1kpu092",
        "depth": 0
      }
    ],
    "1kqih1q": [
      {
        "id": "mt61qkj",
        "body": "I saw this previously and I really like it. I'm not teaching an assembly course right now, but if I were I would 100% use this in the course. It is very cool!",
        "author": "Magdaki",
        "created_utc": 1747680478,
        "score": 3,
        "parent_id": "t3_1kqih1q",
        "depth": 0
      }
    ],
    "1kp5o55": [
      {
        "id": "msvcvnf",
        "body": "The algorithm you've described using dependency analysis is a valid solution to generalized scheduling problems! Modern computer pipelines that do out-of-order execution really are similar. Operations are reordered in a reorder buffer to parallelize independent computation and keep the pipeline as full as possible. It's conceptually similar to assembling the DAG of operations, topologically sorting the elements, and then executing the topological generations in parallel. RISC instruction sets naturally make those operations elementary.\n\nThere are similar techniques applied for operating system scheduling, job processing in applications, etc.\n\nYou're hitting on a very real concept, but as you are discovering, the devil is in the details. If you're interested in continuing with it for learning's sake by all means. But there are also likely off the shelf implementations that have hammered out the details already if you are purely concerned with applying it. In fact, ML libraries like PyTorch operate on a graph structure and interface with the GPU for maximally efficient execution, so they may already provide natural implementations of this concept. Worth investigating",
        "author": "Vallvaka",
        "created_utc": 1747523621,
        "score": 8,
        "parent_id": "t3_1kp5o55",
        "depth": 0
      },
      {
        "id": "msve736",
        "body": "It depends on what you mean by pursue. For the sake of self education, or for fun, certainly. If you mean from the perspective of something novel, or a publication, then you really need to look through the literature and see if this is new. DAG-based parallelism has existed for a very long time, and there's been a surge in such research in the past 15 years or so (due to the rise of GPUs). So, there's at least a fair chance it already exists.\n\nOverall, it comes down to being the right tool for the proper job. Sometimes SIMT is the right choice, and sometimes it will be another paradigm, such as parallel DAG.\n\nBut assuming you came up with this on your own, its impressive and shows a lot of talent and promise.",
        "author": "Magdaki",
        "created_utc": 1747524090,
        "score": 4,
        "parent_id": "t3_1kp5o55",
        "depth": 0
      },
      {
        "id": "msvqifu",
        "body": "Hi, I was taking the Computer Enhance course from casey muratori, and he talks about SIMD (Single instruction multiple data) I think its similar to SIMT you mention about. I understand some of the things you say here, I am in general a react native developer getting into deep computer architecture and theres ton of stuff to learn. To see an 18 year old knowing this much and deep into this is amazing and also a little sad that I wish I could have done this earlier but its never too late as i am still 22\n\nI wanna get into x86 emulation on ARM based devices similar to (Winlator) but there are isnt a lot of resources \n\nAnyways, keep up the good work mate\n\nEdit: typo",
        "author": "space_quasar",
        "created_utc": 1747528812,
        "score": 3,
        "parent_id": "t3_1kp5o55",
        "depth": 0
      }
    ],
    "1knipc1": [
      {
        "id": "msiia6u",
        "body": "It hasn’t been relevant for years now. The hardline policy against “duplicate” questions made it so that once something is answered it never gets revisited, even if the answer is outdated.",
        "author": "-jp-",
        "created_utc": 1747341825,
        "score": 2354,
        "parent_id": "t3_1knipc1",
        "depth": 0
      },
      {
        "id": "msiirp8",
        "body": "Turns out chasing away every user and normalizing condescending responses isn't good for business",
        "author": "lipo_bruh",
        "created_utc": 1747341965,
        "score": 1811,
        "parent_id": "t3_1knipc1",
        "depth": 0
      },
      {
        "id": "msijn4c",
        "body": "Stack Overflow is getting marked as duplicate ",
        "author": "Orangutanion",
        "created_utc": 1747342218,
        "score": 856,
        "parent_id": "t3_1knipc1",
        "depth": 0
      },
      {
        "id": "msii4yk",
        "body": "Interesting that it's been on the decline since ~2017, well before LLMs caught the spotlight. Hard to blame this trend solely on developers asking CoPilot and ChatGPT for help instead of SO, or SO filling with AI slop",
        "author": "nuclear_splines",
        "created_utc": 1747341784,
        "score": 438,
        "parent_id": "t3_1knipc1",
        "depth": 0
      },
      {
        "id": "msinqhx",
        "body": "Back in the day I asked some questions on SO, never got an answer, got banned eventually (for asking questions that wouldn't engage traffic).\n\nI would eventually get more skilled myself, better/more effective at debugging.\n\nNowadays, chat gpt answers almost everything I throw at it and sprinkles in some unsolicited advice on the top of it.\n\nI'm not surprised SO is dead.",
        "author": "Fadeev_Popov_Ghost",
        "created_utc": 1747343431,
        "score": 207,
        "parent_id": "t3_1knipc1",
        "depth": 0
      },
      {
        "id": "msij7z6",
        "body": "What's the new thing? LLMs don't explain the decline as early as 2016",
        "author": "Single_Blueberry",
        "created_utc": 1747342098,
        "score": 96,
        "parent_id": "t3_1knipc1",
        "depth": 0
      },
      {
        "id": "msivf8d",
        "body": "Yeah... turns out locking 99% of all questions immediately, then down voting 800x and preventing people from even asking again (or answering any such threads) is actually a bad practice for a Q&A site. Who could've thunk it!",
        "author": "SoldRIP",
        "created_utc": 1747345779,
        "score": 88,
        "parent_id": "t3_1knipc1",
        "depth": 0
      },
      {
        "id": "msiluds",
        "body": "Good, fuck those mods",
        "author": "particlecore",
        "created_utc": 1747342865,
        "score": 47,
        "parent_id": "t3_1knipc1",
        "depth": 0
      },
      {
        "id": "msitqbw",
        "body": "Becuase you can't just ask YOUR question. They only care about questions that \"look good\" for the site. So they became a hugely popular google result, but nobody botheres to go there to ask new questions because they'll most likely just get deleted. Killed by their own moderation.",
        "author": "l008com",
        "created_utc": 1747345245,
        "score": 51,
        "parent_id": "t3_1knipc1",
        "depth": 0
      },
      {
        "id": "msirfrd",
        "body": "As a new developer years ago it was so snobby and unwelcoming- good riddance.",
        "author": "FatSucks999",
        "created_utc": 1747344546,
        "score": 34,
        "parent_id": "t3_1knipc1",
        "depth": 0
      },
      {
        "id": "msijy50",
        "body": "Are there any good alternatives? I found posting on relevant Sub-Reddits gives okay-ish results, but generally better than SO. \n\n  \nThe last few questions I asked on SO, I'm pretty sure I only got one response and they seemed like they were LLM responses anyways.",
        "author": "thehomelessman0",
        "created_utc": 1747342307,
        "score": 24,
        "parent_id": "t3_1knipc1",
        "depth": 0
      },
      {
        "id": "msiupww",
        "body": "People who want to learn do not want to be insulted on every question.",
        "author": "nous_entre_96",
        "created_utc": 1747345555,
        "score": 26,
        "parent_id": "t3_1knipc1",
        "depth": 0
      },
      {
        "id": "msilikv",
        "body": "Good fucking riddance",
        "author": "primaski",
        "created_utc": 1747342767,
        "score": 23,
        "parent_id": "t3_1knipc1",
        "depth": 0
      },
      {
        "id": "msinvz4",
        "body": "Why was this removed for not being on-topic lmao",
        "author": "MarvelsOfGuppyYT",
        "created_utc": 1747343476,
        "score": 19,
        "parent_id": "t3_1knipc1",
        "depth": 0
      },
      {
        "id": "msin98l",
        "body": "What is off topic about Stack Overflow?",
        "author": "david-1-1",
        "created_utc": 1747343290,
        "score": 12,
        "parent_id": "t3_1knipc1",
        "depth": 0
      },
      {
        "id": "msipr6n",
        "body": "Stack Overflow was a nightmare both as a resource and for answering questions. Out of date answers, overzealous moderation, sarcastic unhelpful answers, and often terribly worded questions, as well as having the delay between question and answer; especially if it was a particularly esoteric or unique question.\n\nStack Overflow served its purpose for a long time as a fairly useful forum for students who were learning or people working on their own projects and things like that. But of course with the rise of AI, you get the same random accuracy of answers (in my opinion, AI answers are fairly unrealiable) but delivered faster which allows people to iterate faster. You could make a post on Stack that would sit there for weeks and not get answered! \n\nAI does also suffer from the out of date information problem sometimes, but if you ask the right question (ie \"Where can I find the answer to X problem in my project\") it can be helpful. It's also helpful for error codes and simple logic sanity checks, which further decreased the need for Stack. It is a blessing though, as I believe the people left using Stack are probably the old tech wizards that are much more likely (now) to give better answers to questions.",
        "author": "JDSherbert",
        "created_utc": 1747344040,
        "score": 13,
        "parent_id": "t3_1knipc1",
        "depth": 0
      },
      {
        "id": "msimmr5",
        "body": "This post has been marked as duplicate /s",
        "author": "thomas_blanky",
        "created_utc": 1747343102,
        "score": 12,
        "parent_id": "t3_1knipc1",
        "depth": 0
      },
      {
        "id": "msixuvi",
        "body": "Only question is ever asked there got down voted and closed as already answered. It took me ages to solve that problem because of them cunts.\n\nI gave a genuine and real problem that in a certain context, might have seemed the same but was definitely  not.\n\nNo recourse, no answers, just ask it again.\n\nWankers. \n\nAi solves my queries now. 🤣",
        "author": "daRaam",
        "created_utc": 1747346564,
        "score": 14,
        "parent_id": "t3_1knipc1",
        "depth": 0
      },
      {
        "id": "msihnn6",
        "body": "That is quite sad to see",
        "author": "Open-Note-1455",
        "created_utc": 1747341645,
        "score": 11,
        "parent_id": "t3_1knipc1",
        "depth": 0
      },
      {
        "id": "msix9w0",
        "body": "LLMs are not toxic and you can ask the same things over and over again without being shamed by passive aggressive comments",
        "author": "UncarefulEngineer",
        "created_utc": 1747346372,
        "score": 10,
        "parent_id": "t3_1knipc1",
        "depth": 0
      }
    ],
    "1koinxc": [
      {
        "id": "msryy4j",
        "body": "Start here:\n\nDigital Design and Computer Architecture (any edition, but I prefer risc v) - Harris and Harris\n\nAfter that\n\nComputer organization and Design ( again, I prefer risc v) by Patterson and Hennessy\n\nAnd for the cherry on the top\n\nComputer architecture: a quantitative approach, by Hennessy and Patterson\n\n\nYou got a nice 6-12 months read there with a lot of exercises. Have fun!",
        "author": "_MeQuieroIr_",
        "created_utc": 1747480653,
        "score": 2,
        "parent_id": "t3_1koinxc",
        "depth": 0
      }
    ],
    "1knwhiu": [
      {
        "id": "mslhew9",
        "body": "ML is cool. Companies using ML to justify making their products significantly worse while cutting jobs is not cool.",
        "author": "JmacTheGreat",
        "created_utc": 1747387378,
        "score": 92,
        "parent_id": "t3_1knwhiu",
        "depth": 0
      },
      {
        "id": "msls2h1",
        "body": "There is still plenty of exciting research happening in machine learning that has nothing to do with language models. Yes, language models have sucked all the air out of the room and dominate the mediasphere and popular consciousness, which can be frustrating. Just go to Google Scholar, and type in \"machine learning\" and you'll find a whole world of other works being done. They may not be making billions in venture capital, or highlighted on the news, but they're still out there. As it has always been really. Most research is not heralded.\n\n[machine learning - Google Scholar](https://scholar.google.ca/scholar?hl=en&as_sdt=0%2C5&q=machine+learning&btnG=)",
        "author": "Magdaki",
        "created_utc": 1747393218,
        "score": 40,
        "parent_id": "t3_1knwhiu",
        "depth": 0
      },
      {
        "id": "msnfboy",
        "body": "Graph based techniques have been my obsession lately.",
        "author": "Zestyclose_Hat1767",
        "created_utc": 1747413122,
        "score": 10,
        "parent_id": "t3_1knwhiu",
        "depth": 0
      },
      {
        "id": "mso9691",
        "body": "You just reminded me that when I started my Bachelors (2017) I was so intrigued by NN that I programmed them in Java by myself - with an OO approach! That's right, each individual \"neuron\" was a seperate object! Man, that was fun. I got to meet ML in a 2 advanced courses in my bachelors (both in computer vision), but the black-box approach put me off. But of course, that's all anectodal - like u/Magdaki says, there's a lot of exciting research out there, for example last week my university invited a guest speaker talking about \"breaking apart\" those black boxes into something we can reason about! Did I understand what he was saying? Not really. Was it cool? Pretty cool.",
        "author": "JewishKilt",
        "created_utc": 1747421958,
        "score": 9,
        "parent_id": "t3_1knwhiu",
        "depth": 0
      },
      {
        "id": "msoyb1t",
        "body": "it comes in waves. I was around when ML was deeply uncool and the web was the greatest thing ever. Then ML slowly started getting cooler and had that special cool halo for a while. Then it became extremely successful and the sociopaths arrived. This is the way of the world. ",
        "author": "njoubert",
        "created_utc": 1747429657,
        "score": 6,
        "parent_id": "t3_1knwhiu",
        "depth": 0
      },
      {
        "id": "mspytp2",
        "body": "I remember when computers were cool, in the late 1990s.",
        "author": "Past-Listen1446",
        "created_utc": 1747443274,
        "score": 4,
        "parent_id": "t3_1knwhiu",
        "depth": 0
      },
      {
        "id": "mt9oz7q",
        "body": "It used to be fun before people started treating it as a way of \"solving all of humanity's problems\". The same kind of mindset that got us stuck with smartphones and constant surveillance at every corner of the planet (and even space). Those people ruin technology for the rest of us and then everybody can't help but to cringe at it whenever it's brought up. As an enthusiast, this is absolutely sad.",
        "author": "xstrawb3rryxx",
        "created_utc": 1747734251,
        "score": 2,
        "parent_id": "t3_1knwhiu",
        "depth": 0
      }
    ],
    "1kn159w": [
      {
        "id": "msenx17",
        "body": "Compiler optimisation has been known to be the dark arts where the boundaries of pure computational theory crosses into real life practical implementations. \n\nBut maybe this is just coming from me always being scared to dig into the source code of modern compilers.",
        "author": "mentix02",
        "created_utc": 1747290399,
        "score": 44,
        "parent_id": "t3_1kn159w",
        "depth": 0
      },
      {
        "id": "msg2e0e",
        "body": "Known by reverse engineers, but still relatively unknown to the public. Polymorphic and metamorphic engines are an interesting topic; those are malware techniques used to evade detection. Firstly, polymorphic engines, work by rewriting parts of their own code during each execution, trying to make analysis more difficult; the latter acts more like an automatic obfuscation technique. For example, if we got this code: `mov eax, 1`, it can be transformed to this:\n\n```\nxor eax, eax\ninc eax\n```\n\nPolymorphic engines cipher the binary code and generate a stub, in each execution, the stub is mutated, changing a predetermined instruction set. The difference between a metamorphic engine, in the first instance, are the methods used; a polymorphic engine only can modify some instructions, cause the payload (stub) doesn't change. On the other hand, metamorphic engines have their own functional pseudo-compiler; in simple words, all binary's code could change in each execution, unlike polymorphic engines.\n\nSome examples of polymorphic and metamorphic malware include: Simile, Win32/Metaphor, Win32.Ursnif, UPolyX, etc.",
        "author": "Saskeloths",
        "created_utc": 1747315800,
        "score": 14,
        "parent_id": "t3_1kn159w",
        "depth": 0
      },
      {
        "id": "msht5gq",
        "body": "My personal hobby-horse is, I feel, massively under-discussed. I call it *the most terrifying object in mathematics*. It's not quite underground as its existence is known in CS, but the philosophical implications are absolutely terrifying. This is an object in mathematics that just exists, and this object is \"lurking\" behind every other mathematical space or object, silently dictating what can or cannot happen in that space. But nobody ever talks about this object. What is this mysterious Eldritch abomination of mathematics, you ask?\n\n**The Universal Prior** (Solomonoff)\n\nThe universal prior is a (Bayesian) prior that orders all possible hypotheses regarding the next bit in a bit-string by their Kolmogorov complexity. In plain language, the UP gives a probability P(x.0) (dot means concatenation) or P(x.1) given only x. This might sound pretty unremarkable until you realize that the UP takes into account *every* hypothesis (every possible computer program) that outputs x, and weights its own probability estimation based on the Kolmogorov complexity of each program, and its next predicted output. It is not possible to build a predictor that outperforms the UP because the UP already contains all possible hypotheses... whatever theory you have that you think would be a better prediction, it's already in the UP and it was taken into account when the UP gave its prediction.\n\nNote: The K-complexity of string x is just the length of a shortest program p that outputs x on some reference Turing-machine M, that is, K(x) = min length(p) : M(p)=x. While the K-complexity is relative to M, due to the invariance theorem, for any given M and M', there is some constant c s.t. that abs(M(x)-M'(x))<c for all x, therefore, the K-complexity (and, by extension, the UP) is independent of x. Thus, the objection \"it's all relative to your choice of reference machine M\" is irrelevant because c doesn't depend on x no matter what M,M' you choose. Therefore, we can think of the UP as a similar kind of object as the Monster group... it's just this terrifying thing that necessarily exists and its structure silently dictates the structure of *all other* mathematics...\n\nPS: In case it's not obvious how the UP affects other mathematics outside of CS, go back to Turing's original paper and understand that the basic concept of a Turing machine is what we today would call digitization or quantization. Any mathematical system that can be expressed as a sequence of discrete symbols or symbol-manipulations (practically all of modern maths) falls under this paradigm. Thus, anything that can be simulated by a Turing-machine, including mathematical equations (and the objects they represent) is subject to the constraints of the UP.",
        "author": "claytonkb",
        "created_utc": 1747334428,
        "score": 8,
        "parent_id": "t3_1kn159w",
        "depth": 0
      },
      {
        "id": "msicxi3",
        "body": "[Program synthesis.](https://en.wikipedia.org/wiki/Program_synthesis) You write a formal spec for a program, and the computer searches for code that satisfies it using a SAT solver. \n\nUnlike LLM-generated code, the results are provably correct and original. Unfortunately, it is less usable than LLMs - formal specs can be more difficult to write than the program itself, and SAT solvers are so slow that they make LLMs look downright fast.",
        "author": "currentscurrents",
        "created_utc": 1747340290,
        "score": 7,
        "parent_id": "t3_1kn159w",
        "depth": 0
      },
      {
        "id": "msepj5h",
        "body": "Cellular automata.\n\nIt used to be famous with Wolfram's a new kind of science book, but somehow it seem doesn't got any future.\n\n[https://en.wikipedia.org/wiki/A\\_New\\_Kind\\_of\\_Science](https://en.wikipedia.org/wiki/A_New_Kind_of_Science)",
        "author": "recursion_is_love",
        "created_utc": 1747291334,
        "score": 4,
        "parent_id": "t3_1kn159w",
        "depth": 0
      },
      {
        "id": "mspppm2",
        "body": "Vulnerability Research on hard targets like Android kernel, Chromium, etc. The actual movie level 0-click hacked stuff happens with this. A full chain exploit compromising chromium+Android to get RCE.\n\n\nThis is like a 30,000 ft overview for those completely uninitiated.",
        "author": "Purple-Object-4591",
        "created_utc": 1747439831,
        "score": 3,
        "parent_id": "t3_1kn159w",
        "depth": 0
      },
      {
        "id": "mt1xx7r",
        "body": "Lambda calculus. It's basically a model in formal logic to define and compute functions, everything is either a function or a variable. It's the most literal way of doing functional programming, no monads, no typeclasses, just bare functions.\n\nIf you know what you're doing, you can actually write very useful \"programs\" while keeping the syntax reasonably readable, unlike its twin, turing machines.\n\nHere's an implementation of the factorial function for church numerals:\n\n    fac = (λfix.λmul.λpred.λisZero. #pre-required functions\n      λself.λn.                             #actual parameter, plus self-reference for recursion\n      (isZero n)\n        (λf.λx.f x)                        #church numeral representing 1, returned if n is zero.\n        mul n (self (pred n)) #recursive call.\n    )\n    (λf.(λx.x x)(λx.f(x x)))                      #fix: for recursion\n    (λn.λm.λf.n (m f)) #mul\n    (λn.λf.λx.n (λg.λh.h (g f)) (λu.x) (λu.u))    #predecessor of n\n    ((λtrue.λfalse.                               #checks if n is zero\n      λn.n (λx.true) false\n    )(λa.λb.a)(λa.λb.b))",
        "author": "AdamWayne04",
        "created_utc": 1747619394,
        "score": 2,
        "parent_id": "t3_1kn159w",
        "depth": 0
      }
    ],
    "1kmiqoe": [
      {
        "id": "msaibvp",
        "body": "I mean, it kinda depends on how much detail your class covers or considers.  As an easy example, a lot of CPUs have FPUs as well as ALUs.  On the more complex end, what about integrated graphics?\n\n>In one of the online supplementary lessons there is a brief description of a CPU and a crude diagram with modals to see more about each component, but looking at diagrams from other sources I am getting conflicting messages.\n\nFor the sake of a test, I'd focus on what your class says to know about the components, more than worrying about other details from outside sources.\n\n>I haven't added any data bus and control bus arrows yet, but for the most part they're just 2 way arrows between each of the components which I don't really get because I was under the impression the Fetch-Decode-Execute was a cycle and cycles usually go round linearly.\n\nIt depends on how you draw your arrows, but the \"cycle\" probably is induced because the arrows are bidirectional.  There's also a bit of a difference between the *dataflow* being a cycle (i.e. the arrows that you draw) and the *high level process flow* being a cycle. (e.g. fetch/decode/execute is a simple cycle that iterates when the program counter is incremented, but how memory access is performed throughout that process isn't as obviously cyclic in terms of arrows on a diagram.)",
        "author": "apnorton",
        "created_utc": 1747238898,
        "score": 19,
        "parent_id": "t3_1kmiqoe",
        "depth": 0
      },
      {
        "id": "msan5zj",
        "body": "Weird.\n\nTechnically, those things do present in a CPU.\n\nBut I feel like the diagram is not doing a good job on what a CPU *actually* does.\n\nFor example, I don't know much about EE, but from a CS perspective, \"clock circuit\" and \"reset circuit\" are irrelevant. Even latches are not very significant, despite their relevance with pipelines.\n\nOn the other hand, something like an instruction decoder is entirely missing from the diagram.\n\nWhile ALUs are important, imo the focus should be on what the CPU does with ALUs, not ALUs themselves. As there are many other components, I would prefer ALUs drawn at a smaller scale (and draw many of them).\n\nRegisters are maybe fine in theoretical(?) sense but some feels weird and outdated(?) from a programmer's perspective.",
        "author": "JiminP",
        "created_utc": 1747240296,
        "score": 14,
        "parent_id": "t3_1kmiqoe",
        "depth": 0
      },
      {
        "id": "msahv4r",
        "body": "I should add that one conflicting message in particular was that in my university's diagram, they place the accumulator as a register in the memory unit, but in another diagram, I've seen the accumulator placed in the ALU instead.",
        "author": "Its_An_Outraage",
        "created_utc": 1747238764,
        "score": 8,
        "parent_id": "t3_1kmiqoe",
        "depth": 0
      },
      {
        "id": "msbln73",
        "body": "That's simultaneously too specific and too general - not a good combination.  \n\nFor some CPUs, some of those things are going to be missing, some of those things may have different names, or some of those things will be external.  \n\nInstruction decode could be part of the control unit, or its own unit, but it needs to be somewhere.\n\nAlso, \"Memory unit\" seems ambiguous; the register file and the memory interface (or bus interface for things without a separate memory controller) are usually separate.  \n\nSimilarly, newer processors - for values of \"newer\" back to about 1996 in the PC world, and the early 1990s in the Unix world - have multiple levels of cache, and often separate I and D caches.  How those are located will depend on the architecture.",
        "author": "CubicleHermit",
        "created_utc": 1747250151,
        "score": 6,
        "parent_id": "t3_1kmiqoe",
        "depth": 0
      },
      {
        "id": "msb2smi",
        "body": "Arithmetic is spelled wrong. Accumulator too.",
        "author": "WanderingRobotStudio",
        "created_utc": 1747244717,
        "score": 3,
        "parent_id": "t3_1kmiqoe",
        "depth": 0
      },
      {
        "id": "msaizy0",
        "body": "Might be a little information overload - but look up microarchitecture high level designs, that shows all the different stages of CPU execution:\n\nhttps://en.m.wikipedia.org/wiki/Microarchitecture",
        "author": "JmacTheGreat",
        "created_utc": 1747239092,
        "score": 2,
        "parent_id": "t3_1kmiqoe",
        "depth": 0
      }
    ],
    "1kmpnbd": [
      {
        "id": "msc4n36",
        "body": "One way is to have a \"load low\" opcode that loads only the lowest four bits and zeros the high bits, and then either a \"load high\" or a shift and an or. I don't know about 8 bits, but for larger word sizes this can be quite good because most constants are small.",
        "author": "thesnootbooper9000",
        "created_utc": 1747255849,
        "score": 7,
        "parent_id": "t3_1kmpnbd",
        "depth": 0
      },
      {
        "id": "msc5sz4",
        "body": "You’ve basically got the right idea. You can do it the Ben Eater SAP-1 way, where the 8-bits of instruction in memory consists of 4 bits of opcode + 4 bits of immediate value to load. The 4 lower value bits would go onto the bus, and then get loaded into the register that the opcode specifies. So your assembly code would look like:\n\nLDA #5\n\nWhich would translate to:\n\n00010101\n\nWhere 0001 is your Load A immediate opcode, and 0101 is the value (in this case 5) to put into A\n\nIf you need 8-bit opcodes and 8-bit immediate values on an 8-bit bus, you would first load the opcode into the instruction register, and then load the value into A. Assuming you only have an 8-bit bus and 8-bit wide memory, this would have to take place in two steps. Your assembly code would then look the same:\n\nLDA #5\n\nBut would compile to:\n\n00000001 00000101",
        "author": "Obvious-Falcon-2765",
        "created_utc": 1747256190,
        "score": 2,
        "parent_id": "t3_1kmpnbd",
        "depth": 0
      },
      {
        "id": "msc8idm",
        "body": "Most real 8-bit CPUs implemented multibyte/multicycle opcodes. It's quite simple, really. You just need:\n\n* A \"current opcode/instruction\" register, which you need anyway if your CPU does any memory operations so it remembers what it's doing during the memory op.\n* A \"extra cycle\" counter - which becomes extra (e.g. 2) bits of input into the instruction decoder, allowing for multi-cycle instructions.\n* An output line from the decoder that says whether that counter increments (next byte is part of the same instruction) or resets (new instruction).\n* A way to trigger a \"fetch\" that increases PC as normal but _doesn't_ put the fetched value into \"current instruction\" - instead into whatever other register is selected. It can often be tied to the same decoder output as the previous.\n\nThen your \"load constant\" opcode (e.g. opcode 0x01) would have two entries in the decoder for 0x01-0 and 0x01-1, where the first sets up a \"argument fetch\" into whichever register and the second finishes it with the fetched value and sets up the next instruction fetch.",
        "author": "TheThiefMaster",
        "created_utc": 1747256999,
        "score": 2,
        "parent_id": "t3_1kmpnbd",
        "depth": 0
      },
      {
        "id": "mscuy45",
        "body": "Probably the easiest way is to have a few 'flag' registers which allow one instruction to change the way the next instruction gets decoded. So a two-byte instructions get fetched just the same as two single byte instructions would be. \n\nSo in cycle1 you fetch a \"load_immediate\" instruction. This instruction does nothing except set a \"load_immediate\" flag.\n\nThen in the next cycle you fetch the next instruction as per normal. But the decoder detects the load_immediate flag and rather than decoding the instruction as an instruction it treats it as data for a load immediate instruction. And clears the load_immediate flag.",
        "author": "Falcon731",
        "created_utc": 1747264284,
        "score": 2,
        "parent_id": "t3_1kmpnbd",
        "depth": 0
      }
    ],
    "1kmalt7": [
      {
        "id": "ms8o1s9",
        "body": "You are in the modern era\n\n\n- Use the teacher to dictate the focus of your studies\n- Search relevant youtube videos to teach you the basics\n- Use your favorite virtual assistant for a more personalized explanation and troubleshooting\n- Use your textbook for additionnal exercices",
        "author": "lipo_bruh",
        "created_utc": 1747213906,
        "score": 72,
        "parent_id": "t3_1kmalt7",
        "depth": 0
      },
      {
        "id": "ms8umol",
        "body": "I would say pretty screwed, In my day it was called logical algebra and essentially the foundation of low-level application development. The further you move up from low-level/embedded, probably the less you need. High level languages do a lot of the nut crushing for you.",
        "author": "Soft-Escape8734",
        "created_utc": 1747217852,
        "score": 11,
        "parent_id": "t3_1kmalt7",
        "depth": 0
      },
      {
        "id": "ms9fgjq",
        "body": "If you're doing any sort of programming without like ChatGPT or something, you're probably already using principles of discrete math without even realizing it. The class, at least in my experience, mostly exists to give formal mathematical background for said principles, and also forms the foundation for proof-based mathematics which is seen in algorithms and beyond.\n\n\nI won't lie though, I found discrete mathematics incredibly dull. It might have been my class going fairly slow all things considered, but for as important as the material is for the math classes I've taken since, it only turned me away from math at the time.\n\n\nMy suggestion is to look at what math classes your school offers past calc 3, lin alg, diff eq, and see which ones have a significant amount of its content be about proofs, but don't expect you to have a rigorous background going in. For my school, UMD, these would be classes like intro to number theory and euclidean and non-euclidean geometries. Taking such classes will likely force you to learn/recall discrete math principles, while also learning something potentially more interesting.",
        "author": "KingMagnaRool",
        "created_utc": 1747226941,
        "score": 11,
        "parent_id": "t3_1kmalt7",
        "depth": 0
      },
      {
        "id": "ms9efn1",
        "body": "You’ll need it. \n\nBut in today’s world, there are so many ways you can learn discrete math besides having a shitty online professor read from the text book. Me; when I learn things I’ve turned to ChatGPT to ask it to explain concepts I don’t quite understand; it (and Claude) both do good jobs at highlighting ideas that may not have quite clicked. That, combined with good YouTube videos (I’m partial to 3Blue1Brown, though I’m not sure if he has a series on discrete math), and using your textbook to give you some structure into the subject—and you should be good to go.\n\nAs an aside, I’m convinced something like 75% of people who claim to be bad at math really had a shitty classroom experience with an incompetent teacher. Thank God there are tools out there today so that if you’re interested, and you have the time and the patience, you can learn practically anything.",
        "author": "w3woody",
        "created_utc": 1747226571,
        "score": 9,
        "parent_id": "t3_1kmalt7",
        "depth": 0
      },
      {
        "id": "ms9fosh",
        "body": "You do not necessarily *need* discrete math to be a competent programmer, but it sure helps.\nA lot of frontend work for example is what I like to call plumbing: it is usually just figuring out what components of the framework you are given should be used. There is not really any math in this.\nThis is not to belittle frontend work, learning the way things should be done requires work, and knowledge about how the framework works.\n\nBut if you ever need to tackle a problem that you cannot immediately solve, or google the solution to, thats where mathematical thinking comes in. \nYou need to get the basics right, so you will know what previously solved problems it is similar to, and to be able to develop strategies that might lead you to a solution.",
        "author": "PHDBroScientist",
        "created_utc": 1747227025,
        "score": 4,
        "parent_id": "t3_1kmalt7",
        "depth": 0
      }
    ],
    "1kk8102": [
      {
        "id": "mrspkwu",
        "body": "Steven Skienna algorithms (probably easiest algorithms book to understand while still covering most of the algorithms covered in a CS program)\n\nOSTEP (well written intro book for operating systems)\n\nMichael Sipser Theory of Computation (reccomend learning discrete math + proof writing first or you might struggle with the exercises)\n\nComputer Systems A programmers perspective\n\nCrafting Interpreters\n\nIntroduction to compiler and language design\n\nThese books are soft introductions to fundamental topics and aren't dry so are also suitable for beginners. Probably should study stats + calculus too if you haven't already",
        "author": "nm9800",
        "created_utc": 1746991865,
        "score": 20,
        "parent_id": "t3_1kk8102",
        "depth": 0
      },
      {
        "id": "mru3389",
        "body": "Code by Charles Petzold is legit one of the best intros to CS fundamentals you could pick - it builds up from basic logic gates to a working computer in a way thats super accessible and actually enjoyable to read (unlike some of the more academic texts that'll put you to sleep lol).",
        "author": "PM_ME_UR_ROUND_ASS",
        "created_utc": 1747009264,
        "score": 13,
        "parent_id": "t3_1kk8102",
        "depth": 0
      },
      {
        "id": "mrsj4t1",
        "body": "I made a longish CS roadmap [here](https://www.reddit.com/r/computerscience/comments/1k731bd/comment/mpk5ixx/?utm_source=share&utm_medium=web3x&utm_name=web3xcss&utm_term=1&utm_content=share_button).\n\nI think skipping Intro to Computing (which is a Python 101 book), the first six recommendations cover pretty much most of core CS:\n\n1. **VSI/Distilled**: Bird's eye view of CS\n2. **The Design of Everyday Things**: Interaction design\n3. **SICP**: Programming languages (a mathematical treatment of computational structures)\n4. **DPV/Erickson**: Algorithms\n5. **Computer Systems: An Integrated Approach**: (what it says - computer architecture + operating systems + networks)\n6. **Russell and Norvig**: Classical and modern AI",
        "author": "srsNDavis",
        "created_utc": 1746989714,
        "score": 10,
        "parent_id": "t3_1kk8102",
        "depth": 0
      },
      {
        "id": "mrsmte5",
        "body": "Introduction to which topic(s)? What is your background? Do you have the mathematical maturity to understand and formulate proofs? Do\nyou have any prior programming knowledge?",
        "author": "devnullopinions",
        "created_utc": 1746990936,
        "score": 3,
        "parent_id": "t3_1kk8102",
        "depth": 0
      },
      {
        "id": "mrt1knz",
        "body": "How to Design Programs",
        "author": "Helpful-Primary2427",
        "created_utc": 1746995824,
        "score": 3,
        "parent_id": "t3_1kk8102",
        "depth": 0
      },
      {
        "id": "mrtltpn",
        "body": "These are coming from a more meta standpoint, but I think they provide important context and \"big ideas\" that more technical manuals may not cover.\n\nCybernetics: Or Control and Communication in the Animal and the Machine - Wiener\n\nInformation Theory: Three Theorems - Shannon\n\nRhetorical Code Studies - Kevin Brock\n\nWhen Computers Where Human - Grier \n\nThe Universal Computer - Martin Davis.",
        "author": "crzzyrzzy",
        "created_utc": 1747002738,
        "score": 3,
        "parent_id": "t3_1kk8102",
        "depth": 0
      },
      {
        "id": "mrv820z",
        "body": "https://pll.harvard.edu/course/cs50-introduction-computer-science\n\nhttps://teachyourselfcs.com/\n\n???",
        "author": "Visible-Employee-403",
        "created_utc": 1747026946,
        "score": 3,
        "parent_id": "t3_1kk8102",
        "depth": 0
      },
      {
        "id": "mrt3sdd",
        "body": "I found **The Elements of Computing Systems** and the accompanying [nand2tetris](https://www.nand2tetris.org) course a useful overview of a computer from the bottom up",
        "author": "Bear8642",
        "created_utc": 1746996539,
        "score": 2,
        "parent_id": "t3_1kk8102",
        "depth": 0
      },
      {
        "id": "mrtpf4s",
        "body": "[The Pattern on the Stone](https://www.amazon.com/Pattern-Stone-Computers-Science-Masters/dp/0465066933)",
        "author": "Milumet",
        "created_utc": 1747004079,
        "score": 2,
        "parent_id": "t3_1kk8102",
        "depth": 0
      },
      {
        "id": "mru8ygk",
        "body": "https://usborne.com/au/books/computer-and-coding-books and a C64 emulator.",
        "author": "nanonan",
        "created_utc": 1747011525,
        "score": 2,
        "parent_id": "t3_1kk8102",
        "depth": 0
      },
      {
        "id": "mrvhcea",
        "body": "Are you a math person?\n\n[https://link.springer.com/book/10.1007/978-3-030-76908-6](https://link.springer.com/book/10.1007/978-3-030-76908-6)",
        "author": "recursion_is_love",
        "created_utc": 1747032298,
        "score": 2,
        "parent_id": "t3_1kk8102",
        "depth": 0
      }
    ],
    "1kjffzv": [
      {
        "id": "mrmookp",
        "body": "Yes. In general any finite state machine (which a Flip Flop is) can be modeled as a Markov Chain with deterministic transitions. The key difference is that for FSM’s, there is always 1 transition given the state & the input, (i.e. in the Markov chain you only have 1 transition with p=1)",
        "author": "CanIBeFuego",
        "created_utc": 1746902759,
        "score": 2,
        "parent_id": "t3_1kjffzv",
        "depth": 0
      }
    ],
    "1kikar2": [
      {
        "id": "mrg8tdb",
        "body": "That one time that i would actually want to read an article someone posts OP forgets to link it.",
        "author": "chemape876",
        "created_utc": 1746811218,
        "score": 9,
        "parent_id": "t3_1kikar2",
        "depth": 0
      },
      {
        "id": "mrh2fdt",
        "body": "Hey folks,  \nhere is the article link: [https://www.sidhantbansal.com/2025/Hashing-when-you-want-chaos/](https://www.sidhantbansal.com/2025/Hashing-when-you-want-chaos/)\n\nDunno why, but was struggling to get this link up on reddit (I suspect some reddit bot issue)\n\nI suspect some folks should have seen this stuff previously, I think the valuable insight I had when writing this was: \n\nhow we simulate uniformity using the hash function, then define a rare event, and invert it to estimate size. \n\nThis idea seems generic enough to be applicable at other places, but when taught in formal academic settings for LogLog / Flajolet Martin, this core intuition is not given enough emphasis.",
        "author": "Due_Raspberry_6269",
        "created_utc": 1746820245,
        "score": 7,
        "parent_id": "t3_1kikar2",
        "depth": 0
      },
      {
        "id": "mrh0i8v",
        "body": "have already seen a few versions of this. hyperlog or sth isn't it? and you forgot the article link",
        "author": "These-Maintenance250",
        "created_utc": 1746819651,
        "score": 2,
        "parent_id": "t3_1kikar2",
        "depth": 0
      },
      {
        "id": "mrky6ol",
        "body": "glad my brain still kinda works for this stuff, was hoping it would be HyperLogLog and related stuff and turns out it is. I saw it on a Breaking Taps video. Nice D3 animation! I think in the plaground being able to shrink the rare polygon (while keeping the # of input points) could be valuable for intuitive tinkering, right now you'd have to clear everything on both sides?\n\nI also like that you can only vote on the poll if you think the article was fun, filtering out noise.",
        "author": "1bc29b36f623ba82aaf6",
        "created_utc": 1746881648,
        "score": 2,
        "parent_id": "t3_1kikar2",
        "depth": 0
      }
    ],
    "1khtocr": [
      {
        "id": "mrapdcn",
        "body": "1. What is Cb?\n\nCb stands for the “cost coefficient of the basic variable”.\n\nTo explain this simply:\nImagine you’re the boss trying to minimize cost using a team of workers.\nYour workers are variables like X₁, X₂, S₁, S₂, S₃, and your goal is:\n\nminimize Z = 2X₁ - 3X₂\n\nThis means:\n\t•\tX₁ costs 2 coins per unit\n\t•\tX₂ saves 3 coins per unit (because of the minus sign — it’s a benefit!)\n\t•\tSlack variables (S₁, S₂, S₃) are just math tricks — they aren’t real workers. They’re added to help set up the equations, and they cost nothing (so their cost is 0)\n\nIn the Simplex Table, you start with slack variables in the solution (because they’re easy to solve for), so in the Cb column, you put their costs: 0, 0, 0.\n\n⸻\n\n2. Why is Cb initially 0?\n\nBecause at the very start of the method:\n\t•\tYour team is made up entirely of slack variables.\n\t•\tSlack variables were never part of your original objective function — they’re like scaffolding when building a house.\n\t•\tSince they don’t affect your cost, their Cb = 0.\n\nThis is why the first column under Cb is all 0s.\n\n⸻\n\n3. Why does Cb change to -3 later?\n\nOnce the simplex method finds out that X₂ is more helpful than a slack variable, we swap it into the solution.\n\nHere’s how:\n\t•\tIn Step 3 (Pivot Column): You look at the Cj - Zj row and find the most negative value (because we’re minimizing). That means, “This variable can reduce cost the most.”\n\t•\tIn this case, X₂ has Cj - Zj = -3\n\t•\tSo, we want to bring X₂ into the team\n\t•\tIn Step 4 (Pivot Row): You calculate which slack variable to kick out. You pick the row with the lowest positive ratio of RHS / X₂ value.\n\t•\tLet’s say S₃ gets kicked out, and X₂ takes its place.\n\nNow, in the new row, we replace the kicked-out variable’s cost (0) with X₂’s cost, which is -3, in the Cb column.\n\nThis is what you see when the 3rd row’s Cb value changes from 0 to -3.\n\n⸻\n\n4. How does this relate to the Pivot Row?\n\nOnce you’ve picked X₂ as the variable to enter, you need to figure out who to remove from the current basic solution.\n\nYou do this by:\n\t•\tDividing each row’s RHS (the rightmost column, called “Constants”) by the corresponding X₂ value in that row.\n\t•\tBut you only consider positive values in the X₂ column, because a negative X₂ would not make sense in most real-world problems (like negative workers).\n\nIn this case:\n\t•\tFirst row: RHS = 7, X₂ = -1 → Not considered (negative)\n\t•\tSecond row: RHS = 12, X₂ = -4 → Not considered (negative)\n\t•\tThird row: RHS = 10, X₂ = 3 → 10 / 3 = 3.33 (smallest positive ratio)\n\nSo the third row is the pivot row, and the basic variable in that row is replaced by X₂.\nTherefore, its Cb changes from 0 to -3.\n\n⸻\n\n5. How does this all fit into the Simplex Method?\n\nHere’s the big picture:\n\nStep 1\nAdd slack variables to turn inequalities into equations.\nStep 2\nSet up the Simplex Tableau. Put slack variables in the solution mix. Their Cb = 0.\nStep 3\nFind the pivot column (most negative Cj - Zj). This shows which real variable (like X₂) should enter the solution.\nStep 4\nFind the pivot row (smallest positive RHS / pivot column value). This shows which slack variable should be removed.\nStep 5\nUpdate the tableau, and replace the Cb in that row with the cost of the entering variable.\nRepeat\nKeep doing this until there are no negative values in Cj - Zj (means you’ve found the minimum).\nFinal Analogy:\n\nImagine you’re assembling a team to do a job with the least cost.\n\t•\tYou start with 3 free interns (S₁, S₂, S₃). They’re okay but not great.\n\t•\tYou discover a worker (X₂) who can actually save you money.\n\t•\tYou check who among the interns is the easiest to replace.\n\t•\tYou swap one intern out and hire X₂.\n\t•\tNow, your team’s cost table (Cb) updates — because X₂ has a real value.\n(Response from ChatGPT btw…I thought it might explain more elaborately than me) hope this helps.",
        "author": "NOBODY_0000000000000",
        "created_utc": 1746732109,
        "score": 4,
        "parent_id": "t3_1khtocr",
        "depth": 0
      },
      {
        "id": "mrvx7i5",
        "body": "sweden",
        "author": "Valuable-Beyond-7317",
        "created_utc": 1747042490,
        "score": 2,
        "parent_id": "t3_1khtocr",
        "depth": 0
      }
    ],
    "1khj325": [
      {
        "id": "mr7ifbi",
        "body": "The Graph Isomorphism Problem is not currently known to be in either P *or* NP-Complete.  Linear programming problems, though, are solvable in polynomial time.\n\nThat is to say, if you have a (continuous) LP formulation of the GIP, you've established a fairly major result.  As such, rather than asking \"is this a valid formulation,\" it might be more time-efficient to put forth a proposed proof that the LP formulation you've come up with *is* valid, and then ask if anyone can spot errors in the proof.  I wasn't able to quickly find a clear proof of the above screenshot in the linked paper.",
        "author": "apnorton",
        "created_utc": 1746689786,
        "score": 22,
        "parent_id": "t3_1khj325",
        "depth": 0
      },
      {
        "id": "mrdecsm",
        "body": "This is very likely well known, and this topic has been known for over forty years. I don’t have the energy to look over your formulation to tell you if it’s correct or not, but I do know that your formulation is way more complicated than it needs to be, especially if you’re using CVXPY. If you read the paper by Bach (and coauthors), and the paper by Vogelstein (and coauthors), and look at their references, you’ll find a reference to an LP formulation. These are two seminal works in the field that aren’t in your references, as are several others. I also don’t see the word, Hungarian algorithm, or anything like that, which is a bad sign because again, important idea for dealing with non vertex solutions. If there’s a reason for the complexity, you haven’t explained it in context. For example, this is an obvious LP starting point:\n\nminimize(P) sum(abs(PA - BP))\n\nsubject to: P@1 = 1, 1@P = 1, P >= 0\n\nThis criteria is the number of edge mismatches. I don’t understand your discrepancy metric, but I know that people have already tried the Wasserstein metric cost, quadratic norm cost, Frobenius norm, graph discrepancy energy, anything that is obvious and can be represented as a convex function. I also don’t understand the point of the circulant matrix. What’s the observation, in one or two sentences, for what a circulant matrix can possibly do, that helps the situation? Recall that the hard situations are the Johnson graphs, whose symmetries are hard to break because they exhibit so many symmetries. For example, I’ll tell you one of my hobby failed ideas.\n\nAs a hobby, I tried attacking this problem with Riemannian optimization with ADMM, where the observation is, the intersection of the Birkhoff polytope and the orthogonal manifold are the permutation matrices, and ADMM lets you optimize over the manifold and birkhoff polytope separately, then combine these constraints. This is very complicated, but I can justify why i tried it to you in one sentence. I scanned your preprint and i can’t find why circulant + LP/SDP is the right way to go. LP is likely the wrong thing to try because of how the simplex method works, which intuition suggests will leads to unavoidable exponential complexity. SDP might be the right thing to do, but there are SDP formulations out there for this problem.",
        "author": "Lexiplehx",
        "created_utc": 1746767312,
        "score": 3,
        "parent_id": "t3_1khj325",
        "depth": 0
      }
    ],
    "1kgvi2v": [
      {
        "id": "mr1x7nu",
        "body": "> when I declare `int a = 10;` I know that a is stored somewhere in memory\n\nExactly. Your compiler works out where to store your data item.\n\n>  and has an address, like 0x00601234.\n\nSort of. If your variable is declared in a function or method (that is, as a local variable), it is stored as an offset to the system stack pointer. But you are correct, it does have an address like you mentioned.\n\n> But I'm confused about what exactly is stored in RAM. \n\nIf you use a typical 21st century computer, the compiler allocates four bytes (32 bits) for your `int`. Then it generates code which stores that value `10` into those four bytes.\n\n> Does RAM store both the address and the value? Or just the value? \n\nJust the value.\n\n> Since the address itself looks like a 4-byte number,\n\nOn 64-bit computers, complete addresses are longer than four bytes. But shorter addresses work, by assuming the extra bits in the address are zero.\n\n> is the address just the position in memory, not actually stored anywhere?\n\nThat's correct.\n\n> And when I use &a, how does that address get generated or retrieved if it's not saved in RAM? \n\nThere are hardware instructions that fetch data from memory, and there are hardware instructions that look like fetch instructions, but actually fetch the effective address rather than the data.\n\n> I’m also aware of virtual vs physical addresses and how page tables map between them,\n\nAll the stuff we've mentioned so far happens on the virtual, user-space, side of the page tables. \n\nI hope this helps. \n\nMany C compilers have a way to dump out assembler (machine code with mnemonics) for the code they generate. It is worth your while to do this with a few simple programs, for the sake of learning about this memory-allocation process.",
        "author": "Aggressive_Ad_5454",
        "created_utc": 1746620243,
        "score": 66,
        "parent_id": "t3_1kgvi2v",
        "depth": 0
      },
      {
        "id": "mr2b0c3",
        "body": "> I'm trying to better understand how variables and memory addresses work in C/C++. For example, when I declare int a = 10;, I know that a is stored somewhere in memory and has an address, like `0x00601234`\n\nWell, maybe. Integers may not be stored in memory at all, but may be held only in a CPU register, which doesn't have a memory address. Doing something like `int a = 10` may compile down to loading an immediate into a register (eg, `mov rax, 10`). Compilers will attempt to avoid allocating memory unnecessarily if it doesn't need to, because accessing the registers is much faster than accessing memory.\n\nIf you take the address of an integer, however, the compiler will give it memory storage, typically on the stack for integers defined in functions, or a global data section for values declared outside of any function.\n\nAddresses are just the virtual memory location that holds the value. If you take the address of an integer, the compiler or linker determines the address of the integer - which may be an address relative to a value in a register (such as the stack pointer), or a fixed, *absolute address*. A value which holds an address is called a pointer. Pointers themselves may be stored in memory or in registers.\n\nWhen a function is compiled, the compiler works out how much storage is required for its local variables, and allocates a *frame* on the stack large enough to hold them. The frame is bound by two values - the stack pointer and frame pointer - both typically held in registers usually called SP and FP (In X64 they're RSP and RBP). Functions have a *prelude* which prepares the stack for function execution, and an *epilogue* which unwinds a stack frame when the function exits (precise semantics are dependant on *calling convention*, and sometimes these are done by the caller rather than the callee).\n\nLocal variables are given an index/offset within the frame, and their values are stored there. Addressing is then *stack pointer relative*, and is performed with simple addition or subtraction of the stack or frame pointers. Instruction set architectures support *addressing modes* so that these offsets don't require separate instructions.\n\nImportant to note is that, if you take the address of a local variable, the use of this address cannot outlive the function call (It may only be used in the *dynamic extent* of the call), and cannot be returned from the function - because returning from the function invalidates the stack frame and anything in it. A pointer into an invalidated stack frame results in undefined behavior (read: a bug which can be exploited by hackers).\n\nFor globals, it's largely implementation dependant. The compiler will typically put global values into a section called `.data`, but it will give them a fixed offset into this section. The `.data` section is loaded into a specific location of virtual memory when the program starts (configurable with the linker, and stored in the ELF or PE file). The code can therefore use an absolute virtual address to access global variables. In some systems there's also a separate GP (global pointer) register, which points to the start of global data. Similarly, each thread can have its own storage, and may be accessed with a thread pointer (TP). On X86 there is no thread pointer register, but compilers typically use the FS and GS *segment registers* for this purpose. Instructions in X86 can be made segment-register relative, so these effectively serve as the thread pointer.\n\nSo essentially, the compiler determines how much storage is needed to hold values - it provides space for them, either an offset from a specific section, or a stack-relative offset for locals. Absolute addresses are therefore stored *in the machine code itself*, which is typically in the `.text` section. Relative addresses are stored in the code as immediates which are a stack relative offset, or index relative to some global or thread pointer.\n\nFor short lived variables whose addresses are not taken though, the compiler can completely optimize out any memory allocation for them, and they may live only in registers.\n\nAbsolute addressing is performed by the *linker*. Compilers emit section-relative addresses in *relocatable object files*, but the final job of determining a fixed memory location for the data and applying absolute addresses to the machine code is done by the linker.\n\n> I’m also aware of virtual vs physical addresses and how page tables map between them, but I’m not sure how that affects this specific point about where and how addresses are stored.\n\nYou do not need to worry about physical addresses unless you are programming an operating system kernel. User space programs have a linear virtual address space which is all you need to concern yourself with. The CPU and kernel handle the translation to physical addresses.",
        "author": "WittyStick",
        "created_utc": 1746625130,
        "score": 14,
        "parent_id": "t3_1kgvi2v",
        "depth": 0
      },
      {
        "id": "mr1w18h",
        "body": "My confusion is if the int a = 10 is stored on the physical RAM without saving the address, then how does it know where to go? like when I use the &a to get the address, how does it give me the address?",
        "author": "Infinite_Swimming861",
        "created_utc": 1746619777,
        "score": 4,
        "parent_id": "t3_1kgvi2v",
        "depth": 0
      },
      {
        "id": "mr2q76h",
        "body": "Don't overthink it.  This is just a picture, to understand it conceptually, but it will help I think. \n\nConsider RAM to be a giant array of bytes.   \nAn address is the index into that 'array'.  Eg ram\\[0x00601234\\] is just like somearray\\[42\\] in terms of how you can think about it, though you can't use that for syntax of course!  \nIn those terms, a pointer is an integer that holds 0x00601234 just like you can say index=42 and then say somearray\\[index\\].  The syntax is notably weird and different from array use, but the concept is exactly the same.   \nfor dynamic memory, you have functions that return these index values.   some pointer = new(..) is just returning an index into ram and storing it into the pointer.  How it got that index is a bit of study because everything on the machine shares it so an operating system level program says which piece is unused that you can have, but the how is not important to you most of the time.  All that matters is that the index was provided and now you can go there. \n\nThat picture will work.  Its not 100% accurate, though, so be aware that its just a conceptual/understanding description.  The addresses are stored in memory of course, usually as part of a larger piece of data that represents a cpu instruction in the compiled version of your program, to oversimplify again.",
        "author": "Independent_Art_6676",
        "created_utc": 1746629785,
        "score": 5,
        "parent_id": "t3_1kgvi2v",
        "depth": 0
      },
      {
        "id": "mr57g6b",
        "body": "I think what you're asking about is the symbol table: https://www.geeksforgeeks.org/symbol-table-compiler/.",
        "author": "Paxtian",
        "created_utc": 1746655645,
        "score": 5,
        "parent_id": "t3_1kgvi2v",
        "depth": 0
      },
      {
        "id": "mr2w07b",
        "body": "The compiler works with the addresses, in 32bit think of them as integer numbers. It can do math with them, increment, decrement the value, clear it to zero, read its value, but also dereference it, which means to go and read some value at address indicated by the value.\nThen it treats that value as if it were a certain type, like a byte or integer. If you want to read a string, it would read byte by byte from the address of your variable's value (which acts as a pointer). There are cpu instructions optimized for tasks, like copying a nr of bytes, which can be used to copy some strings, for example.\nIt's very low level, but they are building blocks for more complex programs.\nIn your program, you work with the value of the variable, but the compiler emits code to work based on the address indicated by your variable, its called pointer.\nYou can have a very large object and work with it like a variable, because the address in your variable points to starting address of your object.\nIn memory, at destination address, there is just the value, not a pair of address and value.\nIt's a bit more complex, that memory pages are loaded in physical memory, so the cpu needs to find the physical address of your address, sometimes it needs to load the page from disk (if the page was swapped due to low memory).",
        "author": "DonutConfident7733",
        "created_utc": 1746631467,
        "score": 3,
        "parent_id": "t3_1kgvi2v",
        "depth": 0
      },
      {
        "id": "mr5vq6e",
        "body": "1. This has NOTHING to do with virtual vs physical memory.  Analyze this question in terms of \"physical memory only\" on an address-limited machine.  That is, ignore virtual concepts.\n2. The address AS FAR AS WHAT YOU WANT TO KNOW, is not stored anywhere. (Kind of ...) The assembly language instruction that is executed for, for example,\n\nx = \\&a; \\*x = 0;   // essentially assigning 0 to a, a=0;\n\nis something like      \n\nsti   0x00601234, 0     //store immediate 0 into 0x'601234'\n\nThe address of variable a is actually located in the executable machine-language instruction itself.\n\n3) But how does the compiler know to use 0x00601234 when emitting the assembly code?  Compilers run on two passes.  The first pass through your program, the compiler builds a list of all your program variables, together with the addresses that the compiler arbitrarily chooses for these variables. The internal list of your program variables and their \"compiler-assigned\" addresses is known as a \"symbol table.\" On the second pass, the compiler emits the assembly code for a=0, (which is the sti instruction in my example)  referencing the symbol table entry for \"variable a\" that it created on pass 1.  The compiler, having completed its work on pass 2, then discards the symbol table, and terminates itself.  You then run your compiled program, oblivious to the existence of the now-defunct symbol table.\n\n4) Symbol tables are sometimes kept around.  This would be the case if you were accessing a variable in a pre-compiled standard library.  In that case, the compiler CANNOT know where the variable is in memory, because the variable is in a library, and the library is out on the disk somewhere.  Such variables are known as externs (externals), and the run-time loader will fill in the variable address in the sti instruction when the run-time loader actually loads up the library, and can then know where the variable is actually located in memory.\n\nYou can issue an option to the compiler (at compile time) that will prevent the compiler from discarding its symbol table.  It will be saved in a file that you can have a look at, if you're curious.",
        "author": "maxthed0g",
        "created_utc": 1746663962,
        "score": 3,
        "parent_id": "t3_1kgvi2v",
        "depth": 0
      },
      {
        "id": "mr3tl27",
        "body": "The address tells you which piece of ram holds the value. The rams are numbered.\n\nIt’s like having a red a green and a blue box. Each box has a color and a content. The color can’t be changed but we can change the content. The color is just useful for knowing which box is which.  \n\nIn a program int a — a is a box. The name a is actually the address but usually we want the content. The content can be changed but a’s color/address is fixed. \n\nBack to the colored boxes we could name them A B C but the colors are still fixed and whether you refer to the box by its color or its name you have the same box. \n\nLikewise the variable an and the address of a &a both can be used to set the content of a.",
        "author": "Classic-Try2484",
        "created_utc": 1746641081,
        "score": 2,
        "parent_id": "t3_1kgvi2v",
        "depth": 0
      }
    ],
    "1kgw29z": [
      {
        "id": "mr1yxfa",
        "body": "DSA is almost entirely language agnostic. There really shouldn't be any issues.\n\nAnd yes, almost everything you learn in a DSA class will already exist in some library (Python or otherwise). You'll rarely build these things outside of the classroom.",
        "author": "Magdaki",
        "created_utc": 1746620905,
        "score": 23,
        "parent_id": "t3_1kgw29z",
        "depth": 0
      },
      {
        "id": "mr1zl9h",
        "body": "\\> Recently i discovered that python offers simple ways\n\nNot for the reference (inductive type) like graph and tree.\n\nPython is using iterator pattern a lot. If you have linear array, your code will look simpler.\n\nYou can write your own iterator for a graph or tree but that will be advance topic.",
        "author": "recursion_is_love",
        "created_utc": 1746621155,
        "score": 2,
        "parent_id": "t3_1kgw29z",
        "depth": 0
      },
      {
        "id": "mr5hu1a",
        "body": "Don't make the switch for DSA class because c++ will clarify your concepts so write simple programs in c++ to build your foundation. As you work on bigger projects, you could use in-built python packages to move fast but for learning basics, python will hide lot of stuff from you.\n\nAs a student, you need to build solid foundation.\n\nThink of like you are learning how to do multiplication but rather than doing by hand to clear your concepts you always use calculator. In this case, c++ is like doing multiplication by hand and python is like a calculator.",
        "author": "buildspecs",
        "created_utc": 1746659164,
        "score": 2,
        "parent_id": "t3_1kgw29z",
        "depth": 0
      }
    ],
    "1kgtiir": [
      {
        "id": "mr1j8pp",
        "body": "It's a continuous fractal space filling curve, related to the Hillbert/Moore curve, because it should wrap at the sides. The top leftmost point should have hamming distance of 1 from the top rightmost point and from the bottom leftmost point - ie, it should form a toroid if wrapped into a 3D surface. It's also related to Karnaugh maps.",
        "author": "WittyStick",
        "created_utc": 1746614019,
        "score": 9,
        "parent_id": "t3_1kgtiir",
        "depth": 0
      },
      {
        "id": "mr3rxqo",
        "body": "Reminded me of this tiny 16 byte program (binary for MSDOS, written in x86 asm)\n\nthat creates something similar : [\"Ruler 16b\"](https://www.pouet.net/prod.php?which=90986)\n\n    mov al,0x13\n    int 0x10\n    les ax,[bx]\n    mov ch,0x80\n    X:\n    stosw\n    sub di,cx\n    rol ax,cl\n    xchg ax,di\n    jmp X",
        "author": "Hell__Mood",
        "created_utc": 1746640614,
        "score": 2,
        "parent_id": "t3_1kgtiir",
        "depth": 0
      }
    ],
    "1kfqvuy": [
      {
        "id": "mqt0s8z",
        "body": "graph theory is extremely fundamental. everything is graph-like in reality. you may not need complex implementations with it very often, but when you do, its generally an extremely high leverage thing.",
        "author": "zeloxolez",
        "created_utc": 1746492344,
        "score": 69,
        "parent_id": "t3_1kfqvuy",
        "depth": 0
      },
      {
        "id": "mqtbgho",
        "body": "Graphs are like, the fundamental computer data structure. Nearly everything is some type of graph if you squint at it long enough. \n\nIs it enough to use as an expertise for a career? No. But it's extremely important to at least understand.",
        "author": "DTux5249",
        "created_utc": 1746496038,
        "score": 25,
        "parent_id": "t3_1kfqvuy",
        "depth": 0
      },
      {
        "id": "mqstgal",
        "body": "1. For industry, graphs or graph-like ideas may appear from time to time but it isn't much upon which to create a career.\n2. For academia, maybe but you'd likely need to broaden it somewhat to make it into a research agenda. Of course, if you plan to do research, then you'll likely need a PhD.",
        "author": "Magdaki",
        "created_utc": 1746489827,
        "score": 16,
        "parent_id": "t3_1kfqvuy",
        "depth": 0
      },
      {
        "id": "mqudtzq",
        "body": "You never, ever, ever can know when something you learn is going to be useful. I once unstuck a team of 15 engineers by knowing that a minimum spanning tree was exactly the answer to a problem they didn't know how to solve. I had only learned about spanning trees because at one point as a child I wanted to write a game like Rogue with connected rooms and wanted to know how to connect them. If you enjoy solving problems in graphs or anything else I say invest in it -- it's for certain not going to be useful if you never learn and explore it.",
        "author": "dontyougetsoupedyet",
        "created_utc": 1746512948,
        "score": 11,
        "parent_id": "t3_1kfqvuy",
        "depth": 0
      },
      {
        "id": "mqtce76",
        "body": "I currently work for networking and need to know how wireless networks are connected in mesh setups. It is basically a graph problem where every node is a wireless station and it connects to other wireless stations in a graph.",
        "author": "ProbablySomeWeebo",
        "created_utc": 1746496347,
        "score": 3,
        "parent_id": "t3_1kfqvuy",
        "depth": 0
      },
      {
        "id": "mqwd30r",
        "body": "I work as a data analyst in retail, but we have small bakeries in stores. We are lacking a way to track the needed ingredients ahead and I was tasked with dealing with it. \n\n\nTurned out, recepie is basically a graph, and I am using depth search to figure out what needs to be delivered! So, yeah, may come handy. ",
        "author": "elephant_ua",
        "created_utc": 1746544945,
        "score": 4,
        "parent_id": "t3_1kfqvuy",
        "depth": 0
      },
      {
        "id": "mqyjr7x",
        "body": "Expertise? No\n\nKnowing it well? Yes\n\nHave a look at Neo4J, it's a graph database and it's fun to use.",
        "author": "dariusbiggs",
        "created_utc": 1746567482,
        "score": 3,
        "parent_id": "t3_1kfqvuy",
        "depth": 0
      },
      {
        "id": "mqud6jj",
        "body": "Graph theory is a great topic to build a research career around, especially if you are interested in theoretical computer science. \n\nBut as others said, do not worry too much about it now. If you decide to pursue research later on, you’ll see if you are still drawn to that or something else.",
        "author": "Fresh_Meeting4571",
        "created_utc": 1746512569,
        "score": 2,
        "parent_id": "t3_1kfqvuy",
        "depth": 0
      },
      {
        "id": "mquo1fj",
        "body": "Most problems can be solved as a graph. If we solve them in other ways, it's simply because it's an optimization. \n\nFor example, a list of sorted integers? A graph. A matrix? Obviously a graph. Hell, nearly everything else is made of those structures to begin with! Even a programming language is just a graph (AST) with some edges at runtime.\n\nAnd the most obvious: everything you can do with a relational database, you can do with a graph. It may be more or less efficient, but it's what it is",
        "author": "ivancea",
        "created_utc": 1746519419,
        "score": 2,
        "parent_id": "t3_1kfqvuy",
        "depth": 0
      },
      {
        "id": "mqvnlvx",
        "body": "With almost any expertise, the more proficient you become, the more opportunities will arise. (lots of real exports do become a freelance advisor / consultant besides their day job)",
        "author": "Bwuaaa",
        "created_utc": 1746537109,
        "score": 2,
        "parent_id": "t3_1kfqvuy",
        "depth": 0
      }
    ],
    "1kf9xut": [
      {
        "id": "mqp0uaz",
        "body": "Looks like a use case of “Segment tree with lazy propagation”",
        "author": "SorrySituation9594",
        "created_utc": 1746447298,
        "score": 13,
        "parent_id": "t3_1kf9xut",
        "depth": 0
      },
      {
        "id": "mqp40ek",
        "body": "You can do it with a modified/augmented binary search tree. As a sketch of what you'll need, you need to have some tree structure made of nodes like these:\n\n\n    class Node<T> {\n      int total_weight_of_subtree;\n      Node left;\n      Node right;\n      T leaf;\n\n      insert(T obj, int weight) {\n        recursively binary search for the location of the leaf\n        insert leaf into correct spot\n        update the total tree weights as you recurse back up\n        if you need to, rebalance the tree as you go (AVL / Red-Black / etc)\n      }\n\n      randomlySelectFromRootNode() {\n        // Pick a random \"weight\" less than the max possible weight\n        int weight = random() * this.total_weight_of_subtree;\n        return this.select(weight);\n      }\n\n      select(int weight) {\n        // If the weights of the leaves are [2,5,6,3] and you choose weight = 8,\n        // this should choose the 3rd leaf\n\n        if (this.leaf != null) {\n          return this.leaf;\n        }\n\n        // Find the element with that weight recursively\n        // If the weight is less than the total weight of the left side, it must be there\n        // Otherwise it must be on the right side\n        if (weight <= this.left.total_weight) {\n          this.left.select(weight);\n        } else {\n          this.right.select(weight - this.left.total_weight);\n        }\n      }\n    }\n\n\nI haven't tested this pseudocode, but the general principle should work with O(logn) time to query. Updating the weight of something is just a binary search for the element followed by propagating the weight back up.\n\nI believe this general idea is called an \"Order statistic tree\" although this specific modification isn't on wikipedia.\n\nYou can also do it with a data structure that supports fast prefix sums (e.g. segment trees or fenwick trees). Much of the logic should be similar, except a segment tree can't have \"holes\" in the array, so you just swap an object to the end of it and reduce the internal length to delete items along with an accompanying hash table so you can keep track of the location of your objects' weights inside the segment tree.",
        "author": "nubcake9000",
        "created_utc": 1746448574,
        "score": 3,
        "parent_id": "t3_1kf9xut",
        "depth": 0
      }
    ],
    "1kewsdw": [
      {
        "id": "mqmn7yo",
        "body": "\\- [https://www.amazon.com/Computer-Networking-Top-Down-Approach-Global/dp/1292153598/](https://www.amazon.com/Computer-Networking-Top-Down-Approach-Global/dp/1292153598/)  \nComputer Networking: Top Down Approach is excellent for beginners.\n\nAnd if you want \"hands on problems\" just pick some stuff you find interesting and implement it yourself.  \nYou mentioned:\n\n>I don't want to memorize that the TCP header is 8 bytes\n\nSo implement the TCP protocol in any language you are most comfortable with.  \nduuhh...\n\nIs that too easy?  \nFucking pick a protocol from Session or Network layer and integrate that into your TCP setup.\n\nStill too easy?  \nBuild the whole OSI stack xD\n\nps.  \nSession or Network layers are one level bellow and above from the Transport Layer where the TCP runs.",
        "author": "juju515",
        "created_utc": 1746405351,
        "score": 4,
        "parent_id": "t3_1kewsdw",
        "depth": 0
      },
      {
        "id": "mqmjr64",
        "body": "Kurose’s book is best i think",
        "author": "MemeLord_0",
        "created_utc": 1746404088,
        "score": 2,
        "parent_id": "t3_1kewsdw",
        "depth": 0
      },
      {
        "id": "mqxbtp2",
        "body": "Need help on this too",
        "author": "AggravatingLoad6650",
        "created_utc": 1746554840,
        "score": 2,
        "parent_id": "t3_1kewsdw",
        "depth": 0
      }
    ],
    "1kdn2o4": [
      {
        "id": "mqc2rhe",
        "body": "Its a good bench mark if the language is able to produce its own compiler. Makes the language look good. Obviously this only applies until its effects the usability of the language e.g. if the python implementation was python.",
        "author": "bronco2p",
        "created_utc": 1746256573,
        "score": 223,
        "parent_id": "t3_1kdn2o4",
        "depth": 0
      },
      {
        "id": "mqccuhh",
        "body": "Slightly off topic but a C compiler is not necessarily just a direct translator.\n\nC/C++ compilers are able to pull a great number of optimizations over your code \n\nCheck this from the great Matt Godbolt \nhttps://youtu.be/w0sz5WbS5AM?si=XY02nVOyfeQvOSKr",
        "author": "IlPresidente995",
        "created_utc": 1746262917,
        "score": 57,
        "parent_id": "t3_1kdn2o4",
        "depth": 0
      },
      {
        "id": "mqc54yd",
        "body": "You may be surprised. I remember reading a blog about formal verification of software and where to stop with the \"verification\" part. From what I remember, they claimed that modern GCC depends on an old GCC version, that one either relies on another one or depends on another and older C compiler, that one also relies on another C compiler even older. \n\nThey talked about that since it's relevant for verification. How can you be sure that the modern one is good, if you don't check the other ones needed to arrive in this state?\n\nAlso, usually bootstrapping (writing X in X) is an objective of programming language developers. Is a mix of pride and a way to free yourself from the limitations of the original language of implementation. If you are doing your lang, chances are that you really like it, so, you probably want to maintain your lang in your lang instead of using that other languages. \n\nFrom what I remember there were some authors that are happy not pursuing bootstrapping. One of them even told us about how not pursuing bootstrapping helped to consolidate the design of the language.",
        "author": "omega1612",
        "created_utc": 1746258047,
        "score": 31,
        "parent_id": "t3_1kdn2o4",
        "depth": 0
      },
      {
        "id": "mqcfbi6",
        "body": "Hey, C is not a direct translation to hardware or any such nonsense.\n\nYou are thinking of assembly language, or machine code",
        "author": "WokeHammer40Genders",
        "created_utc": 1746264521,
        "score": 22,
        "parent_id": "t3_1kdn2o4",
        "depth": 0
      },
      {
        "id": "mqc8egk",
        "body": "Also, bootstrapping the compiler encourages the community to contribute, if you use and know the language, you are also able to work on the compiler",
        "author": "JockeRider199",
        "created_utc": 1746260078,
        "score": 13,
        "parent_id": "t3_1kdn2o4",
        "depth": 0
      },
      {
        "id": "mqcupiy",
        "body": "You can write a compiler for any language in any other language, compilers are just programs that reads in a file and outputs another file. I can write a C compiler or ASM assembler in JavaScript or Python. In the age of LLMs, there’s no need to guess, talk to it to get a good understand of the concept. If you’re interested in modern compilers, check out the LLVM project, you’ll see that the language itself doesn’t really matter, it’s just an opinionated style of expressing ideas, but the underlying basis to getting that to map to machine code is generalizable.",
        "author": "jsllls",
        "created_utc": 1746273019,
        "score": 8,
        "parent_id": "t3_1kdn2o4",
        "depth": 0
      },
      {
        "id": "mqd4dpq",
        "body": "The typescript compiler team is actually moving to go currently because go supports similar models so they can do one to one translation and ensure they keep the semantics while gaining a 10x speed up.",
        "author": "lordheart",
        "created_utc": 1746277128,
        "score": 5,
        "parent_id": "t3_1kdn2o4",
        "depth": 0
      },
      {
        "id": "mqdwvrf",
        "body": "The only way to fully understand your own language and to make it as good as possible is to use it.\n\nIn software circles (and presumably more widely) this is known as eating your own dog food.",
        "author": "RavkanGleawmann",
        "created_utc": 1746286720,
        "score": 4,
        "parent_id": "t3_1kdn2o4",
        "depth": 0
      },
      {
        "id": "mqced7x",
        "body": "Bootstrapping has benefits\n\nhttps://en.m.wikipedia.org/wiki/Bootstrapping_(compilers)",
        "author": "The-Malix",
        "created_utc": 1746263900,
        "score": 3,
        "parent_id": "t3_1kdn2o4",
        "depth": 0
      },
      {
        "id": "mqdc1t3",
        "body": "It was pretty common to write a compiler that compiles itself (bootstrapping), using the language it was meant to compile in. The compiler fetches the rules of the CFG it needs as it goes.",
        "author": "_abscessedwound",
        "created_utc": 1746279966,
        "score": 3,
        "parent_id": "t3_1kdn2o4",
        "depth": 0
      },
      {
        "id": "mqdhman",
        "body": "Beyond dogfooding , testing and the like -- if you like language X enough to invent it,  why would you not want to use it whenever possible?  The bootstrap process can be tedious but is rarely hard.",
        "author": "dnabre",
        "created_utc": 1746281854,
        "score": 3,
        "parent_id": "t3_1kdn2o4",
        "depth": 0
      },
      {
        "id": "mqdr1l6",
        "body": "Writing Lean in Lean also makes it easier to metaprogram in Lean. The Lean Mathlib is a mixture of regular Lean code and metaprogramming code.",
        "author": "laniva",
        "created_utc": 1746284886,
        "score": 3,
        "parent_id": "t3_1kdn2o4",
        "depth": 0
      },
      {
        "id": "mqf1cpd",
        "body": "If you aren’t willing to use your language yourself, why should anyone else bother?",
        "author": "HealthyPresence2207",
        "created_utc": 1746299253,
        "score": 2,
        "parent_id": "t3_1kdn2o4",
        "depth": 0
      },
      {
        "id": "mqgjorh",
        "body": "C compilers are also usually written in C (or I think gcc might be C++ now)",
        "author": "kohuept",
        "created_utc": 1746318314,
        "score": 2,
        "parent_id": "t3_1kdn2o4",
        "depth": 0
      },
      {
        "id": "mqgjx8k",
        "body": "Lean4 is such a cool language, definitely a bit of a learning curve but definitely worth if interested in logical verification. It has a lot of cool features. It's a fully functional purpose programming language (heavy haskell and some rust influences) with very good support for custom syntax like extensible operators and embedded DSLs. On top of all that, it's a proof assistant so you can reason about all the code you write with a concept called \"tactics\" (that also support extensible syntax and search methods).",
        "author": "Molkars",
        "created_utc": 1746318405,
        "score": 2,
        "parent_id": "t3_1kdn2o4",
        "depth": 0
      },
      {
        "id": "mqigo6w",
        "body": "So here is my understanding on this:\n1. Bootstrapping doesn't necessarily make your language slow, bootstrapping is just about using some basic functions you've written in another language to build up a your own language, all this end up in machine code. The compiling time performance depends on how well your language is designed for writing system level application like compilers, while the execution time performance depends on how much control do you give to the programmers. (For example: typescript is not designed for this purpose, thus the bootstrapping compiler was slow, while the go written compiler outperforms)\n\n2. Better optimization in strength points, people usually don't create a new language just for fun, they likely want to archive something that no languages out there can offer them. So it's good to bootstrapping, in order that your language doesn't rely on the other languages, enhancing your language's proprieties. \n\n3. Independency, and thus better maintainability of the compiler. Imagine to write a Your-Language compiler entirely in C, every time you wanna make a new feature, you have to write it in C. You're the creator of Your-Language, and likely supposed to be the one who knows Your-Language better than anyone, but you spend the most of your time programming in C, instead of Your-Language.\n\n4. Testing, to prove that a language is good for something, and make people even just look at your language, you're likely supposed to make a big project with it. And a compiler is such a project, not even talking about the many improvements to your language that could come out from your mind while making it. It's easier to identify the issues of something, when you actually use it.",
        "author": "Inky_bird",
        "created_utc": 1746352694,
        "score": 2,
        "parent_id": "t3_1kdn2o4",
        "depth": 0
      },
      {
        "id": "mqin9nf",
        "body": "In go it works like this:\n\n1. They have a compiler written in C that can compile go code up to go version \\~1.12.\n\n2. With that C compiler you compile go 1.12.\n\n3. They also have a compiler written in Go, and they use go 1.12 version to compile that one. Since go is fully backwards compatible, it works.\n\n4. The upper versions of go only come up with the Go compiler, but you already have a Go compiler at that point (v 1.12), so you can compile them.",
        "author": "throwaway-for-go124",
        "created_utc": 1746356560,
        "score": 2,
        "parent_id": "t3_1kdn2o4",
        "depth": 0
      },
      {
        "id": "mqq70q0",
        "body": "Lean the proof verification language?",
        "author": "Few_Acanthisitta_756",
        "created_utc": 1746461079,
        "score": 2,
        "parent_id": "t3_1kdn2o4",
        "depth": 0
      },
      {
        "id": "mqt2gmm",
        "body": "I once responded to a challenge by successfully writing a standard PL/1 program that prints out its own source file.",
        "author": "david-1-1",
        "created_utc": 1746492919,
        "score": 2,
        "parent_id": "t3_1kdn2o4",
        "depth": 0
      },
      {
        "id": "mqxvfmp",
        "body": "It’s a very good benchmark for the capabilities of a programming language. If a language can compile itself then you also have a guarantee of identical binaries between systems, whereas different C compilers might produce different binaries.",
        "author": "CatRyBou",
        "created_utc": 1746560523,
        "score": 2,
        "parent_id": "t3_1kdn2o4",
        "depth": 0
      }
    ],
    "1ke1xy4": [
      {
        "id": "mqfec91",
        "body": "Amusingly, somebody actually posted a guide about this the other day that you might find helpful.\n\n  \n[https://www.reddit.com/r/computerscience/comments/1kcigvx/fordfulkerson\\_algorithm\\_a\\_stepbystep\\_guide\\_to\\_max/?utm\\_source=share&utm\\_medium=web3x&utm\\_name=web3xcss&utm\\_term=1&utm\\_content=share\\_button](https://www.reddit.com/r/computerscience/comments/1kcigvx/fordfulkerson_algorithm_a_stepbystep_guide_to_max/?utm_source=share&utm_medium=web3x&utm_name=web3xcss&utm_term=1&utm_content=share_button)",
        "author": "Magdaki",
        "created_utc": 1746303580,
        "score": 3,
        "parent_id": "t3_1ke1xy4",
        "depth": 0
      },
      {
        "id": "mqodfr5",
        "body": "after augmenting your yellow path, the middle edge becomes 1/1 saturated, so the edge would disappear in the residual graph. but its reverse edge (the dotted direction) starts to _appear_ in the residual graph because you could augment this reverse edge (by decreasing the flow in the original edge). and then a s->1->0->t path in the residual graph becomes possible.",
        "author": "ktrprpr",
        "created_utc": 1746435113,
        "score": 2,
        "parent_id": "t3_1ke1xy4",
        "depth": 0
      }
    ],
    "1kdwc4c": [
      {
        "id": "mqefi2t",
        "body": "An Application Programming Interface is an intermediate between the application and almost anything else: other parts of the operating system, a driver, a website - it's a very general term. A driver is typically part of the operating system that provides some low-level functionality (such as interfacing with a hardware device, creating a new kind of file system) and presents an API to other parts of the system. Firmware is typically code stored outside of the operating system or userspace, that may not even run on the CPU. For example, your hard drive has a microcontroller in it that runs firmware code for how to run the hard drive. That code is the \"other end\" that the driver is speaking to.",
        "author": "nuclear_splines",
        "created_utc": 1746292495,
        "score": 11,
        "parent_id": "t3_1kdwc4c",
        "depth": 0
      },
      {
        "id": "mqm64tw",
        "body": "- API - How code interacts with other code\n- Driver - How your OS should use a device properly\n- Firmware - Software very close to the hardware (Drivers, microcode, BIOS, ...)\n\nTherefore, a driver is firmware, at least partially. And a driver uses the kernel's APIs to work with that kernel.",
        "author": "Specialist-Delay-199",
        "created_utc": 1746399316,
        "score": 3,
        "parent_id": "t3_1kdwc4c",
        "depth": 0
      }
    ],
    "1kc83d1": [
      {
        "id": "mq13hfo",
        "body": "If you do ceil(x2-x1) you're letting the voxels take non-integer positions. \nIf the voxels need to be integer-aligned, you want ceil(x2)-floor(x1). Or vice versa, depending on whether you want to include partial voxels at either edge. ",
        "author": "the_last_ordinal",
        "created_utc": 1746112058,
        "score": 7,
        "parent_id": "t3_1kc83d1",
        "depth": 0
      },
      {
        "id": "mq0h7h9",
        "body": "Can your computations \"live in\" rational space? e.g. if you're only dealing with integer powers, a \"fraction\" or \"rational\" class may be sufficient.",
        "author": "apnorton",
        "created_utc": 1746105067,
        "score": 7,
        "parent_id": "t3_1kc83d1",
        "depth": 0
      },
      {
        "id": "mq4siux",
        "body": "Ah, graphics. You might be limited to 32-bit floats.\n\nAlso, Ceil always rounds to the next highest number up. You might want a nearest integer function instead.\n\nUsually if you are comparing floats, instead of calculating equals, you subtract the two and say if it's within a certain precision. This would be another way\n\nprivate static float COLLISION\\_PRECISION = 0.002\n\nFor example, if (Math.abs(x2 - x1) < COLLISION\\_PRECISION) // x2 and x1 are the two numbers you want to be treated as equal",
        "author": "fuzzynyanko",
        "created_utc": 1746153915,
        "score": 5,
        "parent_id": "t3_1kc83d1",
        "depth": 0
      },
      {
        "id": "mq9dlfs",
        "body": "Don't use floats.\n\nVoxels should not be able to exist between grid points. Use non-decimal data types and float point isn't an issue.\n\nRemember, if you give your voxel position a float, you're basically saying each voxel is HUGE compared to the grid size. Like a million times the smallest grid cell. No way you actually want that.",
        "author": "TuberTuggerTTV",
        "created_utc": 1746217772,
        "score": 3,
        "parent_id": "t3_1kc83d1",
        "depth": 0
      },
      {
        "id": "mq2gtbg",
        "body": "You can just round the number to the closest 0.0001 or something like that, before taking the ceiling. But 81 boxes technically would not be enough to cover that area (again due to float inaccuracies), so depending on what you need it for, just keeping the result as 82 might be better, as if the size of the boxes and area is somewhat random your problem should occur very rarely",
        "author": "JohnsonJohnilyJohn",
        "created_utc": 1746126473,
        "score": 2,
        "parent_id": "t3_1kc83d1",
        "depth": 0
      },
      {
        "id": "mq9vpkj",
        "body": "Don’t subtract after quantizing. Those operations don’t commute or distribute even with real numbers. Don’t divide too soon, or you’ll compound rounding errors. This area of computer science is called numerical stability.\n\nLet `right` be the limit in the `x` dimension, and `left` be the other limit:\n\n    nCubes = ceil((right - left) / maxCubeSize)\n    function cubeLeft(iCube: int) {\n        return left + (right - left) * iCube / nCubes;\n    }\n    function posToCube(x: float) {\n         return floor(nCubes * (x - left) / (right - left))\n    }\n\nThe actual cube size will be less than `maxCubeSize‘ unless things line up perfectly, but things will line up perfectly when they can. By waiting to divide until you’re directly computing the result, you avoid multiplying the inevitable rounding error when dividing.",
        "author": "joelangeway",
        "created_utc": 1746223378,
        "score": 2,
        "parent_id": "t3_1kc83d1",
        "depth": 0
      },
      {
        "id": "mqm5yfi",
        "body": "You're encountering a classic floating-point precision issue when trying to voxelize a 3D bounding box. The problem occurs because computers represent decimal numbers using binary fractions, which can't exactly represent many decimal values. This causes small discrepancies that affect your calculations.\n\nceil((righttop.x-leftbottom.x)/cubesize) equals 82\n\nceil(righttop.x/cubesize)-ceil(leftbottom.x/cubesize) equals 81\n\nThis is happening because (righttop.x-leftbottom.x)/cubesize evaluates to 81.000001 due to floating-point errors, which when ceiled becomes 82.\n\n\n\nSolutions to Floating-Point Precision Issues\n\n1. Using an Epsilon Value: Add a small tolerance value to handle precision errors:\n\ndef count\\_voxels(min\\_val, max\\_val, cube\\_size):\n\nepsilon = 1e-10  # Small tolerance value\n\ncount = ceil((max\\_val - min\\_val) / cube\\_size - epsilon)\n\nreturn count\n\nor \n\n2. Rounding Before Ceiling: Round the result to a specific decimal place before applying the ceiling function:\n\ndef count\\_voxels(min\\_val, max\\_val, cube\\_size):\n\n\\# Round to 10 decimal places before ceiling\n\nresult = (max\\_val - min\\_val) / cube\\_size\n\nrounded\\_result = round(result, 10)\n\nreturn ceil(rounded\\_result)",
        "author": "West-Unit472",
        "created_utc": 1746399253,
        "score": 2,
        "parent_id": "t3_1kc83d1",
        "depth": 0
      }
    ],
    "1kbo001": [
      {
        "id": "mpw2w95",
        "body": "Nice!\n\nAs a CS educator, some ideas on a v1.1: Include indices, and then don't store small-integers, but instead use letter-dice.  (The distinction between `2` and `a[2]` can be confusing to learners, so having them be different types helps keep them straight.)",
        "author": "not-just-yeti",
        "created_utc": 1746040328,
        "score": 28,
        "parent_id": "t3_1kbo001",
        "depth": 0
      },
      {
        "id": "mpxx5ku",
        "body": "Kids these days and their doggone 3d printers and their alibabas.  Back in my day, we had egg cartons and pennies.  With an onion tied to my belt.",
        "author": "Ghosttwo",
        "created_utc": 1746061332,
        "score": 7,
        "parent_id": "t3_1kbo001",
        "depth": 0
      },
      {
        "id": "mpwh4l9",
        "body": "This is beautiful! Any chance this 3d design is present on any free online 3d printing sites?",
        "author": "forest-cacti",
        "created_utc": 1746044497,
        "score": 6,
        "parent_id": "t3_1kbo001",
        "depth": 0
      },
      {
        "id": "mq1bkh8",
        "body": "[Updated version with indexes](https://imgur.com/a/UQ9OYJH)",
        "author": "AdventurousTown4144",
        "created_utc": 1746114427,
        "score": 3,
        "parent_id": "t3_1kbo001",
        "depth": 0
      },
      {
        "id": "mpw25qx",
        "body": "That’s really cool.",
        "author": "bynaryum",
        "created_utc": 1746040107,
        "score": 2,
        "parent_id": "t3_1kbo001",
        "depth": 0
      },
      {
        "id": "mpwrzw7",
        "body": "I've always just used a multi day pill case for the example. But the little pointers are nice!",
        "author": "roopjm81",
        "created_utc": 1746047639,
        "score": 2,
        "parent_id": "t3_1kbo001",
        "depth": 0
      },
      {
        "id": "mpwu0eu",
        "body": "Damn, back in the day, we just used pen and paper.",
        "author": "AppropriateSpell5405",
        "created_utc": 1746048254,
        "score": 2,
        "parent_id": "t3_1kbo001",
        "depth": 0
      },
      {
        "id": "mpww0ej",
        "body": "really cool ngl",
        "author": "no_Im_perfectly_sane",
        "created_utc": 1746048870,
        "score": 2,
        "parent_id": "t3_1kbo001",
        "depth": 0
      },
      {
        "id": "mr28gk3",
        "body": "Oo that's good. Thanks for hosting on Dicearray as well. I might try to print some smaller ones to explain merge sort",
        "author": "MrHeavySilence",
        "created_utc": 1746624280,
        "score": 2,
        "parent_id": "t3_1kbo001",
        "depth": 0
      }
    ],
    "1kbmsen": [
      {
        "id": "mpybm4j",
        "body": "Love the article and its explanation on this! However, I wonder if what does it look like in the CPU with its mechanisms on carrying out the functions as GPU do and how does it differ from GPU’s?",
        "author": "Captainnick547",
        "created_utc": 1746066387,
        "score": 3,
        "parent_id": "t3_1kbmsen",
        "depth": 0
      }
    ],
    "1kaz67b": [
      {
        "id": "mpqc73m",
        "body": "You would have to look up the technical specs of whatever particular CPU you're interested in",
        "author": "Legitimate_Plane_613",
        "created_utc": 1745961724,
        "score": 21,
        "parent_id": "t3_1kaz67b",
        "depth": 0
      },
      {
        "id": "mpqy5nf",
        "body": "A typical CPU has thousands of registers of various bitwidths, these registers are used for everything from performance metrics, logging, power management, just a myriad of internal bookkeeping stuff. Are you just referring to the user programmable ones? Then probably 64bits since they would need to be able to store 64 bit addresses. During development we often have to dump the contents of all the registers to debug issues, a typically dump could be several gigs, maybe >100GBs. Intel doesn't publish those since you could technically reverse engineer the architecture if they did.",
        "author": "jsllls",
        "created_utc": 1745968820,
        "score": 6,
        "parent_id": "t3_1kaz67b",
        "depth": 0
      },
      {
        "id": "mpr5nvl",
        "body": "Do you mean architectural registers? As-in how much state is exposed to the software? Or do you mean physical registers, I.e., the physical hardware used for OoO execution?",
        "author": "MaxHaydenChiz",
        "created_utc": 1745971324,
        "score": 3,
        "parent_id": "t3_1kaz67b",
        "depth": 0
      },
      {
        "id": "mpsgmxh",
        "body": "Two answers:\n\nIf you want all the bits that could be stored such a CPU, you'd need to look at the design of each and ever detail of the full implementation of everything in the chip on a micro-architectural level , or possibly lower. Documentation like that isn't publicly available.  If it were, modulo patents and manufacturing techniques, anyone could make chips identical to the transistor of the CPU. All those micro-architectural details are Intel's secret sauce.\n\nThat first answer, basically calls any bit of storage on the die is a register (or part of one). A more sensible and useful definition of a register is storage which can be directly or indirectly accessed by instructions running on the CPU.  This removes cache (in most CPUs) from consideration (which is really helpful for reasons). Though simultaneous multithreading (Intel calls this Hyperthreading) maybe be problematic. \n\nUsing this second definition how many registers? I dunno, check the technical manual and count them up. I'd guess maybe ~200 registers in a single core.  Mind you that most of the non-general purpose registers (vector, SIMD, even just floating point) are bigger than 64 bits.\n\nA big factor with number of registers are the kind of addressing schemes the CPU provides. If a CPU lets you use a location in memory as operand for arithmetic, compared to only letting you pull values from RAM into the CPU with load commands, the number of registers needed varies a lot. CISC chips generally provide a wealth of addressing modes and few registers compared to RISC chips with very limited modes but lots of registers. This leading directly into  considering register spillage, and how well cache compensates for it. Or if you want to go back the 1st register definition, all the hidden registers modern CPUs use to fake spillage or reorder instructions to avoid it.  \n\nThis avoiding (as much as possible) that your i7 has at least 3 caches, an MMU (+ TLB), and a full memory controller (I'm sure I'm forgetting some parts).",
        "author": "dnabre",
        "created_utc": 1745988849,
        "score": 2,
        "parent_id": "t3_1kaz67b",
        "depth": 0
      },
      {
        "id": "mpsrhuc",
        "body": "It depends on what you count as a register. The isa says you have 16 64 bit registers plus various floating point ones and vector ones. Definitely less than the  48k ram the spectrum had. \n\nBut modern cpus have cache. If you count that, then it’s far more than the spectrum had.",
        "author": "Particular_Camel_631",
        "created_utc": 1745994609,
        "score": 2,
        "parent_id": "t3_1kaz67b",
        "depth": 0
      }
    ],
    "1kb3bea": [
      {
        "id": "mprca4p",
        "body": "It takes 2 problems for probing to be a notable issue unless your program is so performance tuned that every little cost is a problem.  Problem 1 is the table is too small, so the probe buckets generally get deep just because more data than places to put it.  Problem 2 is the hash function, and how randomly it distributes the data across your table.  If it is poor quality, it can make a deep bucket even in an nearly empty table, and you should catch that during testing and fix it, so its rarely a problem in reality as its part of the debugging.  Its easy to test your performance: have your table stuff everything in like the first (1...10 or so) locations with a modulo or something.  See how bad that feels with a larger than average load for intended use of the table.\n\nSearching even like 100 items is really, really fast today but its obviously still 100 times slower than just having the data in hand after hitting your table.  The question is, how many searches before your performance matters?  Another key factor is how costly your comparisons are.  Is it some awful string matching which could do a multiple compare of 30+ characters in a loop?   Its your program, you have to decide how much speed it needs.  If its fast enough, everything else is just playing with it, which we are probably all guilty of at times but unnecessary performance tuning is just lost dev time.\n\nFor some time now I have used my languages' built in random number generators for hashing.  Feed the key to the PRNG as the seed (something like SHA can help get it to a seed int), and lift the (fixed) 'random' values as the table locations.  This makes rehash really cheap too, as the second value, third value etc from your random number stream should be chaotic and throw the data around well, but you were asking about probing so that is not important today.\n\nTheoretically, if your hash table buckets are smaller than lg(N), then your program is outperforming a binary search, which is .. quite good.  O(1) is better, but still, that is only 20 probes to the million items.",
        "author": "Independent_Art_6676",
        "created_utc": 1745973580,
        "score": 3,
        "parent_id": "t3_1kb3bea",
        "depth": 0
      }
    ],
    "1kaigyx": [
      {
        "id": "mpmns8r",
        "body": "This is like you’ve come up with the hook for a joke, but you’re asking us to figure out the punchline - or rather the rest of your book.",
        "author": "fangus",
        "created_utc": 1745917160,
        "score": 77,
        "parent_id": "t3_1kaigyx",
        "depth": 0
      },
      {
        "id": "mpmjr9e",
        "body": "It sounds like you're expecting some magic to happen ... but then you'll need to make something up, because reality doesn't support that in any way. No \"anomaly will appear\".\n\nFor sure it will be interesting for CS and some other science areas. Also for sure, anything that outside of human society is not affected at all. Somewhat likely, there are no effects outside of science because just P=NP doesn't automatically imply a practical calculation speedup.\n\nAt worst, there'll be a chaotic time for humanity that takes a long while to calm down, because lots of things we take for granted can suddenly be abused / become unreliable. Banking here, secret military communication there, ... long term, science could benefit from it in many ways. Understanding/developing things faster than before.",
        "author": "dkopgerpgdolfg",
        "created_utc": 1745914514,
        "score": 42,
        "parent_id": "t3_1kaigyx",
        "depth": 0
      },
      {
        "id": "mpmi8gm",
        "body": "I cannot put into words how much hatred I feel after reading this.",
        "author": "indjev99",
        "created_utc": 1745913534,
        "score": 17,
        "parent_id": "t3_1kaigyx",
        "depth": 0
      },
      {
        "id": "mpn0z47",
        "body": "This was asked two days ago: https://www.reddit.com/r/computerscience/comments/1k94pqk/what_happens_if_pnp/",
        "author": "apnorton",
        "created_utc": 1745924776,
        "score": 11,
        "parent_id": "t3_1kaigyx",
        "depth": 0
      },
      {
        "id": "mpovb2n",
        "body": "Somewhat relevant to this discussion is [Impagliazzo's Five Worlds](https://citeseerx.ist.psu.edu/document?repid=rep1&type=pdf&doi=238e9dbe512b8b87acc2ec927d8dc17f3fbda4b9).  A resolution to the P vs NP problem could take many different forms; this paper presents a fictionalized view of the possible futures that could come to be when the question is resolved.  In writing your fiction, you might want to pick one of these possibilities to explore, since it constructs a bit of world building impacts, too.\n\n\nThere's a lot of discussion on this paper online (blog posts, Q&A, etc), so it might be a helpful jumping off place.",
        "author": "apnorton",
        "created_utc": 1745946580,
        "score": 5,
        "parent_id": "t3_1kaigyx",
        "depth": 0
      },
      {
        "id": "mpmpuzx",
        "body": "It is depending if prove is by contradiction or constructive.\n\nIf it's by contradiction (we just proved it is but nothing else), just a lot of ripples across science and (some) industries, mostly around crypto (P=NP means, that every crypto validated in P can be decrypted in NP, which suddenly is ==P).\n\nIf it's constructive, means, that someone found a P solution for NP problem, that's make things interesting. Cryptography is gone, a lot of hard problems become extremely simple (including code correctness, pathfinding, optimization problems).\n\nI think it's worth to go into different industries and see where they have workaround for NP-hard problems, and what happens, if they are no longer needed.",
        "author": "amarao_san",
        "created_utc": 1745918515,
        "score": 3,
        "parent_id": "t3_1kaigyx",
        "depth": 0
      },
      {
        "id": "mpno2b1",
        "body": "As a side note, an Indie movie was made in 2013 or thereabouts on a similar premise - it was called *Traveling Salesman*. It was funded via a crowd-funding web site. I don't know whether it was ever widely distributed though.\n\nFor another speculative story about a different case of an answer to a mathematical question being different from what most people expect, see Ted Chiang's short story *Division by Zero*.",
        "author": "Ok-Lavishness-349",
        "created_utc": 1745933761,
        "score": 3,
        "parent_id": "t3_1kaigyx",
        "depth": 0
      },
      {
        "id": "mpnd68a",
        "body": "The last time this was solved, a portal broke open and a bunch of alien monsters came to wreak havoc on humanity and bring its end. \n\nI wouldn’t worry about it this time tho. We’re a bunch of dummies. And also we seem to be bringing our own end quick enough so",
        "author": "FormerTimeTraveller",
        "created_utc": 1745929933,
        "score": 2,
        "parent_id": "t3_1kaigyx",
        "depth": 0
      },
      {
        "id": "mpnux6o",
        "body": "I really think encryption would be the big one.\n\nImagine being able to decrypt nearly everything. You couldn’t do things like bank online.\n\nImagine encryption was broken so badly that HTTPS became worthless overnight. That would cause a huge disruption as half of the major sites get hacked while the other half just go dark to prevent further damage.\n\nThe world goes “offline” for a few weeks while people scramble to come up with software updates to upgrade everyone to safe encryption, but even distributing those updates is problematic so it has to be done in person.\n\nSounds like a good plot to me.",
        "author": "dmazzoni",
        "created_utc": 1745935942,
        "score": 2,
        "parent_id": "t3_1kaigyx",
        "depth": 0
      },
      {
        "id": "mpoorfx",
        "body": "There's a book you might want to look into that one of my college professors recommended to me when I was asking a lot of the same questions back in the day. It's called \"Quantum Computing Since Democritus\", and though I never read it, he suggested that there's a pretty significant portion of it dedicated to what the consequences of P=NP are.",
        "author": "xXProdigalXx",
        "created_utc": 1745944711,
        "score": 2,
        "parent_id": "t3_1kaigyx",
        "depth": 0
      },
      {
        "id": "mpphrnu",
        "body": "Proving P=NP doesn't actually do much. It just tells you for every non-polynomial problem, there is a polynomial solution. But it doesn't tell you what that solution is for any given problem. You still have to do the hard work of finding that solution for any given problem. Each one would be bespoke. Or at least each class of problem would be.\n\nIf P=NP were solved tomorrow, a year from now the world probably wouldn't look very different than it does today.",
        "author": "Literature-South",
        "created_utc": 1745952957,
        "score": 2,
        "parent_id": "t3_1kaigyx",
        "depth": 0
      },
      {
        "id": "mprihdd",
        "body": "In an alternative reality something like this may happen;\n\n1. **Initial excitement followed by disappointment**: The world first panics at the P=NP proof, then relaxes when they realize the high polynomial degree makes it impractical.\n\n2. **The true threat emerges gradually**: Your protagonist realizes the special conditions that enable efficient solutions are becoming more common or controllable.\n\n3. **Competing factions**: Some groups might:\n   - Try to create environments that enable lower-degree P=NP solutions\n   - Build devices that exploit these conditions\n   - Attempt to suppress knowledge of the special circumstances\n\n4. **Selective disruption**: Instead of total cryptographic collapse, you get targeted vulnerabilities:\n   - Certain systems fail while others remain secure\n   - Unpredictable breakthroughs in specific domains\n   - \"P=NP zones\" where computing power is drastically enhanced\n\nThis allows you flexibility in the story about what effects it could have. PS I used AI to help me",
        "author": "paroxsitic",
        "created_utc": 1745975669,
        "score": 2,
        "parent_id": "t3_1kaigyx",
        "depth": 0
      }
    ],
    "1ka1y8r": [
      {
        "id": "mpithgo",
        "body": "Well, that's a research topic in itself. A CPU can have different scheduling strategies depending on what it is used for. I.e. Priority based scheduling, Shortest Job First, Shortest Remaining Time, Round Robin etc...",
        "author": "YamKey638",
        "created_utc": 1745863724,
        "score": 61,
        "parent_id": "t3_1ka1y8r",
        "depth": 0
      },
      {
        "id": "mpiu8il",
        "body": "Read this: [https://pages.cs.wisc.edu/\\~remzi/OSTEP/](https://pages.cs.wisc.edu/~remzi/OSTEP/)\n\nChapters 3-11 are all relevant, but Ch 7 will likely answer your question (edit: 6.3 is also useful). Your numbers are off--the context switch can be fast as long as little needs to be swapped (you may want to read the memory chapters too).",
        "author": "YetYetAnotherPerson",
        "created_utc": 1745863949,
        "score": 13,
        "parent_id": "t3_1ka1y8r",
        "depth": 0
      },
      {
        "id": "mpixupg",
        "body": "It's definitely OS-dependent. One of the OS's core jobs is to schedule threads to run on a processor and there are lots of different ways to do it.\n\nThe processor isn't aware of the concept of threads. The OS kernel sets up interrupts that happen either when there's I/O, or at regular timer intervals. In one of those interrupts, the kernel can choose to switch threads, which it does by saving the state of one thread, then resuming the state of another thread, and then continuing that thread where it left off.\n\nOn Linux, the default algorithm is based on categorizing each thread as either IO-bound or CPU-bound. IO-bound threads spend most of their time waiting for the disk, or the network, or the user (keyboard and mouse). The OS tries to minimize latency for these threads - when I/O is available, it wakes the thread up as soon as possible. For cpu-bound threads, it tries to provide longer time slices but doesn't prioritize waking it up immediately.\n\nOther factors include thread / process priorities - so the OS can try to ensure that the computer still feels responsive even if it's under heavy load.\n\nOn Linux, you can switch the scheduling algorithm - some servers prefer a different algorithm.\n\nThere's no theoretical limit to the number of threads, but most operating systems do have a limit to keep things from getting out of hand. On Unix systems it's just an environment variable you can configure if you want to make it higher.",
        "author": "dmazzoni",
        "created_utc": 1745865028,
        "score": 9,
        "parent_id": "t3_1ka1y8r",
        "depth": 0
      },
      {
        "id": "mpiwwm1",
        "body": "There are many strategies you can use, but I think one that was popular was clock-stealing with priority. A single core, single thread CPU isn’t actually active 100% of the time, so other processes can interject themselves into the dead space to do some work. How to prioritize processes in such a system, and even which strategy to use, is still a topic of research today!",
        "author": "_abscessedwound",
        "created_utc": 1745864745,
        "score": 7,
        "parent_id": "t3_1ka1y8r",
        "depth": 0
      },
      {
        "id": "mpirg6o",
        "body": "I don't see any prior posts of yours removed by the automod, so you can be more specific if you like and I'll approve it if the automod removes it.",
        "author": "Magdaki",
        "created_utc": 1745863121,
        "score": 3,
        "parent_id": "t3_1ka1y8r",
        "depth": 0
      },
      {
        "id": "mpjeg0n",
        "body": "3ms.  Not much time?  On a 4ghz processor, that is 4 billion per second, that means you could have executed over 10 million instructions alongside the swap.  And swapping is costly, but less than it used to be as hardware has been leaning into more threads and optimizations to support it are in place.  Regardless, I don't know the numbers but I am convinced the engineers who do this work would: the process switching costs something and the amount of time allocated to crunch after that is sufficient to get a good bit done before swapping again.  That is, the amount of time in the total process time slice is going to be like 80 or 90% crunch time and only 10-20% or less swap time. \n\nIn the old days, computers were just slower.  Trying to run too much at once hit you in the gut 3 or 4 times... your memory ran out so it did a big page file swap to disk, your cpu was taxed and swapping cost a lot so clicking one program to another could take seconds, even minutes, to bring the second one up. DOS had to be pushed by a highly literate user to run more than 1 thing at once (sorta) while the windows of the era could do it (but was not an operating system: windows was a program that sat on top of dos at this point in history).  I wouldn't study dos/windows really deep.. its interesting stuff, but its from an era where the machines struggled to fit programs into their limited memory, caches, and even had fairly small disks.   They did the single core threading much as has been said, but generally, the programs were single threaded and so this was multiple programs running at once time, fighting for resources and the loser of the fight was the end user.    Instead, see if you can find a modern explain on what happens when you finally tap out a modern machine.  It can be done, and the OS has fallbacks for when all the cores are running flat out.",
        "author": "Independent_Art_6676",
        "created_utc": 1745870044,
        "score": 3,
        "parent_id": "t3_1ka1y8r",
        "depth": 0
      },
      {
        "id": "mpjr1q8",
        "body": "> If each process is limited to 3 milliseconds, then most of the CPU time is spent swapping between processes and not actually running them.\n\n\nA quick search suggests that context switching on modern intel cpus takes a few microseconds so that's only 1% of the time slice.",
        "author": "xaraca",
        "created_utc": 1745873810,
        "score": 3,
        "parent_id": "t3_1ka1y8r",
        "depth": 0
      }
    ],
    "1k94pqk": [
      {
        "id": "mpbgmmp",
        "body": "In practice, probably not much unless someone finds a polynomial solution for an NP-complete problem that scales with at most O(n^3 ). In theoretical terms it would lead to the collapse of the complexity hierarchy.",
        "author": "flumsi",
        "created_utc": 1745764367,
        "score": 148,
        "parent_id": "t3_1k94pqk",
        "depth": 0
      },
      {
        "id": "mpbev23",
        "body": "in theory, certain cryptography algorithms will break down, and a vast swath of real-world programs will be rewritten to be much faster and with less memory usage. \n\nIt is however possible that P=NP only when galactic algorithms are involved, at which point it wouldn't really matter.",
        "author": "dude132456789",
        "created_utc": 1745763789,
        "score": 105,
        "parent_id": "t3_1k94pqk",
        "depth": 0
      },
      {
        "id": "mpbcgsc",
        "body": "N=1",
        "author": "bernoullistokes",
        "created_utc": 1745762983,
        "score": 42,
        "parent_id": "t3_1k94pqk",
        "depth": 0
      },
      {
        "id": "mpbecdq",
        "body": "It likely depends on how big the polynomials need to be. Like, if the polynomial equivalence is n to the 100th power, i doubt it changes that much in practice.",
        "author": "Dragostorm",
        "created_utc": 1745763616,
        "score": 30,
        "parent_id": "t3_1k94pqk",
        "depth": 0
      },
      {
        "id": "mpc682b",
        "body": "A lot of my proofs would become redundant, and I would have to change research topics. That would probably be the most significant effect.",
        "author": "Fresh_Meeting4571",
        "created_utc": 1745772400,
        "score": 24,
        "parent_id": "t3_1k94pqk",
        "depth": 0
      },
      {
        "id": "mpbesvb",
        "body": "[https://www.reddit.com/r/compsci/comments/3dcain/what\\_would\\_happen\\_if\\_p\\_np\\_was\\_solvedproved/](https://www.reddit.com/r/compsci/comments/3dcain/what_would_happen_if_p_np_was_solvedproved/)",
        "author": "SendAstronomy",
        "created_utc": 1745763768,
        "score": 10,
        "parent_id": "t3_1k94pqk",
        "depth": 0
      },
      {
        "id": "mpceub2",
        "body": "Someone gets a million dollars",
        "author": "Yendric",
        "created_utc": 1745774971,
        "score": 10,
        "parent_id": "t3_1k94pqk",
        "depth": 0
      },
      {
        "id": "mpcnn0u",
        "body": "Afaik, optimal algorithms for solving NP complete problems are already know (up to the constant factor). They are based [Levin Universal Search](http://www.scholarpedia.org/article/Universal_search). A proof of NP=P would mean that the algorithm is polynomial even though the constant factor is still ... astronomical.",
        "author": "tstanisl",
        "created_utc": 1745777585,
        "score": 9,
        "parent_id": "t3_1k94pqk",
        "depth": 0
      },
      {
        "id": "mpbpo88",
        "body": "Then CoNP = NP.",
        "author": "Eroica_Pavane",
        "created_utc": 1745767252,
        "score": 7,
        "parent_id": "t3_1k94pqk",
        "depth": 0
      },
      {
        "id": "mpcis35",
        "body": "Will finally get some sleep 😴",
        "author": "orbit99za",
        "created_utc": 1745776122,
        "score": 6,
        "parent_id": "t3_1k94pqk",
        "depth": 0
      },
      {
        "id": "mpbyhzz",
        "body": "Current age cryptographic security would break, optimization would explode, and AI discovery would accelerate.",
        "author": "StackOwOFlow",
        "created_utc": 1745769979,
        "score": 4,
        "parent_id": "t3_1k94pqk",
        "depth": 0
      },
      {
        "id": "mpbzre0",
        "body": "Judgment Day",
        "author": "ACrossingTroll",
        "created_utc": 1745770372,
        "score": 3,
        "parent_id": "t3_1k94pqk",
        "depth": 0
      },
      {
        "id": "mpd6ucv",
        "body": "Every algorithm is O(1) since time is an illusion 🤓☝️",
        "author": "Positive-Fee-8546",
        "created_utc": 1745783566,
        "score": 3,
        "parent_id": "t3_1k94pqk",
        "depth": 0
      },
      {
        "id": "mpelzbi",
        "body": "I can finally quit searching.",
        "author": "Paul__miner",
        "created_utc": 1745800488,
        "score": 3,
        "parent_id": "t3_1k94pqk",
        "depth": 0
      },
      {
        "id": "mpevw9f",
        "body": "Whoever finds a way to prove it gets a million dollars.",
        "author": "nwbrown",
        "created_utc": 1745804169,
        "score": 2,
        "parent_id": "t3_1k94pqk",
        "depth": 0
      },
      {
        "id": "mpf0uzk",
        "body": "https://www.youtube.com/watch?v=6ybd5rbQ5rU",
        "author": "rlyacht",
        "created_utc": 1745806009,
        "score": 2,
        "parent_id": "t3_1k94pqk",
        "depth": 0
      },
      {
        "id": "mpg64xq",
        "body": "There are (at least) three ways it bring proven true would be pretty meaningless, at least in practice: \n\n1) This is a bit pedantic, but nobody can prove it.\n\n2) It's quite possible that someone proves P=NP, without that proof giving any insight in how you might solve NP problems in P-time. The idea might seem pretty out there for people without much math experience. However, it's not unheard of, or even particularly uncommon (arguably), to prove something is possible to do, but that proof in no way helping you actually do the thing you've proven possible.  i.e. we found out that P=NP, but basically nothing other than fact is true.\n\n2) We have the proof that P=NP. We figure how to love NP problems in P-time. However, the time for any of the NP problems we make P-time solutions for are incredibly slow. P-time is definitely better than exponential, but  O(n^20) may still be intractable in many cases. Imagine if we can convert an NP problem, previously thought to be only solvable in exponential time, say O(2^n), into P-time but it's O(n^1_000_000).  Yeah when n gets to a 30 million or so (which is actually surprisingly low to me), that polynomial may be faster, but that doesn't make the algorithm particular useful.  This would likely cause a lot of change for theorists, but may have pretty limited direct practical results.",
        "author": "dnabre",
        "created_utc": 1745826585,
        "score": 2,
        "parent_id": "t3_1k94pqk",
        "depth": 0
      },
      {
        "id": "mpgdld6",
        "body": "Ohhh ummm.. Noooooothiiiiing ;D",
        "author": "Revolutionalredstone",
        "created_utc": 1745831508,
        "score": 2,
        "parent_id": "t3_1k94pqk",
        "depth": 0
      },
      {
        "id": "mpglr09",
        "body": "> No I don’t have a proof I was just wondering ... what happens if P=NP?\n\n... is exactly what someone who has a proof would say 😜",
        "author": "SonOfSofaman",
        "created_utc": 1745836517,
        "score": 2,
        "parent_id": "t3_1k94pqk",
        "depth": 0
      }
    ],
    "1k93ewk": [
      {
        "id": "mpbf742",
        "body": "[https://en.wikipedia.org/wiki/Code:\\_The\\_Hidden\\_Language\\_of\\_Computer\\_Hardware\\_and\\_Software](https://en.wikipedia.org/wiki/Code:_The_Hidden_Language_of_Computer_Hardware_and_Software) is your book \n\nBut there's no book which will give you that big of an overview",
        "author": "drugosrbijanac",
        "created_utc": 1745763900,
        "score": 9,
        "parent_id": "t3_1k93ewk",
        "depth": 0
      },
      {
        "id": "mpbuvo1",
        "body": "What you are asking for is too much information to be contained in one book. That said I suggest you go through:\n\n1. Code by Charles Petzold\n2. OSTEP\n4. Networking: A top down approach\n5. DDIA\n\nMore or less in this order.",
        "author": "-PxlogPx",
        "created_utc": 1745768863,
        "score": 6,
        "parent_id": "t3_1k93ewk",
        "depth": 0
      },
      {
        "id": "mpb7ylg",
        "body": "Good computer architecture and systems programming courses would be a HUGE help in understanding all of those things!  There isn't a single book that maps all the current innovations into the CS knowledge base that would explain all of it to you in an easy to digest form.  It would be too lengthy and involved for a beginner anyway. \n\nThe easiest way forward is to simply start with the basics.  Go through a CS curriculum \"the hard way\" and you'll see that's actually the easiest way to understand innovations from the ground up.  \n\nBesides that, it will take a few years for you to see patterns in the innovations themselves and how they build on the past.  For example:  What relation does IBM's work on virtualization in the 1960's on mainframes bear on containers from today?  Well, technically they have nothing to do with each other, but then again, they solve many of the same problems but understanding how and the trade-offs that were made in each case is deep.  You can obviously use ChatGPT and the like to explore questions like that, but you won't know the relationships are there until you've been around a while.",
        "author": "vplatt",
        "created_utc": 1745761392,
        "score": 2,
        "parent_id": "t3_1k93ewk",
        "depth": 0
      },
      {
        "id": "mpk6fkr",
        "body": "[R&L](https://books.google.co.uk/books?id=pyTFAAAACAAJ) offers a more holistic view than most books on the individual topics of computer architecture, operating systems and system software, and computer networking.",
        "author": "srsNDavis",
        "created_utc": 1745878870,
        "score": 2,
        "parent_id": "t3_1k93ewk",
        "depth": 0
      }
    ],
    "1k8imyd": [
      {
        "id": "mp6nux6",
        "body": "Read ***Designing Data Intensive Applications*** by ***Martin Kleppmann***",
        "author": "bssgopi",
        "created_utc": 1745691347,
        "score": 5,
        "parent_id": "t3_1k8imyd",
        "depth": 0
      }
    ],
    "1k8i5iw": [
      {
        "id": "mp8oaos",
        "body": "Read through \"a concise introduction to pure mathematics\" by martin liebeck. It's a relatively short as the name suggests but is very good\n\nAfter that you could go through some of the relevant chapters of \"discrete mathematics and it's applications\" by Kenneth h rosen. It's a really long book but quite detailed",
        "author": "Worth_Bunch_4166",
        "created_utc": 1745715970,
        "score": 3,
        "parent_id": "t3_1k8i5iw",
        "depth": 0
      }
    ],
    "1k7q893": [
      {
        "id": "mp19cin",
        "body": "A bit of memory is either electrified (1) or not (0).\nIf you buy a brand new ssd it's probably all zeroes, but in practice it doesn't really matter. When you have \"empty\" space the bits can have arbitrary values, because they won't be checked. When the memory is allocated to a file, all the bits are overwritten with something that does have meaning. When a file is deleted, we just designate the space as \"empty\", so the bits still actually have their previous value, we just don't care anymore.\n\nWhen formatting a drive, you can decide whether the computer should overwrite everything with zeroes, or just leave it be and designate it as empty. That's usually the difference between a \"quick\" format and a normal format, although systems often have the quick version as default behavior.",
        "author": "Senguash",
        "created_utc": 1745613824,
        "score": 45,
        "parent_id": "t3_1k7q893",
        "depth": 0
      },
      {
        "id": "mp131ar",
        "body": "In theory, you should consider any unallocated memory to have undefined contents.  It likely just has random residual electrical signals in it that don't \"mean\" anything, but just are present.",
        "author": "apnorton",
        "created_utc": 1745611916,
        "score": 11,
        "parent_id": "t3_1k7q893",
        "depth": 0
      },
      {
        "id": "mp4c7da",
        "body": "Some modern SSDs store 2, or 3, bits per cell, meaning that a cell can have 4, or 8, different voltages (instead of binary 0 and 1)",
        "author": "BigPurpleBlob",
        "created_utc": 1745659973,
        "score": 5,
        "parent_id": "t3_1k7q893",
        "depth": 0
      },
      {
        "id": "mp19d5s",
        "body": "An SSD's memory contains a plurality of flash blocks, each of which holds a plurality of pages that may be either blank or hold a sector's data along with information about which logical sector it holds and the order in which it was written relative to other pages.  Rewriting a sector requires finding a blank page and writing the new data there along with the sector number and information identifying the new data as more recent than the previous version of that sector.\n\nAt a hardware level, the only way an SSD can reuse storage is by finding a block whose pages are mostly junk, copying any pages that aren't junk elsewhere, and then erasing all pages within the block simultaneously.\n\nIf a logical sector is unused, that means that no live page in flash contains data for it.  Typically, no storage for the sector would exist anywhere unless or until it is written.",
        "author": "flatfinger",
        "created_utc": 1745613829,
        "score": 2,
        "parent_id": "t3_1k7q893",
        "depth": 0
      },
      {
        "id": "mpfnmo1",
        "body": "There are two trips of electronic memory. NAND and NOR. One is made of NAND flash is made out of NOT and AND gates. NOR is made of NOT and OR gates. \n\nOne kind is (NAND) erased to all zeros. The other kind  (NOR) is erased to all ones. NAND is slower than NOR to when changing single bits but faster overall when you write a lot of bits in order. NOR has a longer reliable lifespan before the bits start to become uncertain. \n\nSo each type of flash chip has a different purpose and structure. \n\nWhen you write to any kind of flash you have to erase a whole region, commonly called a page, usually two consecutive kilobytes (so 16 kbits). And then you write the region by twiddling the bits that aren't correct. \n\nBy that I mean if you want to write a value to some NAND flash you erase the page to turn all the bits on, and then you turn off the bits that shouldn't be on to save the actual bike values. \n\nOne of the big advancements that happened in making ssds practical is that they put a whole bunch of logic on the chips so that the user application doesn't have to read the entire 2K region out figure out what bits to twiddle manually do the array so then manually do the write.\n\n In a modern flash chip there are a bunch of spare pages and when you write a section it actually figures everything out internally does the copy from the currently visible page they represents the address you're writing to create the new changed page and then it swaps the two in place with some jiggery pokery. \n\nAnd one of the reasons flash chips can get slower is that it can get very Tangled in terms of which page is visible on when you ask for which address. \n\nSo if you look at modern file systems and stuff you will discover that they have a trim operation. \n\nRather than erasing a page by manually writing zeros over it or manually writing ones over it as the operating system would do the operating system says \"hey the particular 2K page that lives in this particular location is something I don't need anymore\" and the individual hardware chip will say okay thanks, it will erase that page, make a note that if anything tries to read from the address it just vacated it will return whatever it's default value is instead of actually looking for a page, and then we'll sort that page back into the free list where it can be most effectively found in the future. \n\nSo there's a whole dance going on. \n\nWhen you get a brand new flash chip what's happened is that the manufacturer has trimmed the entire chip. \n\nWhat that means is that all the pages have been erased to whatever they're default value is depending on the electrical kind of chip it is. \n\nBut also none of those pages are connected up. When you try to read from an area that hasn't been written yet it hits a piece of logic that says hey there's no page here at all and the chip gives you a stock answer. \n\nThe modern computing equipment plays many games and there is not one correct answer for what's there if you try to read from it. \n\nThis also means that there's a stupid human trick. If you've got a piece of flash and it is not wired up to allow you to trim it, but you happen to know which type of hardware it actually is made out of, you can write the entire visible area of the chip using the right value (that is all bits set or all bits off as appropriate) and the chip will do the erase page thing and then realize it doesn't have to twiddle any bits. And if you do that for the entire space of the chip in order you can get it almost as clean as if you could trim it. \n\nThis can be very useful for bringing like a USB thumb drive back to life because most USB drives do not actually support trimming because there is no USB command equivalent to tell the shift to do the trim. \n\nAnd if you've got a USB drive enclosure that's got a solid state disc in it one of the things you can do if the performance of that drive starts falling apart is literally disassemble the enclosure put the drive into a regular computer hooked up with the SATA adapter and trim the entire drive to recondition it before putting it back in the enclosure. Obviously you will have just erased the entire drive but that gets you your speed and efficiency back. \n\nSo there's this whole thing going on \n\n🐴🤘😎",
        "author": "BitOBear",
        "created_utc": 1745815797,
        "score": 3,
        "parent_id": "t3_1k7q893",
        "depth": 0
      },
      {
        "id": "mp4zoxu",
        "body": "Brand new SSDs actually come pre-initialized from the factory with a specific pattern (usually all 1's at the flash level, which reads as all 0's to the controller) becuase flash memory cells must be explicitly programmed to hold data.",
        "author": "nickthegeek1",
        "created_utc": 1745671829,
        "score": 2,
        "parent_id": "t3_1k7q893",
        "depth": 0
      },
      {
        "id": "mp50566",
        "body": "In SSD, physical sectors are mapped to logical sectors through a mapping table.\n\nIn all erased state, all physical sectors are in a free list, and all logical sectors are unmapped (read as zeros).",
        "author": "WoodyTheWorker",
        "created_utc": 1745672007,
        "score": 2,
        "parent_id": "t3_1k7q893",
        "depth": 0
      },
      {
        "id": "mp663ek",
        "body": "Each bit is either 0 or 1 (even if multiple bits are stored in one cell, which voltage we interpret as some combination of those bits) - it is how we interpret them, which gives them a meaning. Devices can be zeroed (or one-ned) out, or just contain random 0 and 1. Since none of them can be interpreted as a valid data, they show up empty in end user software",
        "author": "Grubzer",
        "created_utc": 1745685938,
        "score": 2,
        "parent_id": "t3_1k7q893",
        "depth": 0
      },
      {
        "id": "mp6usgs",
        "body": "What's in a box that no one is using anymore?\n\nI dunno, man. It could be empty. It could have stuff inside that was long forgotten. Who knows!\n\nFinders keepers!!",
        "author": "jontzbaker",
        "created_utc": 1745693493,
        "score": 2,
        "parent_id": "t3_1k7q893",
        "depth": 0
      }
    ],
    "1k70ncf": [
      {
        "id": "moub8v1",
        "body": "CDs are storage **media** but not devices.  The drives that read them are storage devices.  The CDs and blu-ray disks have no way to interface with the computer on their own.  \n\nIt's the same reason that paper is not an output device.  It's the medium used by an ouput device (printer), but the paper is not the output device itself.\n\n(In reality though, this is VERY nitpicky.  If your grade is borderline and this would give you the last points needed to move up a letter grade, message your teacher.  Good teachers are more concerned with you actually thinking and understanding and will accept a reasonable argument.)",
        "author": "ChrisC1234",
        "created_utc": 1745522354,
        "score": 358,
        "parent_id": "t3_1k70ncf",
        "depth": 0
      },
      {
        "id": "mouebxv",
        "body": "Personally I think that CDs are a storage device. I don't think that \"device\" necessarily implies that it must be powered computer hardware or anything like that. A \"device\" is simply an object with a purpose. The CD's purpose is to store data, so it's a storage device.\n\n[Dictionary.com](http://Dictionary.com) specifically includes CD as an example in its definition of storage device: [https://www.dictionary.com/browse/storage%20device](https://www.dictionary.com/browse/storage%20device)\n\nCollins dictionary describes it as \"a piece of computer equipment, such as a magnetic tape, disk, etc, in or on which data and instructions can be stored, usually in binary form\", CDs fit this description exactly [https://www.collinsdictionary.com/us/dictionary/english/storage-device](https://www.collinsdictionary.com/us/dictionary/english/storage-device)\n\nWikipedia's page on \"Data storage\" also has a picture including a CD captioned as being \"storage devices\".\n\nClearly this is not a settled debate :)",
        "author": "borks_west_alone",
        "created_utc": 1745523283,
        "score": 63,
        "parent_id": "t3_1k70ncf",
        "depth": 0
      },
      {
        "id": "mouhicu",
        "body": "This is a teachable moment. When in doubt,  advocate for youself.",
        "author": "UntrustedProcess",
        "created_utc": 1745524231,
        "score": 34,
        "parent_id": "t3_1k70ncf",
        "depth": 0
      },
      {
        "id": "moubsc6",
        "body": "1. CDs have long been included in the definition of secondary storage devices.\n2. A smart phone certainly falls under ubiquitous computing. A smart watch might be a bit more grey, but if I were answering that question, then I would have selected yes.",
        "author": "Magdaki",
        "created_utc": 1745522516,
        "score": 20,
        "parent_id": "t3_1k70ncf",
        "depth": 0
      },
      {
        "id": "moub2bm",
        "body": "It literally an optical drive. \n\nGuess what's in an HDD? A fucking disc.\n\nYour final is stupid.",
        "author": "Greasy-Chungus",
        "created_utc": 1745522301,
        "score": 12,
        "parent_id": "t3_1k70ncf",
        "depth": 0
      },
      {
        "id": "mouftfq",
        "body": "This is the classic problem on mc tests where it's not as clear cut as T or F. I've never heard the term \"Ubiquitous Computing\" until now, but from the Wikipedia article for it \n\n\\> Ubiquitous computing is the concept of using small internet connected and inexpensive computers to help with everyday functions in an automated fashion.\n\nI wouldn't say a modern smart watch meets that defintion, but I can see how it'd be confusing. Computers embedded in sensors, or digital (non-smart) watches, would probably be good examples of ubiquitous computing devices. They're not computers for the sake of being a computer, they serve other purposes and the fact that there's a computer in there is more of an accident of the fact that that is useful toward some other end.\n\nAnd a CD is a storage device in the same sense that a notepad is a storage device, so like, eh. They're in such far reaches in any educational discussion of computer data stores that it's more of a joke to bring them up, like floppy disks at this point. The CPU's caches, RAM, SSD, HDD, and network storage are highly relevant to modern computer operation, CDs are not. That said, they would fall in the Off-line stroage if not Tertiary storage section of the [wiki article](https://en.wikipedia.org/wiki/Computer_data_storage) on Computer Data Storage.",
        "author": "reednel",
        "created_utc": 1745523730,
        "score": 5,
        "parent_id": "t3_1k70ncf",
        "depth": 0
      },
      {
        "id": "moujhsv",
        "body": ">Is this worth sending a message to him for?\n\nJust do whatever you think you need to do to pass the class and move on. The nature of the questions hints that this whole class is pointless. You need to spend as little energy as possible here and just get through it, so you can focus on deeper CS curriculum courses.",
        "author": "Metal_Goose_Solid",
        "created_utc": 1745524814,
        "score": 5,
        "parent_id": "t3_1k70ncf",
        "depth": 0
      },
      {
        "id": "moxp2p1",
        "body": "1. For all intents and purposes, you can take the answer to be true, unless you want to cherry-pick the term \"device\" and over-philosophize about it. Yes, CDs and such are technically storage “media”, not devices. But that's just one of the many normalized misnomers and mislabels in CS that everyone has agreed to accept unconditionally. Just as we still call SSDs “hard drives”, we call fiber Internet cards \"modems\" (but they don't do any modulation), the “power supply” is actually a power converter, “USB stick drives” aren't drives because they don't have any drive mechanisms in them, and countless other examples. So they can be technically right about this, and if they want to be pedantic to the point of being counterproductive, there's not much you can do except realize that they're just being a dick about it\n\n2. The question is silly because a) there is no such thing as a standalone ubiquitous computer, it has to exist within a larger system, so in this question the system must be assumed which is dumb, and b) the answer is arbitrary and depends on how seamless you think the interoperability and integration of devices within the discussed system is, and how \"invisible\" said devices are to you. It’s a fluid and interpretative paradigm, not a set-in-stone spec. But even so, if we assume that the system is a roster of common current-day devices and smart gadgets, then smartwatches are literally a textbook example of ubiquitous computing. Not only that, but Mark Weiser himself has conceptualized wearables as being part of the Tabs category https://en.m.wikipedia.org/wiki/Ubiquitous_computing#Core_concepts . So unless your professor wants to challenge the very guy who has pioneered and defined the whole fucking ubiquitous computing concept, they are absolutely wrong lol, and they seem to not fully grasp the subject they are teaching",
        "author": "that_one_retard_2",
        "created_utc": 1745568392,
        "score": 6,
        "parent_id": "t3_1k70ncf",
        "depth": 0
      },
      {
        "id": "mouiebt",
        "body": "It's possibly debatable, but I can see both sides. CDs do indeed store data, but they typically are a write once medium. One could debate about re-writeable CDs being more in line with the definition of storage since you can add and remove files from them. I can also see CDs as being not storage because it is just a snapshot of files/data and the only way to update or change it would be to throw that out and write a new one.\n\nPersonally, I would call CDs more of an install media or backup solution but something like a flash drive, SD card, or hard drive as storage.\n\nAs for a smart watch being ubiquitous computer, I'm curious about the wording. Ubiquitous computing vs computer. I don't know if that makes any difference but the literal definition of ubiquitous is: present, appearing, or found everywhere. So is the question about ubiquitous computing or about a smart watch being a computer like what we see all over the place. Then again, I could just be reading too much into it.\n\nNo matter what, in the end it doesn't matter and this may be one of those things you'll remember as a funny little quirk of this professor decades later. I still can't believe I was told I was wrong for stating that the way to change a drive letter of a CD ROM in DOS was to edit autoexec.bat and not mscdex.exe.",
        "author": "FreakZombie",
        "created_utc": 1745524492,
        "score": 2,
        "parent_id": "t3_1k70ncf",
        "depth": 0
      },
      {
        "id": "movp8hn",
        "body": "This is all quite interesting — and yet also utterly pointless. \n\nWithout an agreed definition of “device” there is no “right” answer. \n\nAs this entire discussion proves. \n\nPick any answer here, and it’s either right or wrong depending on the definition of “device”.  Most everything here is advocating, implicitly, for one or another definition of “device” by citing properties of objects and systems. \n\nWhat matters for your grade is what the course taught you was the definition of Device. There is no other “right” answer, as the answer can only be made in reference to that definition. \n\nThat said, if you go to your teacher and engage him/her on the subject and they don’t agree to give you credit due to ambiguity, then cross them off your “intellectual mentors” candidate list.",
        "author": "AHostOfIssues",
        "created_utc": 1745538004,
        "score": 3,
        "parent_id": "t3_1k70ncf",
        "depth": 0
      },
      {
        "id": "movzyuw",
        "body": "They are not storage \"devices\", but rather storage \"media\". The device would be the optical disc drive",
        "author": "Kajitani-Eizan",
        "created_utc": 1745541635,
        "score": 3,
        "parent_id": "t3_1k70ncf",
        "depth": 0
      },
      {
        "id": "mp9c70d",
        "body": "Storage media vs storage device",
        "author": "gfranxman",
        "created_utc": 1745725531,
        "score": 3,
        "parent_id": "t3_1k70ncf",
        "depth": 0
      },
      {
        "id": "mounk3g",
        "body": "Just to chime in on the watch, many smart watches are not capable of running installable applications but rather have core functions built-in or offload the compute capabilities to a smart phone or similar device, and just relay the input and output. I’m not saying this was the reason why it marked the question as wrong, but is a possible reason why it was positioned as such.",
        "author": "LeaveMickeyOutOfThis",
        "created_utc": 1745526008,
        "score": 2,
        "parent_id": "t3_1k70ncf",
        "depth": 0
      },
      {
        "id": "mouow3f",
        "body": "“Devices” is the key word in that question. While CDs and Blu-rays are storage, they are not devices.",
        "author": "algernonramone",
        "created_utc": 1745526401,
        "score": 2,
        "parent_id": "t3_1k70ncf",
        "depth": 0
      },
      {
        "id": "mowguth",
        "body": "Seems like a silly gotcha question. A better one would have been \"which one is more device-like, a CD or the CD reader\".\n\nVery little real-world applicability on display here. It's the sort of thing that turns people away from education.",
        "author": "IanYates82",
        "created_utc": 1745547380,
        "score": 2,
        "parent_id": "t3_1k70ncf",
        "depth": 0
      },
      {
        "id": "moxqm5k",
        "body": "These are just terrible questions that serve only to quantify how well you memorize completely arbitrary things. They are effectively no different than \"True or false: the seventh word on page 71 of your textbook is ‘efficient’\".\n\nI would talk to the instructor and just explain your logic. Describe what you think a storage device is and why you feel like a CD is an example of one (same for the other question). Don’t get mad. Don’t tell them the questions are bullshit. Just approach it as trying to understand why you were wrong. If it’s clear that you understood the concept, you might get points back. Likely, nothing will change and there’s nothing you can do, but you can try.",
        "author": "deong",
        "created_utc": 1745569372,
        "score": 2,
        "parent_id": "t3_1k70ncf",
        "depth": 0
      },
      {
        "id": "moytzln",
        "body": "You need some context here. \n\nThey're likely considering the word \"device\" not \"storage\". And I imagine it was in your class reading to learn that particular distinction. \n\nOut of context \"is this correct\" questions on reddit are so often someone not understanding that questions and exams are ASKED IN CONTEXT. You can't just bring it to someone random and ask off the street. \n\nTests are testing for something. It's deeper than raw q and a. \n\nIt doesn't matter opinion. It matters what was taught. Feel free to disagree with the teacher, but you still have to prove you've learned what they explained by answering what they require. \n\nOnce you hit the job market, this fact only gets worse. A boss doesn't want you to objectively correct them. It is a super important life skill to be able to translate what a person is asking and respond the way they're requiring it. Ego aside.",
        "author": "TuberTuggerTTV",
        "created_utc": 1745587905,
        "score": 2,
        "parent_id": "t3_1k70ncf",
        "depth": 0
      },
      {
        "id": "mp0l2ci",
        "body": "They are storage media, they require a device to extract the data.",
        "author": "Stooper_Dave",
        "created_utc": 1745606459,
        "score": 2,
        "parent_id": "t3_1k70ncf",
        "depth": 0
      },
      {
        "id": "mp5l5s5",
        "body": "Late to the party here, but long time IT monkey going to chime in.\n\nA 'floppy' disc drive does not store data.  It is the medium on which data is STORED on removable media.\n\nA CD-R drive does not store data.  A ZIP drive (yes, I'm dating myself) does not store data.\n\nHDDs of any sort, USB thumb-drives, SD cards are all 'storage devices', but they still have to interface with something.\n\nYour professor is being a pedantic ass.",
        "author": "MisterStampy",
        "created_utc": 1745679342,
        "score": 2,
        "parent_id": "t3_1k70ncf",
        "depth": 0
      },
      {
        "id": "mp97t0w",
        "body": "I think it's a bullshit question, the kind that answering it 'right' doesn't reveal anything of value about your mastery, but in terms of devices, in the context of a computer, the CD-ROM drive would be the device. Not the media.\n\nFor those talking about paper as storage, the printer and scanner would be the devices that read and write to the media.",
        "author": "exedore6",
        "created_utc": 1745723673,
        "score": 2,
        "parent_id": "t3_1k70ncf",
        "depth": 0
      }
    ],
    "1k77ekx": [
      {
        "id": "movy2fc",
        "body": "Compiler courses tend to cram in too much into a single course, generally leaving you with a rudimentary but functional compiler. A course on operating systems, by comparison, will maybe teach you about memory management and scheduling and call it a day. Networking and databases are narrower topics in general.",
        "author": "MooseBoys",
        "created_utc": 1745540986,
        "score": 55,
        "parent_id": "t3_1k77ekx",
        "depth": 0
      },
      {
        "id": "mow3763",
        "body": "Compiler design covers a wide swath of all of computer science. It goes from the highly theoretical (formal languages, grammars, proofs of correctness, etc.) to the lowest level (computer architecture, CPU instruction set, registers, addressing modes, etc.). A compiler will use a variety of data structures and algorithms to perform its tasks. So a student needs to engage with all of these areas. Plus, implementing the various parts is tricky and bugs can be subtle (try to find an obscure bug in the code generator by digging through pages of assembly or machine code).",
        "author": "Turbulent_Focus_3867",
        "created_utc": 1745542743,
        "score": 19,
        "parent_id": "t3_1k77ekx",
        "depth": 0
      },
      {
        "id": "movy9ij",
        "body": "Most classes have you learning the theory of how stuff works. Your databases class will just teach you the theory behind a database and probably some SQL.\n\nA good compilers class has you creating a full compiler. And compilers are really really hard to make in general.",
        "author": "ExhaustedByStupidity",
        "created_utc": 1745541052,
        "score": 16,
        "parent_id": "t3_1k77ekx",
        "depth": 0
      },
      {
        "id": "mowaz46",
        "body": "I'm in a compiler class right now and it's the hardest class I have taken by far. I am going to have to work 50+ hours on this class alone over the next week to \\*try\\* and finish everything up. The material is challenging but it's mostly just about the volume of hands on work the implementation of even a basic compiler takes.",
        "author": "Embarrassed-Log-9628",
        "created_utc": 1745545386,
        "score": 7,
        "parent_id": "t3_1k77ekx",
        "depth": 0
      },
      {
        "id": "moxbbso",
        "body": "Ours was (long ago) not too bad, we did one for a made up computer and all it had to do was parse a few correct programs from the professor (he didn't try to bust our programs with invalid syntax or see if we covered every possible odd input).  That means our programs were probably not robust but that wasn't the point.  We still covered a lot and learned a lot, without the stress of trying to cram in everything there is.  \n\nProject heavy classes (where one project is the whole class) are problematic, esp if a team is involved.  You learn a lot from them when it goes well, but when one teammate won't do anything and another is always late to everything...  or the reverse, if you grade your mates, everyone gets an A for that part by consensus...  the nature of these classes alone puts them up a couple of notches in difficulty, and this topic is not easy.  I mean the concepts are actually kind of easy, but putting it all together, that is not, and often its the first time a student has to use everything they know and then some to pull off a working program.",
        "author": "Independent_Art_6676",
        "created_utc": 1745560236,
        "score": 3,
        "parent_id": "t3_1k77ekx",
        "depth": 0
      },
      {
        "id": "moyyjsf",
        "body": "I thought OS was generally considered the harder course. At least at Stanford, the reputation was that CS 140 (OS) was harder than CS 143 (compilers).",
        "author": "Other_Argument5112",
        "created_utc": 1745589383,
        "score": 3,
        "parent_id": "t3_1k77ekx",
        "depth": 0
      },
      {
        "id": "mpgeate",
        "body": "The compiler course is often the first course where the students need to be precise for the first time.  \nIt's no longer enough to have a vague understanding of a concept. Consider lambda-expressions.\n\nIt's one thing to use lambda-expressions in a program.\n\nIt's another thing to explain, how (in the general case)  evaluation of a  \nlambda expression creates a closure at runtime.\n\n\\- How are the free variables in the lambda expression found?  \n\\- How are they stored in the closure?  \n\\- What happens when a closure is applied?\n\nAnd then one must implement these steps.\n\nA vague understanding of lambda-expressions as \"it's just a function\"  \nis not enough to implement them.\n\n  \nThe compiler course is the gateway to semantics ;-)",
        "author": "soegaard",
        "created_utc": 1745831974,
        "score": 3,
        "parent_id": "t3_1k77ekx",
        "depth": 0
      },
      {
        "id": "mp5hf2v",
        "body": "Compilers or systems courses tend to be one of the first courses that programming language knowledge, algorithms, and data structures are applied in real world applications.",
        "author": "bluehavana",
        "created_utc": 1745678142,
        "score": 2,
        "parent_id": "t3_1k77ekx",
        "depth": 0
      },
      {
        "id": "mp9mxr8",
        "body": "I took an undergrad course in compilers but it was the same as the grad course, except using LLVM instead of implementing a register allocator, liveness analyzer, and other optimizations. (I do think that this didn’t make it any easier— I feel pretty strongly that the LLVM bindings qualify as being an entire DSL in their own right…). So I’ve been personally victimized by the dragon book. \n\nI’m convinced that it’s the influence of the dragon book. Don’t get me wrong, compilers are probably the “hardest” subfield of computer science, but I think compilers pedagogy sucks because of the dragon book in particular. It’s an incredible reference but I think using crafting interpreters would be a much better text for a first course.",
        "author": "quinn_fabray_AMA",
        "created_utc": 1745730695,
        "score": 2,
        "parent_id": "t3_1k77ekx",
        "depth": 0
      },
      {
        "id": "mp9oees",
        "body": "If I were to design such a class, I'd split it into several, starting with an overview class that results in a bare bones one, and then fleshing it out in subsequent classes, one pass at a time.",
        "author": "sol_hsa",
        "created_utc": 1745731478,
        "score": 2,
        "parent_id": "t3_1k77ekx",
        "depth": 0
      },
      {
        "id": "mpay9bd",
        "body": "I think that's mainly because writing a compiler is a microcosm of computer science. This is what [a popular compilers book (C&T)](https://www.google.co.uk/books/edition/Engineering_a_Compiler/_tgh4bgQ6PAC) says:\n\n>A good compiler makes practical use of greedy algorithms (register allocation), heuristic search techniques (list scheduling), graph algorithms (dead-code elimination), dynamic programming (instruction selection), automata theory (scanning and parsing), and fixed-point algorithms (data-flow analysis). It deals with problems such as dynamic allocation, synchronization, naming, locality, memory hierarchy management, and pipeline scheduling. **Few other software systems bring together as many complex and diverse components** (pp. 4-5 in 3ed., emphasis mine).\n\nOf course, one part of the difficulty assessment is subjective - for instance, someone who finds the maths of it difficult will struggle with AI/ML and computer graphics, even if it does not span as many diverse components as writing a compiler.",
        "author": "srsNDavis",
        "created_utc": 1745757640,
        "score": 2,
        "parent_id": "t3_1k77ekx",
        "depth": 0
      }
    ],
    "1k731bd": [
      {
        "id": "mouu7kd",
        "body": "\"CLRS\" https://en.wikipedia.org/wiki/Introduction_to_Algorithms\n\nis standard for algorithms",
        "author": "bobbsec",
        "created_utc": 1745527959,
        "score": 15,
        "parent_id": "t3_1k731bd",
        "depth": 0
      },
      {
        "id": "movjuzm",
        "body": "TAOCP, yeah",
        "author": "rattnoot",
        "created_utc": 1745536213,
        "score": 6,
        "parent_id": "t3_1k731bd",
        "depth": 0
      },
      {
        "id": "mpk5ixx",
        "body": "[A picture speaks a thousand words, so here...](https://imgur.com/a/quick-dirty-cs-roadmap-ndvs-DffABWp)\n\nOf course, there's a lot **not included here** (e.g. ubicomp, mixed reality, computer engineering, cybersecurity and forensice, and so on).\n\n**Assumed knowledge**: Discrete maths, some informal logic. (In the latter parts) Linear algebra, calculus, statistics and probability.\n\n* **CS: Distilled** OR **VSI: CS**: For when you have no idea of what CS is about.\n* [Intro to Computing](https://www.davidjoyner.net/b/wp-content/uploads/2017/03/Joyner_IntroductiontoComputing_1stEdition.pdf): Your first programming language, introduced intuitively.\n* **The Design of Everyday Things**: Human-computer interaction is arguably its own domain, but it is often covered under CS. I advocate knowing at least the basics early, because once you do, you'd remember to make things *usable* in addition to being useful.\n\nSince Intro to Computing teaches you a programming language and ends with some rudimentary data structures and algorithms, you can branch into:\n\n* **SICP**: Programming languages 101, but focused on the computational structures that make up programming languages.\n* **DPV** or [Erickson](https://jeffe.cs.illinois.edu/teaching/algorithms/): Algorithms 101. I doubt this'll be hard for you (you've seen enough maths), but for those without mathsy backgrounds, **Grokking Algorithms** is a better intro.\n\nAt this point, it might be worth picking up a second programming language - one that's relatively lower-level. Yes, I'm talking of C/C++ (**K&R** is a good C book. **Stroustrup**'s own text is a classic for C++, but check out **Overland** too - I especially like its exercises).\n\n**Once you know C/C++**, you're ready to dive into:\n\n* [R&L](https://books.google.co.uk/books?id=pyTFAAAACAAJ): An 'integrated approach' to computer systems, spanning computer architecture, operating systems and system software, and networking (all three, plus related topics such as computer organisation, have entire books dedicated to themselves if you want to go deeper). Feel free to dive deeper into any of these as interested.\n\nHowever, you can also skip C/C++ for now. **Once you're done with algorithms 101 and know some maths** (calculus, linear algebra, statistics and probability), you're (surprisingly) ready to take up two hot topics:\n\n* **Russell and Norvig**: Classic resource to learn (mostly classical) AI.\n* Not counting LLMs, the hottest kind of AI as of writing this is deep neural nets. [Weidman](https://www.oreilly.com/library/view/deep-learning-from/9781492041405/) is a good balance between hands-on (but insufficient theory) and other, more 'standard' texts like GBC which are more theoretical with not as much hands-on experience.\n* [Wong](https://www.thomaswong.net/) offers a great intro to quantum computing - though at university, you'll likely use something like [Mike and Ike](https://www.cambridge.org/highereducation/books/quantum-computation-and-quantum-information/01E10196D0A682A6AEFFEA52D53BE9AE). (Some parts of QC build upon systems knowledge though). QC also has theoretical elements (e.g. complexity and computability), which you are not very well-prepped for at the moment.\n\n... as well as a not-as-hot topic:\n\n* **Computer Graphics**: [The PBR book](https://pbr-book.org/) is my recommendation purely for its literate programming.\n\n...Or if you discover **a passion for maths**, you can follow algorithms 101 with...\n\n* **Theoretical computer science**, spanning computability theory (a.k.a. recursion theory) and complexity theory. (Maths folks usually study these in a bottom-up sequence - computability --> complexity --> algorithms - but you can learn it top-down if that's your style.) Books like DPV end with a brief overview of these topics, but the best depth is probably found in maths texts proper (e.g. the GTM series).\n\nTaking a step back: You just need HCI 101 to be able to take your first dive into this little domain that's a passion for many of us:\n\n* **Game Design**: Technically an HCI subdomain, [Swink](http://www.game-feel.com/) offers a good intro. (For any serious game *development*, though, you should ideally know C/C++ or C#, and learn an engine, like Unreal, CryEngine, Godot, or Unity. Some aspects of games are also best learnt after understanding classical AI.)",
        "author": "srsNDavis",
        "created_utc": 1745878562,
        "score": 5,
        "parent_id": "t3_1k731bd",
        "depth": 0
      },
      {
        "id": "moznuwj",
        "body": "OSTEP (Operating Systems: Three Easy Pieces) is great for understanding OS fundamentals and it covers a lot of theory around scheduling, memory, concurrency etc. The pdf is freely available [https://pages.cs.wisc.edu/\\~remzi/OSTEP/](https://pages.cs.wisc.edu/~remzi/OSTEP/)",
        "author": "zhaverzky",
        "created_utc": 1745596843,
        "score": 3,
        "parent_id": "t3_1k731bd",
        "depth": 0
      },
      {
        "id": "mp096ui",
        "body": "As a fellow science enthusiast, \"Designing Data-Intensive Applications\" by Martin Kleppmann is absolutley essential for someone with your background - it bridges the gap between physics thinking and data engineering while diving deep into CS fundamentals.",
        "author": "PM_ME_UR_ROUND_ASS",
        "created_utc": 1745602995,
        "score": 3,
        "parent_id": "t3_1k731bd",
        "depth": 0
      },
      {
        "id": "mp2eym6",
        "body": "\"The Science of Programming\" by David Gries: how to write programs that are free of bugs because they can be proven correct. An unfairly neglected book.\n\nAny books by Donald Knuth: great algorithms. Rightfully praised books.",
        "author": "david-1-1",
        "created_utc": 1745627682,
        "score": 3,
        "parent_id": "t3_1k731bd",
        "depth": 0
      },
      {
        "id": "mp7zbx5",
        "body": "Compilers: Principles, Techniques, and Tools, which is also known as the Dragon Book is a good introduction to the theory of compilers.",
        "author": "bXkrm3wh86cj",
        "created_utc": 1745706954,
        "score": 3,
        "parent_id": "t3_1k731bd",
        "depth": 0
      },
      {
        "id": "mouurmm",
        "body": "I like Skiena's Algorithm Manual book.",
        "author": "DeGamiesaiKaiSy",
        "created_utc": 1745528125,
        "score": 2,
        "parent_id": "t3_1k731bd",
        "depth": 0
      },
      {
        "id": "movntzm",
        "body": "For complexity theory specifically: Lipton's Introduction to the Theory of Computation. After that, Arora and Barak's Computational Complexity.",
        "author": "WE_THINK_IS_COOL",
        "created_utc": 1745537534,
        "score": 2,
        "parent_id": "t3_1k731bd",
        "depth": 0
      },
      {
        "id": "moxrvih",
        "body": "SICP book",
        "author": "notnull__",
        "created_utc": 1745570189,
        "score": 2,
        "parent_id": "t3_1k731bd",
        "depth": 0
      },
      {
        "id": "mp3jgd2",
        "body": "I always start with University recommendations especially the references they link in the courses they teach. That's the ideal place to begin with and should be more than sufficient.",
        "author": "bssgopi",
        "created_utc": 1745643418,
        "score": 2,
        "parent_id": "t3_1k731bd",
        "depth": 0
      },
      {
        "id": "mp7kudh",
        "body": "something else you may want to consider...  Ben Eater has an outstanding youtube channel.  his 'build a 6502 computer' and '8-bit computer' videos are excellent.  it's about hardware.  but it will give you a great understamding of how computers work.  even if you have no interest in actually building the computers yourself, you may want to watch those videos.  it will be worth your time..  best wishes.",
        "author": "GT6502",
        "created_utc": 1745702012,
        "score": 2,
        "parent_id": "t3_1k731bd",
        "depth": 0
      }
    ],
    "1k64jxe": [
      {
        "id": "mon2tet",
        "body": "Once I needed to implement a tool that would pull chat logs meeting certain criteria through an API (e.g. \"involves user A and user C, but not user B\").  I wrote my own context free grammar for the search language, then parsed the search criteria with a python wrapper for ANTLR.\n\n\nEnded up with a really slick CLI, but it brought back memories of my PL design class.\n\n\nPretty sure I needed to get a topo sort for a graph once, too, but I can't remember the circumstances exactly.",
        "author": "apnorton",
        "created_utc": 1745428704,
        "score": 72,
        "parent_id": "t3_1k64jxe",
        "depth": 0
      },
      {
        "id": "mon7sl3",
        "body": "I'm learning so much of this stuff in undergrad but I'm scared I'm going to forget all of it once I graduate",
        "author": "InsufferableBah",
        "created_utc": 1745430104,
        "score": 38,
        "parent_id": "t3_1k64jxe",
        "depth": 0
      },
      {
        "id": "monrrlp",
        "body": "I don't think this is quite the same, but I've made code dramatically more efficient by decreasing cache misses.\n\nA big example is replacing a linked list or tree-based data structure with a flat array or sorted array. Sure, in theory the pointer-based data structure is faster especially for very large values of n, but in practice we were using it for a few hundred values, and searching a flat array of a few hundred values is way more cache-efficient than following a few hundred pointers. Of course, it's important to profile and determine if there are sizes of n where it becomes inefficient and decide if we need something smarter then.\n\nThat sort of thing catches a lot of CS grads who know their algorithms really well but weren't paying as much attention in their computer architecture class.\n\nAs far as algorithm / data structure wins, my favorite by far is using a Bloom filter. A great example is an API that needs to search a database for a record and it usually returns no results. The bloom filter lets you identify most of the cases where the record is not present almost instantly. Only a small fraction of the time it needs to actually check the database.",
        "author": "dmazzoni",
        "created_utc": 1745435882,
        "score": 28,
        "parent_id": "t3_1k64jxe",
        "depth": 0
      },
      {
        "id": "mon7o5h",
        "body": "Toposort on a schedule graph for some operations research related use case. I had the idea of using a max-flow / min-cut variation for that same use case as well.\n\nClient was a defense consulting contractor",
        "author": "fntdrmx",
        "created_utc": 1745430070,
        "score": 23,
        "parent_id": "t3_1k64jxe",
        "depth": 0
      },
      {
        "id": "mon9lex",
        "body": "Understood RB-tree internals and managed to identify and fix an obscure bug in a library that resulted from `std::set` being used improperly, because it used a custom comparator that wasn't a strict weak ordering.",
        "author": "SoldRIP",
        "created_utc": 1745430609,
        "score": 10,
        "parent_id": "t3_1k64jxe",
        "depth": 0
      },
      {
        "id": "mooczaw",
        "body": "Used interval trees from a CS theory class to speed up log parsing across overlapping time windows. Went from brute-force scans to sub-second queries on gigabyte logs. Never thought that lecture would actually pay off but here we are.",
        "author": "Shanus_Zeeshu",
        "created_utc": 1745442030,
        "score": 8,
        "parent_id": "t3_1k64jxe",
        "depth": 0
      },
      {
        "id": "mop0srj",
        "body": "I’ve implemented the Floyd-Warshall algorithm to calculate transitive closures.",
        "author": "Abigail-ii",
        "created_utc": 1745449659,
        "score": 7,
        "parent_id": "t3_1k64jxe",
        "depth": 0
      },
      {
        "id": "mooq6ps",
        "body": "Bloom filters and other sketching algos are insanely effective when results don’t have to be perfect but just good enough. I’m talking about several orders of magnitude improvements.",
        "author": "abial2000",
        "created_utc": 1745446123,
        "score": 8,
        "parent_id": "t3_1k64jxe",
        "depth": 0
      },
      {
        "id": "mot78x0",
        "body": "In 40 years of software engineering, I'm not sure I've ever used an algorithm I learned in school directly. When I was in school we had a different set of theory, of course. But I did learn enough about DS&A to recognize bad algorithms, to make smart choices between existing tools, and to engineer my own optimized solutions to real problems. \n\nI once overhauled a large state tracker that had a custom sparse map implementation underneath it. It was a complicated refactoring that took several weeks to get right, half of which was just understanding and documenting the existing code. \n\nI found a comment on the original Jira from 8 years earlier: \"Why not use a hashmap for the underlying storage?\". And the answer, \"I tried that and it was 40% slower.\" Lol\n\nSo, after my overhaul, the new algorithm was 10x faster, but someone still asked, correctly, \"Why not a hashmap?\" Good question, I thought. Compilers are much faster, libraries have improved. Why not a hashmap? It was only 5 lines of code to change to try it. So I did.\n\nIt was 40% slower.",
        "author": "phord",
        "created_utc": 1745510998,
        "score": 3,
        "parent_id": "t3_1k64jxe",
        "depth": 0
      },
      {
        "id": "monz1a6",
        "body": "My contribution isn’t necessarily working with data like the other examples but I used a tree structure to recursively generate and store logical expressions in Reverse Polish Notation. We were having trouble figuring out how to keep track of parentheses in the expression and realized that was the easiest way since they’re built into the string. I then recursively generated the blocks on the front end with a tree traversal algorithm and rolled it up after when sending the string to the backend.",
        "author": "crappyoats",
        "created_utc": 1745437997,
        "score": 2,
        "parent_id": "t3_1k64jxe",
        "depth": 0
      }
    ],
    "1k4wka0": [
      {
        "id": "modfsbz",
        "body": "Edit: you know what? Fuck it. The replies have convinced me that maybe software engineers really are engineers. What the fuck do I know.\n\nI wouldn't consider software engineering an actual subfield of engineering, but merely the practical aspect of programming. It doesn't seem like you can study engineering and then go on to specialize in civic, mechanical, electrical, or *software* engineering. Its not engineering in the same sense of the word, in the same way that a train conductor isn't the same kind of conductor as a classical music conductor, nor the same sort of thing as an electrical conductor.\n\nInstead, I think people are using the term to mean \"technical designer\" or something like that, which is far from the actual meaning of an engineer except for simplified, toy ideas of what makes an engineer.",
        "author": "c3534l",
        "created_utc": 1745292359,
        "score": 69,
        "parent_id": "t3_1k4wka0",
        "depth": 0
      },
      {
        "id": "modhaqs",
        "body": "I don’t have the brain power to formulate a well thought out response to this but engineering and statistics def overlap",
        "author": "FantasticEmu",
        "created_utc": 1745292986,
        "score": 56,
        "parent_id": "t3_1k4wka0",
        "depth": 0
      },
      {
        "id": "modjhqz",
        "body": "This is (in my personal opinion) correct at some extent !\n\nTo me Software engineering is a mixture between CS, Business and engineering.\n\nCS is just theoretical: algorithms, data structures, mathematics, proofs, computer logic, etc....\n\nEngineering: Technical aspect of a project, building, testing, designing, etc...\n\nBusiness: Management, assurance quality, business communication, client interaction, meetings with clients, etc...\n\nSoftware Engineering: Which design pattern(algorithms) will you use to build a payment system for a client? How will you deliver the system? What kind of technologies will you use? How will you address your clients needs and concerns? which framework will you use to interact with stakeholders(Scrum???)? What kind of NoSQL database will you use(graph base? doc base? key base? column base? why even would you consider NoSQL over SQL? Are you going to test your software?\n\nSoftware engineers are using their knowledge from CS, Business and engineering to solve problems.\n\nData science is CS + Statistics.",
        "author": "New_Bat_9086",
        "created_utc": 1745293883,
        "score": 9,
        "parent_id": "t3_1k4wka0",
        "depth": 0
      },
      {
        "id": "modkk3t",
        "body": "Engineers get pissy if you bundle them with software engineers",
        "author": "N0Zzel",
        "created_utc": 1745294332,
        "score": 10,
        "parent_id": "t3_1k4wka0",
        "depth": 0
      },
      {
        "id": "moe1mp7",
        "body": "Since no one else is saying it I will: it's not a Venn diagram. A Venn diagram has n shapes that divide the plane into 2^n regions so that each of the logically possible combinations are represented by some region. Here for instance, the overlap between statistics and engineering is not represented, though logically possible (and surely there is some real world overlap...)",
        "author": "ccppurcell",
        "created_utc": 1745302969,
        "score": 6,
        "parent_id": "t3_1k4wka0",
        "depth": 0
      },
      {
        "id": "modliox",
        "body": "Replace \"engineering\" with \"sand castle building\"",
        "author": "OddChoirboy",
        "created_utc": 1745294753,
        "score": 3,
        "parent_id": "t3_1k4wka0",
        "depth": 0
      },
      {
        "id": "modzesj",
        "body": "Ok engineering encompasses all of computer engineering and both share a domain with statistics but don’t encompass it",
        "author": "FantasticEmu",
        "created_utc": 1745301659,
        "score": 3,
        "parent_id": "t3_1k4wka0",
        "depth": 0
      },
      {
        "id": "mofqkct",
        "body": "Euler diagram not a venn diagram",
        "author": "diabetic-shaggy",
        "created_utc": 1745332395,
        "score": 3,
        "parent_id": "t3_1k4wka0",
        "depth": 0
      },
      {
        "id": "mof0ant",
        "body": "Mathematics intersection for theory",
        "author": "davididp",
        "created_utc": 1745323126,
        "score": 2,
        "parent_id": "t3_1k4wka0",
        "depth": 0
      }
    ],
    "1k4usm2": [
      {
        "id": "mod2b7d",
        "body": "We actually tried other architectures.  Cf. Harvard vs. Von Neumann architectures.  I’ve seen simulations of even crazier stuff, like data and code mixed together.  We tried ternary machines, and analog machines.  Von Neumann won for a reason.",
        "author": "_Barbaric_yawp",
        "created_utc": 1745287390,
        "score": 131,
        "parent_id": "t3_1k4usm2",
        "depth": 0
      },
      {
        "id": "mod4gce",
        "body": "Computing models aren't a type of thing like idk, locomotion. If we do away with cars for example, sure bus and street cars might proliferate, and life adapts. Turing machines though are not a specific implementation like a bus or street car. Turing machines are a theoretical entity; a thought experiment about how computation might take place, with the added benefit of mathematical rigor such that you can prove using this model, that certain questions can or cannot be answered/computed.\n\nVon Neumann and Harvard, on the other hand, *are* physical implementations. They both have benefits and tradeoffs, which is why you see a mix of them. Intel x86 is Von Neumann, and ARM and ATmega (as well as many other microcontrollers) are Harvard. I'm not really sure what to tell you, these are still tape machines, except one separates data and instruction and one has them all on one tape. Like no matter how you cut it, things reduce down to tape machines, and whether you want to split memory or mix them... It's like asking \"hey, we're fixating too hard on this True and False. What if we didn't? What if there's a third state?? I know that Boole guy was crazy smart and all, but what if??\". Like sure, I cannot prove to you, maybe ever, that there isn't a 3rd undiscovered logic state, but we're not running into any limitations evaluating logic and reasoning with just the 2 states. Similarly for computing, our limitations aren't architectural (at least not this foundational); they're with the physics of memory, memory bandwidth and latency, engineering of materials, design of communication bus, compiler optimizations, data structures, etc. There's so many other limitations, none of which are really because we took Turing's model literally.\n\nLooking at cells for example, they do the exact same thing as tape machines. Proteins traverse the DNA to spit out proteins that assemble together and interact, just like how a CPU traverses the instruction tape to spit out numbers, daemons, services, that interact. If there's any other model of execution that doesn't involve linear input and output like a function, I'm sure life would've found it with the >4b years it's had to work with.",
        "author": "finn-the-rabbit",
        "created_utc": 1745288113,
        "score": 49,
        "parent_id": "t3_1k4usm2",
        "depth": 0
      },
      {
        "id": "modc241",
        "body": "Veritassium did a video on how analogue computers are making a comeback for more organic calculations and signal processing",
        "author": "BobbyThrowaway6969",
        "created_utc": 1745290868,
        "score": 11,
        "parent_id": "t3_1k4usm2",
        "depth": 0
      },
      {
        "id": "mofvg5b",
        "body": "This is not a stupid question at all. In fact research is going into specialized hardware that can be much more efficient for specific tasks; and better with non exact computations and AI. For instance:\n\n[Synaptic and neural behaviours in a standard silicon transistor](https://www.nature.com/articles/s41586-025-08742-4)\n\n[An optical Fourier transform coprocessor with direct phase determination](https://www.nature.com/articles/s41598-017-13733-1)\n\n[D-Wave annealing quantum computer](https://www.dwavequantum.com/)\n\nOne can only imagine if we started sooner.",
        "author": "mikaball",
        "created_utc": 1745333854,
        "score": 9,
        "parent_id": "t3_1k4usm2",
        "depth": 0
      },
      {
        "id": "mod3u75",
        "body": "Quantum, wetware and neuromorphic computing are still in their fledgling stages. Von Neumann just came first using the tools of the time and made the most sense and was thus built upon further.",
        "author": "RemyVonLion",
        "created_utc": 1745287909,
        "score": 6,
        "parent_id": "t3_1k4usm2",
        "depth": 0
      },
      {
        "id": "moeq3r2",
        "body": "I love this kind of question! Science advances when people ask “what are we missing?”\n\nWe need to be careful about adopting the “lone towering hero” mode of explaining the history of any science, however. Both Turing and von Neumann were members of large teams working on urgent (to put it mildly) problems. If they missed something personally, their colleagues almost certainly didn’t.\n\nAnd, the binary paradigm has proven useful. There’s no sign, other than quantum computing, that the binary paradigm is breaking down. There are plenty of places where that paradigm is pushed to its limits. Old school modems had multiple bits per symbol. Some memory and processor schemes have non saturating logic and forward error correction. (cf. [The Structure of Scientific Revolutions](https://search.worldcat.org/title/756577696) by Thomas Kuhn.)\n\nGenerative AI models are built on mass quantities of probability numbers (0-1) represented with fixed-point binary numbers. That area might be ripe for a rethink, just because there’s so much of that stuff.",
        "author": "Aggressive_Ad_5454",
        "created_utc": 1745318341,
        "score": 7,
        "parent_id": "t3_1k4usm2",
        "depth": 0
      },
      {
        "id": "mogufuw",
        "body": "Yoooo I hate your edit lol. This is a really cool thought provoking question and great content for this sub don’t be so hard on yourself hahaha.",
        "author": "Semi_Chenga",
        "created_utc": 1745343994,
        "score": 6,
        "parent_id": "t3_1k4usm2",
        "depth": 0
      },
      {
        "id": "mod1qsp",
        "body": "Yes, the reason why our current AI-like software needs specialized AI hardware is because existing CPUs (or more specifically the cores of existing CPUs) are Von Neumann style.",
        "author": "CanadianBuddha",
        "created_utc": 1745287194,
        "score": 5,
        "parent_id": "t3_1k4usm2",
        "depth": 0
      },
      {
        "id": "modp784",
        "body": "you might want to take a look at analog computing, optical computing and neuromorphic computing.",
        "author": "okaryotcanli",
        "created_utc": 1745296405,
        "score": 3,
        "parent_id": "t3_1k4usm2",
        "depth": 0
      },
      {
        "id": "mog86fe",
        "body": "I haven’t read all the comments so it may be mentioned but I’ve had my interest piqued by neuromorphic computing lately.",
        "author": "Dielawnv1",
        "created_utc": 1745337565,
        "score": 2,
        "parent_id": "t3_1k4usm2",
        "depth": 0
      },
      {
        "id": "mohtbvo",
        "body": "Not a stupid question.  A rather interesting one with a known answer.",
        "author": "Kumlekar",
        "created_utc": 1745354276,
        "score": 2,
        "parent_id": "t3_1k4usm2",
        "depth": 0
      }
    ],
    "1k4i4az": [
      {
        "id": "moak1jf",
        "body": "AI attracts a lot of the same types of people that are into ufos. If you want to avoid that kind of thing you’ll have to stick to more of the technical subs",
        "author": "ArtificialTalent",
        "created_utc": 1745258484,
        "score": 51,
        "parent_id": "t3_1k4i4az",
        "depth": 0
      },
      {
        "id": "moabosm",
        "body": "The usual law of \"AI\" applies; replace it with logistic regression and see if it still makes sense.\n\n\"Logistic Regression can help make sense of complex data\" Yes\n\n\"Logistic Regression can be game changing for some fields\" Yes\n\n\"Logistic Regression is sentient\" hard doubt",
        "author": "JJJSchmidt_etAl",
        "created_utc": 1745256096,
        "score": 46,
        "parent_id": "t3_1k4i4az",
        "depth": 0
      },
      {
        "id": "moa5kgg",
        "body": "No, they don't.",
        "author": "Rude-Pangolin8823",
        "created_utc": 1745254334,
        "score": 24,
        "parent_id": "t3_1k4i4az",
        "depth": 0
      },
      {
        "id": "moa50ta",
        "body": "There are hundreds of comments on this thread gaslighting OP into thinking LLMs are sentient and we don’t understand how LLMs are made or work (when literally there are thousands of LLM models made by companies and individual people)? Feel free to check it out lmao. \n\nYeah, we don’t fully understand how the human brain works. That’s true. But what we do know is that it’s not “just math.” It’s a deeply complex biological system shaped by millions of years of evolution. It operates through electrochemical signaling, plasticity, embodied experience, and constant environmental feedback. It feels pain, forms memories, has sleep cycles, hormonal states, and emergent self-awareness grounded in a physical, dying body. None of that is happening inside an LLM.\n\nSure, you technically can’t “rule out” that an LLM is sentient. But that’s not an argument. You can’t rule out that your toaster is sentient either, but that doesn’t mean we have to entertain the idea seriously. Once you understand how LLMs actually work, how they tokenize inputs, generate statistical predictions across layers of linear algebra and attention mechanisms, and output the most likely next word based on pattern matching, it becomes painfully obvious that this is simulation, not experience.\n\nThe fact that this even needs to be explained in a OpenAI subreddit is embarrassing. There’s a difference between intellectual humility and just refusing to learn how the systems you’re talking about actually function. I’m probably gonna stay off that subreddit for a while since it seems to have become politically charged and have a lack of knowledge about how these systems work.",
        "author": "DerpDerper909",
        "created_utc": 1745254174,
        "score": 25,
        "parent_id": "t3_1k4i4az",
        "depth": 0
      },
      {
        "id": "moaf9gp",
        "body": "I don’t think any LLM is anywhere close to sentient.\n\nI think transformers are an overrated architecture (O(n²) … gross).\n\nI think the kinds of arguments you link to are on a spectrum from ignorant to pathetic.\n\n_But_! The fact that something uses transformers does not, by itself, prove it’s not sentient. There’s a lot we don’t know about sentience. We have no reason to act categorically certain that it can or can’t be reached by this particular kind of function. There are reasonable conjectures to be made. But the idea that if it’s transformers then it must not be sentient – I don’t think that’s a convincing argument on its own. Even though, as stated, I think transformers are annoying and that LLMs are not sentient.",
        "author": "mulch_v_bark",
        "created_utc": 1745257122,
        "score": 22,
        "parent_id": "t3_1k4i4az",
        "depth": 0
      },
      {
        "id": "moawg3p",
        "body": "I have seen, on more than one occasion, people argue on that subreddit about how machine learning isn’t a subset of AI. Your PhD and Master’s be damned. LLMs definitely must be sentient because r/openAI said so. \n\nAlso, the typical braindead argument of “my consciousness is just a mathematical equation as well” makes me want to use some really choice words that will get me banned. As someone else said on here, this topic attracts the UFO crowd. \n\nAnd the worst part is that I don’t even disagree, I really do think that a proto-consciousness perhaps can manifest in more complex models with certain qualifications. But it is like banging your head against the wall when it comes to the general lack of intelligence surrounding the merits or demerits of such an argument on that subreddit. They’ll probably think a textbook that contains weights and auto-diff calculations is conscious.",
        "author": "Asdzxjj",
        "created_utc": 1745262136,
        "score": 19,
        "parent_id": "t3_1k4i4az",
        "depth": 0
      },
      {
        "id": "moazcv7",
        "body": "Remind me, what's the definition of sentience that's reached a consensus? Just because we've limited models to extract single tokens, we have no idea what complex semantic relationships are being utilized within the model. There's a whole field of an AI built around this idea. You could have a box that contains a human. You instruct the human to output a word depending on the words you input into the box. Unless you understand what's in the box, you can't possibly claim that sentience isn't involved. With the size of the vector spaces involved, it's hard to know what emergent qualities could arise. Not claiming llms are sentient, but I'm not going to rule out the possibility that transformers could get us there. I don't understand sentience or the limits of the emergence well enough to do so. I don't think anyone does at the moment, but that's my opinion.",
        "author": "Lynx2447",
        "created_utc": 1745263002,
        "score": 8,
        "parent_id": "t3_1k4i4az",
        "depth": 0
      },
      {
        "id": "mobp7mc",
        "body": ">Whether a computer can think is no more interesting than whether a submarine can swim. - Edsger W. Dijkstra\n\nCzechs use the same word for a human swimming and a submarine cruising. In English we use different words. \n\nYou probably mean sapient not sentient. But, these are just words. \n\nIn fifty years, the Anglosphere may say machines are sapient while the Sinosphere rejects machine sapience. \n\nBut we're arguing semantics all the way down.",
        "author": "Beautiful-Parsley-24",
        "created_utc": 1745270716,
        "score": 3,
        "parent_id": "t3_1k4i4az",
        "depth": 0
      },
      {
        "id": "mom4aid",
        "body": "Wild how many people still think other people are sentient, do they even know how brains work?",
        "author": "Single_Blueberry",
        "created_utc": 1745418654,
        "score": 3,
        "parent_id": "t3_1k4i4az",
        "depth": 0
      }
    ],
    "1k4njwn": [
      {
        "id": "moeyizy",
        "body": "Thanks for your post! Here's your code formatted for old Reddit on desktop:\n\n\n    const express = require(\"express\");\n    const axios = require(\"axios\");\n    const sqlite3 = require(\"sqlite3\").verbose();\n    const crypto = require(\"crypto\");\n    const jwt = require(\"jsonwebtoken\");\n    const jwksClient = require(\"jwks-rsa\");\n    \n    const app = express();\n    const db = new sqlite3.Database(\":memory:\");\n    \n    // Initialize database\n    db.serialize(() => {\n      db.run(\n        \"CREATE TABLE users (id INTEGER PRIMARY KEY AUTOINCREMENT, name TEXT, email TEXT)\"\n      );\n      db.run(\n        \"CREATE TABLE federated_credentials (user_id INTEGER, provider TEXT, subject TEXT, PRIMARY KEY (provider, subject))\"\n      );\n    });\n    \n    // Configuration\n    const CLIENT_ID = process.env.GOOGLE_CLIENT_ID;\n    const CLIENT_SECRET = process.env.GOOGLE_CLIENT_SECRET;\n    const REDIRECT_URI = \"https://example.com/oauth2/callback\";\n    const SCOPE = \"openid profile email\";\n    \n    // JWKS client to fetch Google's public keys\n    const jwks = jwksClient({\n      jwksUri: \"https://www.googleapis.com/oauth2/v3/certs\",\n    });\n    \n    // Function to verify JWT\n    async function verifyIdToken(idToken) {\n      return new Promise((resolve, reject) => {\n        jwt.verify(\n          idToken,\n          (header, callback) => {\n            jwks.getSigningKey(header.kid, (err, key) => {\n              callback(null, key.getPublicKey());\n            });\n          },\n          {\n            audience: CLIENT_ID,\n            issuer: \"https://accounts.google.com\",\n          },\n          (err, decoded) => {\n            if (err) return reject(err);\n            resolve(decoded);\n          }\n        );\n      });\n    }\n    \n    // Generate a random state for CSRF protection\n    app.get(\"/login\", (req, res) => {\n      const state = crypto.randomBytes(16).toString(\"hex\");\n      req.session.state = state; // Store state in session\n      const authUrl = `https://accounts.google.com/o/oauth2/auth?client_id=${CLIENT_ID}&redirect_uri=${REDIRECT_URI}&scope=${SCOPE}&response_type=code&state=${state}`;\n      res.redirect(authUrl);\n    });\n    \n    // OAuth callback\n    app.get(\"/oauth2/callback\", async (req, res) => {\n      const { code, state } = req.query;\n    \n      // Verify state to prevent CSRF\n      if (state !== req.session.state) {\n        return res.status(403).send(\"Invalid state parameter\");\n      }\n    \n      try {\n        // Exchange code for tokens\n        const tokenResponse = await axios.post(\n          \"https://oauth2.googleapis.com/token\",\n          {\n            code,\n            client_id: CLIENT_ID,\n            client_secret: CLIENT_SECRET,\n            redirect_uri: REDIRECT_URI,\n            grant_type: \"authorization_code\",\n          }\n        );\n    \n        const { id_token } = tokenResponse.data;\n    \n        // Verify ID token (JWT)\n        const decoded = await verifyIdToken(id_token);\n        const { sub: subject, name, email } = decoded;\n    \n        // Check if user exists in federated_credentials\n        db.get(\n          \"SELECT * FROM federated_credentials WHERE provider = ? AND subject = ?\",\n          [\"https://accounts.google.com\", subject],\n          (err, cred) => {\n            if (err) return res.status(500).send(\"Database error\");\n    \n            if (!cred) {\n              // New user: create account\n              db.run(\n                \"INSERT INTO users (name, email) VALUES (?, ?)\",\n                [name, email],\n                function (err) {\n                  if (err) return res.status(500).send(\"Database error\");\n    \n                  const userId = this.lastID;\n                  db.run(\n                    \"INSERT INTO federated_credentials (user_id, provider, subject) VALUES (?, ?, ?)\",\n                    [userId, \"https://accounts.google.com\", subject],\n                    (err) => {\n                      if (err) return res.status(500).send(\"Database error\");\n                      res.send(`Logged in as ${name} (${email})`);\n                    }\n                  );\n                }\n              );\n            } else {\n              // Existing user: fetch and log in\n              db.get(\n                \"SELECT * FROM users WHERE id = ?\",\n                [cred.user_id],\n                (err, user) => {\n                  if (err || !user) return res.status(500).send(\"Database error\");\n                  res.send(`Logged in as ${user.name} (${user.email})`);\n                }\n              );\n            }\n          }\n        );\n      } catch (error) {\n        res.status(500).send(\"OAuth or JWT verification error\");\n      }\n    });\n    \n    app.listen(3000, () => console.log(\"Server running on port 3000\"));",
        "author": "nonreligious2",
        "created_utc": 1745322374,
        "score": 2,
        "parent_id": "t3_1k4njwn",
        "depth": 0
      }
    ],
    "1k4fuc9": [
      {
        "id": "mo9oa04",
        "body": "In this case, you can conclude that the graph is not strongly connected. Depending on your goal, you might want to continue searching starting at a random unvisited node or you might want to exit. ",
        "author": "TheologyFan",
        "created_utc": 1745248327,
        "score": 15,
        "parent_id": "t3_1k4fuc9",
        "depth": 0
      },
      {
        "id": "mo9oe3l",
        "body": "What do you mean by should? DFS and BFS are just tools to use to compute other stuff. What are you actually trying to compute?",
        "author": "indjev99",
        "created_utc": 1745248362,
        "score": 5,
        "parent_id": "t3_1k4fuc9",
        "depth": 0
      },
      {
        "id": "mo9ou03",
        "body": "You can reach F from C and C from B. Maybe they will be added to queue, but not processed if they are already visited, not sure.",
        "author": "kiner_shah",
        "created_utc": 1745248495,
        "score": 2,
        "parent_id": "t3_1k4fuc9",
        "depth": 0
      },
      {
        "id": "modlhnw",
        "body": "Based on just the information provided, it looks like you already solved this question. There’s no additional technique to apply if you reach a dead end, unless the goal is to find a path that connects the most vertices or something specific. That doesn’t seem to be the case here though. This graph is not strongly connected so BFS/ DFS will only get so far regardless of the chosen source node. Pretty sure there’s no one answer to this question. Based on your chosen source node, they’ll probably just verify your paths make sense using BFS/ DFS.",
        "author": "Gon34EV",
        "created_utc": 1745294740,
        "score": 2,
        "parent_id": "t3_1k4fuc9",
        "depth": 0
      }
    ],
    "1k4f7le": [
      {
        "id": "mo9l84a",
        "body": "Python. It has more use cases and you will find more available resources and libraries to do more projects.\n\nYou can teach static typing after they wrap their heads around basic loops and stuff. You can even teach them to run mypy/pyright since it is only one instruction and easy to use",
        "author": "Sagarret",
        "created_utc": 1745247403,
        "score": 19,
        "parent_id": "t3_1k4f7le",
        "depth": 0
      },
      {
        "id": "mo9o8hd",
        "body": "False. Python is *strongly typed*, and always has been (unlike JavaScript, which is weakly typed). This is not the same thing as *statically typed*, which is probably what you meant. But Python *is* statically typed (and also dynamically typed. This is not a contradiction.) If you want to check the types statically, you can, just run a static type checker like MyPy or PyRight, and use the type annotation syntax built into the language and standard library. Python is overall an excellent teaching language, much better than JavaScript or Swift, but other languages might be better in specific areas.\n\nI can only recommend Swift for iOS development; it's Apple-specific. (You have a lot more options on a Mac.) You can do a lot better than Swift.\n\nIf you primarily want to teach static typing theory, Haskell or Idris are better choices. They're even more strongly typed than Python, and their typing systems are more consistent and regular. Haskell is more widely used. Idris is similar, but has a more powerful dependent type system. You can use type \"holes\" in Idris to get the compiler to help complete the program.\n\nIf you want to teach a strongly and statically typed language that's more generally useful in industry (besides Python), Rust could be a good choice. I'd recommend it over Swift.",
        "author": "Gnaxe",
        "created_utc": 1745248314,
        "score": 10,
        "parent_id": "t3_1k4f7le",
        "depth": 0
      },
      {
        "id": "mo9qjqq",
        "body": "What's your goal and what's your intended audience?\n\nIf you're just teaching students who might be interested in programming but aren't sure, or who just want to pick up a few coding skills but not become software engineers, it's hard to beat Python. It's easy to get students motivated and interested when the bar for doing things is so low. \n\nThere's plenty of time for learning about lower level stuff after the people who are just looking for an intro have weeded themselves out.",
        "author": "qwaai",
        "created_utc": 1745249011,
        "score": 5,
        "parent_id": "t3_1k4f7le",
        "depth": 0
      },
      {
        "id": "mob64nq",
        "body": "That's a tough choice to make. Swift is a great language, and it's designed to work across multiple platforms. However, iOS development still requires SwiftUI or UIKit, which only work on macOS. You can definitely build apps for Mac users, though. (There might be ways to create iOS apps on Windows, but from what I know, it's not very straightforward.)\n\nPython is a great language too, but I understand the concerns about it being dynamically typed. If you go with Python, you could ask your students to always use type hints and annotations, that would help with some of those issues.\n\nChoosing a first language is always tricky. Go could also be a good option because it's a relatively simple language. Even C could work, though things like memory management and pointers can be tough for beginners.\n\nGood luck deciding.\n\nPersonally, I think Swift could be a great choice, it’s clean, modern, and offers a fresh perspective compared to Python. It’s great that you’re exploring creative options.\n\nAs a side note I have courses on [Swift/SwiftUI](https://www.udemy.com/course/deep-dive-ios-16-swiftui-programming/?couponCode=MAR2025-SWIFTUI) and [Python](https://www.udemy.com/course/python-foundations-for-data-science-from-zero-to-data-analy/?couponCode=SPRINGSALE-PYTHON) and I love both. Still quite hard to decide which would be better for a first language. Technically speaking it doesn't really matter. The programming principles should be more or less the same (for instance understanding conditions, loops, functions, reference vs value types, etc are universal ideas).",
        "author": "Ron-Erez",
        "created_utc": 1745265015,
        "score": 3,
        "parent_id": "t3_1k4f7le",
        "depth": 0
      },
      {
        "id": "mobm0bx",
        "body": "100% Python.\n\nPython does have libraries like TKinter that you can use to make programs with gui. It has a library for almost any use case you can think of, although it won't be the most efficient language to do so everytime.\n\nHonestly Swift is a really niche language with a lot less use cases than a mainstream language like python, c++ or java. Considering that these students just want to be introduced to programming principles and not go into frontend engineering, one of the c-family languages will be a better option over something like Swift.",
        "author": "EthanSpot",
        "created_utc": 1745269724,
        "score": 2,
        "parent_id": "t3_1k4f7le",
        "depth": 0
      }
    ],
    "1k411lr": [
      {
        "id": "mo6l22i",
        "body": "Well… tons. To list off the common ones at a *very* high level:\n\nCPU clock speed\n\nCPU architecture\n\nCPU core count\n\nRAM size\n\nRAM speed\n\nRAM latency\n\nGPU (in general I guess this is a whole different rabbit hole)\n\nDisk capacity/usage\n\nDisk speed\n\nNetwork speed\n\nNetwork latency\n\nISP issues\n\nDropped network packets\n\nWireless band congestion\n\nUtilization of any/all of the aforementioned items\n\nSoftware limiters (i.e battery saving mode)\n\nAny one of these are their own rabbit hole that each could have many of their own reasons for being “slow”. It really depends on exactly what’s being slow and why",
        "author": "warhammercasey",
        "created_utc": 1745197287,
        "score": 54,
        "parent_id": "t3_1k411lr",
        "depth": 0
      },
      {
        "id": "mo6q3n5",
        "body": "Your question is kinda like asking a mechanic on Reddit, “Why is my car broken?” There are so many factors that it’s very hard to tell.",
        "author": "sept27",
        "created_utc": 1745199100,
        "score": 19,
        "parent_id": "t3_1k411lr",
        "depth": 0
      },
      {
        "id": "mo6jhwd",
        "body": "You will need to specify more detail on what it is your doing, and what slowdowns you see. There are too many hardware components and software layers that can possibly contribute to performance when given no context.",
        "author": "TheBlasterMaster",
        "created_utc": 1745196746,
        "score": 7,
        "parent_id": "t3_1k411lr",
        "depth": 0
      },
      {
        "id": "mo7efqk",
        "body": "A major factor is I/O. Your main disk can be doing a lot of reading and writing. Did you notice this 2 weeks ago? April 8 was Patch Tuesday, and March 12 is the next Patch Tuesday. This is where Windows is downloading updates from Microsoft. \n\nIf your main disk is running at 100%, your system can feel incredibly slow because the CPU is having to wait for data to load from disk. Windows actually is set to load a lot of stuff from disk on boot. My own PC slows down for maybe 3-5 minutes during this time. Even if I load from my secondary disk, a program can call many .DLL files that are in C:\\\\Windows\\\\System32\n\nIt's not only Microsoft, but many other companies update on Patch Tuesday. I often get the updates on Wednesdays. \n\nAs for CPUs themselves, there's a concept called IPC, Instructions per Clock. The IPC for a Ryzen 5800X3D at 3.8 GHz is much higher vs a 3.8 GHz Core i7-2600k. There's a lot more newer technology in the 5800X3D.",
        "author": "fuzzynyanko",
        "created_utc": 1745208594,
        "score": 5,
        "parent_id": "t3_1k411lr",
        "depth": 0
      },
      {
        "id": "mo6kfz8",
        "body": "How's your internet speed? That, and the speed of the service your computer \\*may\\* be talking to, are one of hundreds of factors.",
        "author": "VoiceOfSoftware",
        "created_utc": 1745197071,
        "score": 3,
        "parent_id": "t3_1k411lr",
        "depth": 0
      },
      {
        "id": "mo72pi2",
        "body": "From a high level it’s because the vast majority of the time the software/firmware is written like literal ass.",
        "author": "tonyshark116",
        "created_utc": 1745203666,
        "score": 3,
        "parent_id": "t3_1k411lr",
        "depth": 0
      },
      {
        "id": "mo6ke0m",
        "body": "Processing speed is not just about clock frequency, like you mentioned. \n\nUnderstanding the interaction between hardware (CPU, memory, disk), software (algorithms, system calls), and OS (scheduling, process management) is important when trying to figure out why certain request take longer than others.",
        "author": "Proficient_Novice",
        "created_utc": 1745197053,
        "score": 2,
        "parent_id": "t3_1k411lr",
        "depth": 0
      }
    ],
    "1k3ep22": [
      {
        "id": "mo1ngdt",
        "body": "I think Computer Networking: A Top Down Approach by Jim Kurose is pretty good. I used it in university but I think a smart highschooler could handle it. The fact that it’s “top-down” makes it a little easier imo, starting from the application level is less daunting than starting from the physical level and working up",
        "author": "pioverpie",
        "created_utc": 1745125258,
        "score": 8,
        "parent_id": "t3_1k3ep22",
        "depth": 0
      }
    ],
    "1k23e4m": [
      {
        "id": "mnr14v0",
        "body": "That’s called a computer science degree.  By your posting this I’m going to assume this is a fleeting thought that will burn out. If you had any real desire to know this you’d be to busy reading and hacking away at computers. \n\nThe way you do this is by building things and by applying and going to university, reading, doing your work. And after 5 years you’ll have a good understanding of how things work under the hood. You won’t be an expert in any of the domains but you understand the gist. \n\nHere are the essential layers you’ll need to hit:\n\n- **CPU & Architecture**: What does a processor actually do? How do registers, instructions, and binary voltages translate to physical actions? Why is memory organized the way it is, and how do instructions coordinate in time?  \n- **Operating Systems**: How does an OS tame raw hardware into “clean” interfaces? Spoiler: it’s messy under the hood.  \n- **Compilers & Languages**: How does high‑level code become machine behavior? What magic happens in a compiler?  \n- **Networking & the Internet**: Beyond HTTP, how do cables, packets, routing tables, and TCP/IP handshakes actually move bits? How does DNS keep this chaos somewhat organized?  \n- **Cryptography, Timekeeping & Physics**: At some point you realize it’s atoms and electrons obeying math and thermodynamics—and you’ve blinked into neighboring disciplines.\n\n**Resources to jump in**  \n- **Nand2Tetris** (aka *The Elements of Computing Systems*): Builds from NAND gates up to a simple OS and language—brilliant end‑to‑end.  \n- **CS:APP (Computer Systems: A Programmer’s Perspective)**: A gritty look at how your code really runs.  \n- **Computer Networking: A Top‑Down Approach** + **TCP/IP Illustrated**: From application‑level down to wires and packets.  \n- **Operating Systems: Three Easy Pieces** + **Code** by Charles Petzold: Deep dives with those “ohhh, that’s how it works” moments.  \n- **The Art of Unix Programming**: Cultural wisdom before you start spelunking Linux kernel code.\n\n\n- **Learn C.** It forces you to see pointers, memory, stacks, and segmentation faults—steam leaking from the abstraction pipe.  \n- **Tackle language design**: parsing, ASTs, interpreters, compilers, meta‑circular eval—like casting spells in code.  \n- **Explore theory**: Turing machines, computational limits, generating randomness on deterministic hardware, information theory.\n\nYou’ll never truly hit the bottom building an inspecting things is a good route: run `tcpdump`, hand‑inspect packets, write your own web server without libraries, build an OS in assembly, etc. ",
        "author": "AI_is_the_rake",
        "created_utc": 1744980445,
        "score": 89,
        "parent_id": "t3_1k23e4m",
        "depth": 0
      },
      {
        "id": "mnqwrqf",
        "body": "That sounds unrealistic. CS is a giant discipline and if you get in it you will have to accept that you won't be able to understand everything in depth.",
        "author": "Krowken",
        "created_utc": 1744978721,
        "score": 31,
        "parent_id": "t3_1k23e4m",
        "depth": 0
      },
      {
        "id": "mnrai6v",
        "body": "They may be man-made, but nobody, not even the greatest experts, understands everything about computers. They are complex at every level, the innovations of decades of engineers and logicians built on top of one another. Each layer is an abstraction of the previous one, so nobody needs to understand it fully in order to build upon it.\n\nYou’ll always have to wave your hands at some point when describing how computers work, but at least you can get a fairly accurate sense of it by studying a little bit at every level. At the very top there is knowing how to use a computer as a regular user, then there is knowing a scripting language, then there is understanding software development, then there is compiler/interpreter design (how programming languages themselves are made) and operating system design (the programs that run all the other programs on your computer). Below that is understanding system hardware components and how machine code is written and interpreted, and below that we start getting into logical circuitry (AKA how do we trick electricity into doing math for us). Any lower and we’ve left the computer science domain and entered the land of electrical engineering and particle physics.",
        "author": "Quantum-Bot",
        "created_utc": 1744983799,
        "score": 12,
        "parent_id": "t3_1k23e4m",
        "depth": 0
      },
      {
        "id": "mnqxk9x",
        "body": "Consider that a computer really only contains 4 influential parts:\n\n1. Processors\n\n2. Main memory\n\n3. I/O\n\n4. System bus\n\nThe best way to learn how a computer really works would be to start learning about these 4 components, once you figure out how these 4 components work together, breaking them down individually becomes easy. \n\nFrom there you can dive into more advanced topics like the Von Neumann architecture, kernels, assembly language, paging and segmentation, operating systems and networking.",
        "author": "i__have__ebola",
        "created_utc": 1744979045,
        "score": 7,
        "parent_id": "t3_1k23e4m",
        "depth": 0
      },
      {
        "id": "mnri4e8",
        "body": "A great starting point could be Ben Eater’s YouTube channel, where he builds an 8-bit computer from scratch. It’s both educational and a lot of fun!  \nFrom there, it really depends on your interests. You can go lower-level and try synthesizing a CPU using an FPGA with VHDL or Verilog, or you can move up the stack and explore how operating systems work—their fundamental building blocks and inner workings.  \nThere are plenty of great resources out there on topics like \"writing your own OS from scratch just for fun,\" and similar projects.",
        "author": "SignificanceIcy2589",
        "created_utc": 1744986264,
        "score": 7,
        "parent_id": "t3_1k23e4m",
        "depth": 0
      },
      {
        "id": "mnre5zh",
        "body": "I'll second the [nand2tetris.org](https://nand2tetris.org) recommendation: this will give you about 70% of what you're looking for, and a solid foundation for pursuing the rest.",
        "author": "not-just-yeti",
        "created_utc": 1744985004,
        "score": 6,
        "parent_id": "t3_1k23e4m",
        "depth": 0
      },
      {
        "id": "mnr9eg0",
        "body": "There's a great article called \"The Internet Explained from First Principles\" that pretty much does what it says:\n\nhttps://explained-from-first-principles.com/internet/",
        "author": "rednets",
        "created_utc": 1744983425,
        "score": 4,
        "parent_id": "t3_1k23e4m",
        "depth": 0
      },
      {
        "id": "mnrdhkz",
        "body": "Start by entering a good computer science college",
        "author": "gboncoffee",
        "created_utc": 1744984783,
        "score": 3,
        "parent_id": "t3_1k23e4m",
        "depth": 0
      },
      {
        "id": "mnrhmlk",
        "body": "That's quite a challenge depending on what you read into \"fully understanding\".\n\nBen eater and domino computers (search youtube) may give a somewhat digestable introduction to parts of how computers work.",
        "author": "Diligent_Ad_9060",
        "created_utc": 1744986110,
        "score": 3,
        "parent_id": "t3_1k23e4m",
        "depth": 0
      },
      {
        "id": "mnrscmy",
        "body": "Suggest: Harvard CS50, Nand2Tetris, and MITs computation structures. Then do some podcasts (like Lex + Hotz round2). And a lot of filling articles in between - from a bachelors degree.",
        "author": "sanjarcode",
        "created_utc": 1744989358,
        "score": 3,
        "parent_id": "t3_1k23e4m",
        "depth": 0
      },
      {
        "id": "mnt3tm0",
        "body": "Had the same idea, got a CS degree, am satisfied now.",
        "author": "Enough_Cauliflower69",
        "created_utc": 1745003656,
        "score": 3,
        "parent_id": "t3_1k23e4m",
        "depth": 0
      },
      {
        "id": "mnrszln",
        "body": "Anyone who claims to fully understand everything about computers and the internet down to the lowest levels is either lying or an idiot who doesn't know what they are talking about.\n\nHow many people fully understand processor design down to the transistor level?\nHow many of them understand how the guts of a modern operating system work?\nOf those people (if we aren't already at a group size of zero) understand cryptography well enough to understand how internet security works? \nWe could easily throw in a few more specialities but I think you get the idea.\n\nTo fully understand any one of those areas is a lifetimes work. You could know everything to an above average level, possibly even all of them to the level of the average person working in those fields. But fully understanding more than a tiny fraction down to the lowest level? Forget it.",
        "author": "InevitablyCyclic",
        "created_utc": 1744989550,
        "score": 2,
        "parent_id": "t3_1k23e4m",
        "depth": 0
      },
      {
        "id": "mnsc7q9",
        "body": "Besides nand2tetris, a first step would be *Code: The Hidden Language of Computer Hardware and Software* by Charles Petzold",
        "author": "Worried_Humor_8060",
        "created_utc": 1744995335,
        "score": 2,
        "parent_id": "t3_1k23e4m",
        "depth": 0
      },
      {
        "id": "mnsplfb",
        "body": "Yeah you’ll likely want a CS degree or equivalent education, lots of which can be had for free online. OSTEP (Operating Systems: Three Easy Pieces) is a decent resource for OS, although I wouldn’t necessarily call it easy, for other resources you can find whole curated lists of them from searching, and they’ll guide you both on “what topics to learn” and sort of “how much deep to learn them”, so you’ll have to dig even deeper on your own if that’s not enough. Maybe you’ll also want an electrical engineering degree to go low level enough…\n\nAs for internet, the CCIE (Cisco Certified Internetwork Expert) cert is a pretty good proxy for knowing a ton about the internet, and you’d be hard pressed to find someone who knows more about it than a CCIE, so following along some cert track and doing study guides and practicals will eventually build that knowledge for you too.\n\nAll in I expect this to take you a minimum of ~12 years to accomplish if you’re an absolute fiend and have someone sponsoring you/no other obligations. But realistically much closer to 30 years, and here’s the great news, by the time you’ve learned everything in 30 years, it will all be completely different!\n\nNew computer hardware architectures, new microcode new software architectures and programming languages maybe even new physical materials to make the stuff, definitely new network OS & hardware. — of course everything you learn will all still be running in production somewhere, and the knowledge and skills won’t be useless, but that will largely be because you learned the abstractions well rather than the low level concrete details. Oh and even possibly fundamentally new paradigms of computation (quantum) that also may take additional decades to learn.\n\nI can’t fault you, I want the same thing really just because it’s all so interesting to me and so I’m totally unbothered by reading old spec sheets for CPUs long-since out of production, and then writing assembly programs for them that serve no practical function. My real point is you should clarify, for yourself, why do you actually want to do this? The reason could be anything at all, you want to be a professional, looking for a hobby, want to teach or tutor others, entertaining your masochism… whatever it is will influence which things are most valuable or relevant for you to learn. Clarifying it for yourself will help you have a guiding light, and if you want, clarifying your goals to others will enable them to help you even better.",
        "author": "zenware",
        "created_utc": 1744999260,
        "score": 2,
        "parent_id": "t3_1k23e4m",
        "depth": 0
      },
      {
        "id": "mntc9g1",
        "body": "This guy thinks he’s iron man.",
        "author": "travannah",
        "created_utc": 1745006360,
        "score": 2,
        "parent_id": "t3_1k23e4m",
        "depth": 0
      }
    ],
    "1k1shwf": [
      {
        "id": "mnoohzq",
        "body": ">Reasonably, in most games I imagine that the slowest an object can move is the equivalent of roughly 1 mm/second, and the fastest is equivalent to probably maximum bullet velocity, roughly 400 meter/second, i.e. 400,000 mm/second.\n\nOn its face, I don't think these assumptions are necessarily reasonable.  e.g. Elite Dangerous has speeds ranging from a few hundred meters per second to tens of thousands of lightyears per second in its game.  Also, you might not want to deal with things in units of millimeters all the time --- what if you're building a driving game where things are measured in kilometers?\n\nA big reason, though, is that if you're staying strictly in the integer world, you have to be really careful about division because you can \"bottom out\" at 0 really easily.  With floating point numbers, there's a *lot* of numbers between 0 and 1.",
        "author": "apnorton",
        "created_utc": 1744938084,
        "score": 110,
        "parent_id": "t3_1k1shwf",
        "depth": 0
      },
      {
        "id": "mnpc5k4",
        "body": "Have you ever taken a computational geometry class?\n\nTo rotate something, you need to multiply its coordinates by a [rotation matrix](https://en.wikipedia.org/wiki/Rotation_matrix) \\- a matrix built from the sin and cosine of your angle. Doing so accurately requires floating point values.",
        "author": "zacker150",
        "created_utc": 1744947455,
        "score": 74,
        "parent_id": "t3_1k1shwf",
        "depth": 0
      },
      {
        "id": "mnoz6c5",
        "body": "It is extremely hard to do actual math with fixed precision. Any multiplication also multiplies possible range  Add some exponents, some divisions and you need many orders of magnitude to hold all intermediate values. Games used to be made with fixed point math all the time (PS1 era, Doom etc). But it is extremely cumbersome and requires a lot of really tedious and fragile bounds checking all over the place.\n\nLooking at space transforms or perspective projections, there are almost always very small values multiplied with very big values to end up with a \"normal\" result. Perfect for float, but not possible with fixed point.\n\nGPUs use small floats (16b, or even 8b), and lots of fixed-point tricks, and it is extremely easy to mess it up and get wildly wrong values. Try making even slightly large game worlds, and you will hit the 32-float limit; hard. \n\ntl;dr. it's not about the values you store, it's about the math in-between. \"Handbook of Floating Arithmetic\" (J-M Muller) is a pretty good read with lots of fun details.",
        "author": "jaap_null",
        "created_utc": 1744942089,
        "score": 67,
        "parent_id": "t3_1k1shwf",
        "depth": 0
      },
      {
        "id": "mnop9j1",
        "body": "Back in the 80s, and less so the 90s, we cared about int VS float because of the extra processor overhead in calculation and memory footprint difference between the two. I suppose the modern equivalent is an arduino or other small low speed mcu. \n\nThese days it's a wasted effort trying to get rid of floats because computers are just so quick and the potential to cause future issues with a change to int isn't zero.",
        "author": "2748seiceps",
        "created_utc": 1744938365,
        "score": 35,
        "parent_id": "t3_1k1shwf",
        "depth": 0
      },
      {
        "id": "mnorscs",
        "body": "Seems like it would be hard to smoothly interpolate from [0.0 to 1.0] on a color, location, rotation, sound, animation, etc. with integers?\n\nAll games heavily involve interpolation.",
        "author": "Fippy-Darkpaw",
        "created_utc": 1744939313,
        "score": 9,
        "parent_id": "t3_1k1shwf",
        "depth": 0
      },
      {
        "id": "mnovh9o",
        "body": "You can multiply 2 floats and be almost certain you will not be out of range, and your loss of precision is minimized. Then you can accumulate that product into a running sum. If the running sum is bigger than the product (which is given in the case of almost all differential equation solvers/simulators, any sort of FIR processing, etc.), so your calculation error is limited. That error also scales with the absolute size of your numbers, so the relative error is more-less the same regardless of the range of numbers in use\n\nWith int (or fix point) types you need to take much more care to not run out of range from a multiplication while still keeping quantization error low, should the product be \"small\". It's just more bothersome to use, may require bitshifts to use properly (wasted operations compared to floats).\n\nreally, the question is reversed. Why should we use integer types (or hack in fix point types) to use in game engines, if floats work just fine? Premature optimization is the root of all evil.\n\nAlso, modern CPUs are superscalars. They can execute more than 1 instruction per clock, if the conditions are favorable. The hardware for making int and float operations on a CPU (or GPU) are separate, so pretty much every CPU can execute an int and a float operation at once without either type suffering.\n\nThis is important, because your code will always have int type operations for indexing into arrays and incrementing loop counters. Using floats for the actual math can actually be a direct speedup, because the real math and index operations are not fighting over the same part of the CPU",
        "author": "Masztufa",
        "created_utc": 1744940693,
        "score": 6,
        "parent_id": "t3_1k1shwf",
        "depth": 0
      },
      {
        "id": "mnqea00",
        "body": "I've implemented fixed-point graphics maths using integers (in TurboPascal, no less). At the time, floating point coprocessors were rare and expensive, so if you wanted speed, fixed-point was a requirement. You could further improve performance by implementing fixed point operations in inline assembler if you were prepared to dig into the Intel x86 instruction set documentation. \n\nThere is a problem with accuracy - you may end up having to have more than one fixed point range to deal with both large numbers, and high accuracy decimals. Every operation requires checking to see if you need to shift numbers from one format to another. Errors accumulate, so you need to regularly correct or round numbers to a smaller number of digits. Logs and Trigonometric functions that are natively implemented in a floating point processor have to be implemented in your fixed-point format, or (more commonly) extrapolated on the fly from pre-generated lookup tables. \n\nIt's painful. I have seen reference to modern libraries for processors that still don't implement floating point maths. But all the caveats I mentioned apply, and for mainstream processors, floating point is still easier, even if it might be a bit slower.",
        "author": "grat_is_not_nice",
        "created_utc": 1744969382,
        "score": 4,
        "parent_id": "t3_1k1shwf",
        "depth": 0
      },
      {
        "id": "mnopuk4",
        "body": "Given that modern hardware has strong support for floating point calculations, it doesn't really make sense for most games to avoid them. They make dealing with fractional numbers easy and performant. While fixed-point numbers can be encoded using integers, the fact that most programming languages and libraries don't natively support them makes it not worthwhile anyway.",
        "author": "xArchaicDreamsx",
        "created_utc": 1744938584,
        "score": 3,
        "parent_id": "t3_1k1shwf",
        "depth": 0
      },
      {
        "id": "mnorz7q",
        "body": "It’s simply easier to use floating point for most real-number calculations. You can write a fixed-point representation, but there will be a lot of back and forth conversions, for instance, when you need to take the square root. Hitting the same optimization for your hand-rolled mathematical functions is a chore (that said, mathematical functions are often written to be faster with a loss of accuracy). Also, your hand-rolled types won’t work well with SIMD, and SIMD, in general, has better support for floating point values than integer values. ",
        "author": "aePrime",
        "created_utc": 1744939384,
        "score": 3,
        "parent_id": "t3_1k1shwf",
        "depth": 0
      },
      {
        "id": "mnou1gw",
        "body": "The main requirement for integers in modern PCs is where absolute and known precision is needed: Finance, Memory access, Counting objects, etc.. Essentially, whenever discrete things (or things with a maximum realistic detail, such as colour) are used, they should use integers, while anything else should use floats.",
        "author": "BIRD_II",
        "created_utc": 1744940158,
        "score": 3,
        "parent_id": "t3_1k1shwf",
        "depth": 0
      },
      {
        "id": "mnp17r2",
        "body": "Tell me how you would represent cash over 2.3B or change using signed integers. And then how you would represent it using floats. You could do it with integers but it’s much easier and straightforward with floats. That’s one single example. There are many more.\n\nAn object moves 2.4 units per frame? A bullet hits at frame 143.78 of a 60Hz simulation? Animation is blended between 45.5% idle and 54.5% running?\n\nWant a camera to move smoothly from point A to B over 1.5 seconds? You need sub-unit precision. Want to blend animations 30% run and 70% walk? Again—fractions.\n\nOn the topic of linear algebra which is how computers produce graphics on the screen, rotation matrices and quaternions are inherently float-based. Physics calculations (gravity, acceleration, interpolation, easing functions) need fractional values.",
        "author": "Fate_Creator",
        "created_utc": 1744942888,
        "score": 2,
        "parent_id": "t3_1k1shwf",
        "depth": 0
      },
      {
        "id": "mnp2tw0",
        "body": "In j2me, older Java, early on we didn’t have floats so you can find books that talked about how to do it with ints. It is work but I built a mobile race game that way. It isn’t bad to look at how things were done back in the day.",
        "author": "Jamb9876",
        "created_utc": 1744943525,
        "score": 2,
        "parent_id": "t3_1k1shwf",
        "depth": 0
      },
      {
        "id": "mnp7l9i",
        "body": "If you look at games for older computers where floating-point hardware was unavailable it was common to use integers for representing most values.  You could do calculations very fast, but also had to do more clever programming to handle calculations that would be much simpler with floating-point numbers.",
        "author": "stevevdvkpe",
        "created_utc": 1744945470,
        "score": 2,
        "parent_id": "t3_1k1shwf",
        "depth": 0
      },
      {
        "id": "mnpii6j",
        "body": "It's been done. There was a billiards game for Macintosh around 1990ish that used ints for everything. It used fixed point numbers so, basically, it used 1 to represent 0.001 inches, 2 to represent 0.002 inches, etc. Or something like that. \n\nThey did this for performance.  At the time some Macintosh computers had a floating point processor chip that enabled them to do floating point maths, and some did not. Doing floating point maths without that extra chip was very very slow.\n\nComputers now all have floating point maths functions built into their main processor, and are designed on purpose to be good at using floating point numbers in games.",
        "author": "Robot_Graffiti",
        "created_utc": 1744950427,
        "score": 2,
        "parent_id": "t3_1k1shwf",
        "depth": 0
      }
    ],
    "1k18ehj": [
      {
        "id": "mnkjiyq",
        "body": "There are modeling and simulation in most science/engineering field. With fantastic calculation capability of a computer, would you not using it?\n\nIf it is science, a mathematical model will be useful model (if not the only model) for anything you are interesting in.\n\nNot everything compute by a computer is about the computing itself. To answer your question, I think it is No.",
        "author": "recursion_is_love",
        "created_utc": 1744891124,
        "score": 8,
        "parent_id": "t3_1k18ehj",
        "depth": 0
      },
      {
        "id": "mnkc5vn",
        "body": "What college is this?, because i don't think this is offered in universities/colleges in my country",
        "author": "General_Resident_915",
        "created_utc": 1744887904,
        "score": 5,
        "parent_id": "t3_1k18ehj",
        "depth": 0
      },
      {
        "id": "mnk0g19",
        "body": "It's rather principles applying to different disciplines.",
        "author": "Visible-Employee-403",
        "created_utc": 1744881403,
        "score": 2,
        "parent_id": "t3_1k18ehj",
        "depth": 0
      },
      {
        "id": "mnk0ush",
        "body": "I think it's mostly biology + physics (or control theory). ",
        "author": "neuralengineer",
        "created_utc": 1744881664,
        "score": 2,
        "parent_id": "t3_1k18ehj",
        "depth": 0
      },
      {
        "id": "mnljgna",
        "body": "Computational <some science> is largely about methods for efficiently computing things for mathematical models, the foundation would be maths for modelling and numerical methods for actually calculating things, and then most likely implementing the numerical methods and models in code so you can let a computer do the calculations because no one is finding numerical solutions to differential equations by hand",
        "author": "defectivetoaster1",
        "created_utc": 1744902989,
        "score": 2,
        "parent_id": "t3_1k18ehj",
        "depth": 0
      },
      {
        "id": "mo10bul",
        "body": "Systems biology focuses on understanding complex biological interactions as a whole system (using both math models and code), while bioinformatics is more about analyzing biological data with algorithms - so yes you'll code a lot, but systems biology has more theoretical modelling than pure bioinformtics which is more data-processing heavy.",
        "author": "PM_ME_UR_ROUND_ASS",
        "created_utc": 1745114987,
        "score": 2,
        "parent_id": "t3_1k18ehj",
        "depth": 0
      },
      {
        "id": "mo3nis4",
        "body": "I am a bioinformatics student, I'd say yeah but not quite? Systems biology is indeed CS heavy, but it involves a lot of biology and biochemistry and is very heavy on maths. The focus is on using computational and mathematical methods to study biology from a complex system perspective rather than a detail one, so you can expect stuff like reconstruction of metabolic pathways or microbiota reconstruction. There is a lot of mathematical modelling, and less of a high detail CS analysis.",
        "author": "New_to_Siberia",
        "created_utc": 1745161797,
        "score": 2,
        "parent_id": "t3_1k18ehj",
        "depth": 0
      }
    ],
    "1jz4oqu": [
      {
        "id": "mn3k2x1",
        "body": ">Because I couldn't see lessons for math, physics\n\nI would argue Physics should be considered out-of-scope; it is true that understanding physics can help with understanding circuit-level aspects of how computers work, but that's not *really* \"computer science\" in the traditional sense.  Yes, it's required for the degree in most schools, but that's more-or-less a \"general education\" requirement for engineers.\n\nThere are certainly math concepts that would be needed to *truly* understand some of the things listed (e.g. asymptotics requires an understanding of limits), but I feel like if you start adding in pre-requisite math you're going to go down a rabbithole of no return.\n\n>computer architecture, operating systems\n\nThe \"Networking,\" \"How Computers Work,\" \"Processes and Threads,\" and \"System design\" sections appear to touch on a significant part of what would be in a comp arch + OS course.",
        "author": "apnorton",
        "created_utc": 1744653322,
        "score": 39,
        "parent_id": "t3_1jz4oqu",
        "depth": 0
      },
      {
        "id": "mn3mca4",
        "body": "if you're starting out from scratch, most (if not all) universities have the curriculum on their websites and I'd say those are great resources. Example one from MIT: [https://catalog.mit.edu/degree-charts/computer-science-engineering-course-6-3/](https://catalog.mit.edu/degree-charts/computer-science-engineering-course-6-3/) \n\nHonestly beyond the basics, what you study should be what you like from there on. In reality, you'll forget a lot of this stuff anyways, but what sticks is your ability to solve problems. I highly suggest to incorporate a ton of projects in your roadmap. One of the great things about CS is that a computer and good internet can take you really far, so take advantage of that. \n\nHope this helps :)",
        "author": "aeronauticator",
        "created_utc": 1744653979,
        "score": 22,
        "parent_id": "t3_1jz4oqu",
        "depth": 0
      },
      {
        "id": "mn6pb5a",
        "body": "Real computer science needs a lot of math.  It's not an applied science.  You should look at a university program like Carnigie Melon, UIUC, Berkley, MIT, or Stanford.",
        "author": "DorkyMcDorky",
        "created_utc": 1744693048,
        "score": 8,
        "parent_id": "t3_1jz4oqu",
        "depth": 0
      },
      {
        "id": "mn3kpnq",
        "body": "Most of what you listed isn’t really computer science, you can learn those separately. Computer architecture is comp engineering. The CS parts of architecture are listed on that roadmap, under system design and How Computers Work and Processes and Threads. It isn’t comprehensive but it has some of that. Much of the theory stuff it mentions is math. \n\nThis looks to me to be more of a roadmap that causes someone to feel like they’re learning stuff and can speak as someone from the industry, but someone with that list of knowledge would have a tough time finding a real job. If they did, it’d be pretty generic and end of the line mill type job, unless you become really good at designing scalable web services, data engineering, or certain cybersec skills. You’d have to convince your company that the rest of those topics actually matters, and most of them would require extra education and maybe some certifications. ",
        "author": "alnyland",
        "created_utc": 1744653502,
        "score": 5,
        "parent_id": "t3_1jz4oqu",
        "depth": 0
      },
      {
        "id": "mn5zv5l",
        "body": "Go check out these documents as better reference points:\n\n[https://github.com/ossu/computer-science](https://github.com/ossu/computer-science)\n\n[https://csed.acm.org/wp-content/uploads/2023/09/Version-Gamma.pdf](https://csed.acm.org/wp-content/uploads/2023/09/Version-Gamma.pdf)",
        "author": "MathmoKiwi",
        "created_utc": 1744682111,
        "score": 3,
        "parent_id": "t3_1jz4oqu",
        "depth": 0
      },
      {
        "id": "mn3ovp4",
        "body": "Counting Ford-Fulkerson as a greedy algorithm certainly makes that category messy.",
        "author": "Eroica_Pavane",
        "created_utc": 1744654733,
        "score": 2,
        "parent_id": "t3_1jz4oqu",
        "depth": 0
      },
      {
        "id": "mn75b3a",
        "body": "This is more of a bachelor software engineering road map than a computer science one ",
        "author": "Waffalz",
        "created_utc": 1744702609,
        "score": 2,
        "parent_id": "t3_1jz4oqu",
        "depth": 0
      }
    ],
    "1jy8t8g": [
      {
        "id": "mn0asyu",
        "body": "Usually you have to go quite deep before the connections become clear. And the thing that binds them together is almost always maths.",
        "author": "Medium-Pen3711",
        "created_utc": 1744602694,
        "score": 4,
        "parent_id": "t3_1jy8t8g",
        "depth": 0
      }
    ],
    "1jy0nay": [
      {
        "id": "mmuuwpo",
        "body": "digital signal processing mainly focuses on topics like fourier analysis, sampling, quantization, filtering, convolutions, etc. Usually these courses also have a lot of focus on audio processing as well. The way I think about it is that digital signal processing has to do with compression and error correction of handling image data in transit and in storage. \n\nBased on that, even though there is some overlap between that and a bunch of image processing stuff, it's not substantial enough in my opinion to be a necessary prerequisite unless you're interested in topics like compression and error correction\n\n  \nFor computer graphics, computer vision stuff, I'd focus a lot more on building a strong foundation in linear algebra, calc, and some stats. \n\nHope this helps!",
        "author": "aeronauticator",
        "created_utc": 1744525318,
        "score": 7,
        "parent_id": "t3_1jy0nay",
        "depth": 0
      },
      {
        "id": "mmuyvd8",
        "body": "I would say that the course will be very useful to you but it will not expose you to those techniques you might be interested in immediately.\n\nUnfortunately, curricula have to compartmentalise subjects for practical reasons. But knowledge does not come in small boxes.\n\nSignals and systems will give you a huge amount of background knowledge that will definitely help you understand why some techniques work the way they do or why it is impossible to do certain things.\n\nAs a personal example, I felt that I would not have got wavelets had I not have a very good exposure to the Fourier transform. \n\nTo an extent, digital image processing is 2d digital signal processing. To that extent, it is worth 100% taking the signals and systems course.\n\nIf you are interested in radiance fields and gaussian splatting and high dynamic range imaging and colour matching, photogrammetry, etc....signals and systems will be useful but you will definitely find yourself reaching out to other domains of mathematics very frequently (geometry, linear algebra, statistics).",
        "author": "bluefourier",
        "created_utc": 1744527685,
        "score": 3,
        "parent_id": "t3_1jy0nay",
        "depth": 0
      },
      {
        "id": "mmvir6y",
        "body": "I wouldn’t consider signals & systems a requisite per se, and I imagine that those parts where that knowledge might be applied to image processing would be covered in your other courses anyway, but that isn’t to say there’s no benefit.\n\nThe main benefit of taking a signals & systems course would probably be in getting a more in-depth/rigorous understanding of certain topics (e.g. Fourier analysis & sampling). These are relevant to image processing, but an introductory image processing class might not say any more than “it works, here’s some examples, here’s a formula”. If you took a signals course, it would likely go deeper into mathematically proving why these techniques work and why the formulas look the way they do, whereas in an image processing course you’d simply take the facts at face value and move on. \n\nPersonally speaking, I would not have properly understood the ideas behind Fourier analysis had I only taken an image processing course, so in that sense I do recommend taking a signals course if you have the opportunity. That being said, I wouldn’t consider it a requisite for anything and you don’t need to take it before your other courses; better to have linear algebra/multivariable calculus/probability done first, if you haven’t already.",
        "author": "dandantian5",
        "created_utc": 1744540368,
        "score": 2,
        "parent_id": "t3_1jy0nay",
        "depth": 0
      },
      {
        "id": "mmvyf9b",
        "body": "DSP is where the magic is for CGI, e.g. shaders.",
        "author": "mycall",
        "created_utc": 1744548354,
        "score": 2,
        "parent_id": "t3_1jy0nay",
        "depth": 0
      }
    ],
    "1jxpua9": [
      {
        "id": "mmsb2hu",
        "body": "This is quite cool! Zero knowledge implementations are such an interesting area of CS research. Is this supposed to be a form of circuit arithmetization?",
        "author": "Calm_Dot1389",
        "created_utc": 1744488031,
        "score": 5,
        "parent_id": "t3_1jxpua9",
        "depth": 0
      },
      {
        "id": "mmskh6k",
        "body": "TIL about zero knowledge proofs. Pretty rad stuff ngl",
        "author": "BeginningLong551",
        "created_utc": 1744491164,
        "score": 3,
        "parent_id": "t3_1jxpua9",
        "depth": 0
      },
      {
        "id": "mmsqc2c",
        "body": "Nicely done!",
        "author": "Magdaki",
        "created_utc": 1744493177,
        "score": 2,
        "parent_id": "t3_1jxpua9",
        "depth": 0
      },
      {
        "id": "mmt47e2",
        "body": "this is awesome 🙌",
        "author": "poopingforhealth",
        "created_utc": 1744498190,
        "score": 2,
        "parent_id": "t3_1jxpua9",
        "depth": 0
      }
    ],
    "1jxopcz": [
      {
        "id": "mmsonss",
        "body": "The semiconductor junction question touches on a fundamental concept in solid-state physics that's often misunderstood. Let me clarify:\n\nElectrons flow from N to P initially not because they \"want\" to fill holes, but because of the concentration gradient. In N-type material, there's a high concentration of free electrons, while in P-type there are few. This creates a diffusion current - particles naturally move from areas of high concentration to low (like how a drop of food coloring spreads in water).\n\nAs electrons diffuse across, they leave behind positively charged donor atoms in the N region and combine with holes in the P region, creating negatively charged acceptor ions. This creates the depletion region with a built-in electric field pointing from N to P.\n\nThis electric field creates a drift current in the opposite direction of the diffusion current. Equilibrium is reached when these two currents balance exactly.\n\nElectrons don't flow back because:\n1. Any electron trying to move from P to N would be fighting against the built-in electric field\n2. The P region has very few free electrons to begin with\n3. The depletion region acts as an insulating barrier\n\nThis understanding forms the basis of diode behavior - current flows easily from P to N (forward bias) when you apply a voltage that works against the built-in field, but not from N to P (reverse bias) when you enhance the field.",
        "author": "traderprof",
        "created_utc": 1744492591,
        "score": 28,
        "parent_id": "t3_1jxopcz",
        "depth": 0
      },
      {
        "id": "mms1xsm",
        "body": "Wrong forum. Try r/electicalengineering",
        "author": "voodoohounds",
        "created_utc": 1744484986,
        "score": 10,
        "parent_id": "t3_1jxopcz",
        "depth": 0
      },
      {
        "id": "mmt7p1r",
        "body": "First watch this: https://youtu.be/33vbFFFn04k?si=ErFvmO7jcM2n4Obt\n\nThen watch this: https://youtu.be/DXvAlwMAxiA?si=HS16ZI8O3R9pTO9F",
        "author": "Obvious-Falcon-2765",
        "created_utc": 1744499513,
        "score": 3,
        "parent_id": "t3_1jxopcz",
        "depth": 0
      }
    ],
    "1jwujre": [
      {
        "id": "mmldphn",
        "body": "The best way to implement any data structure depends on the operations that you will mostly perform and which operations you most care about being optimally efficient.  Do you care more about memory efficiency, time to create efficiency, time to query if an element is in the POSET, efficiency in adding/changing/deleting elements from an existing POSET?",
        "author": "CanadianBuddha",
        "created_utc": 1744391295,
        "score": 10,
        "parent_id": "t3_1jwujre",
        "depth": 0
      },
      {
        "id": "mmldutk",
        "body": "The unfortunate answer is that it depends on the type of problem you're trying to solve.\n\n\nAs an example, for many things, a standard adjacency list representation will be fine. But if you ever end up dealing with a poset like (ℝ, <), good luck fitting all those elements in memory! ;)",
        "author": "apnorton",
        "created_utc": 1744391340,
        "score": 7,
        "parent_id": "t3_1jwujre",
        "depth": 0
      },
      {
        "id": "mmlddxt",
        "body": "DAGs model them pretty naturally.",
        "author": "Vallvaka",
        "created_utc": 1744391202,
        "score": 5,
        "parent_id": "t3_1jwujre",
        "depth": 0
      },
      {
        "id": "mmp58u7",
        "body": "You should probably work with an abstract representation, using typeclasses/traits, or interfaces if using an OOP language. Whatever type(s) you use to define the sets should instance/implement these types.\n\nEg, in Haskell:\n\n    class Poset t where\n        (<=) :: t -> t -> Bool\n        \n    class Poset t => JoinSemilattice t where\n        (\\/) :: t -> t -> t\n        \n    class Poset t => MeetSemilattice t where\n        (/\\) :: t -> t -> t\n        \n    class (JoinSemilattice t, MeetSemilattice t) => Lattice t\n    \n    class JoinSemilattice t => BoundedJoinSemilattice t where\n        bot :: t\n        \n    class MeetSemilattice t => BoundedMeetSemilattice t where\n        top :: t\n        \n    class (BoundedJoinSemilattice t, BoundedMeetSemilattice t) => BoundedLattice t\n\nOr in C# or similar:\n\n    interface Poset<T> \n    {\n        Bool LessOrEqual(T other); /* this <= other */\n    }\n\n    interface JoinSemilattice<T> \n        : Poset<T> \n    {\n        T LeastUpperBound(T other); /* this \\/ other /*\n    }\n\n    interface MeetSemiliattice<T> \n        : Poset<T> \n    {\n        T GreatestLowerBound(T other); /*  this /\\ other */\n    }\n    \n    interface Lattice<T> \n        : JoinSemilattice<T>\n        , MeetSemilattice<T> \n    { }\n\n    interface BoundedJoinSemilattice<T> \n        : JoinSemilattice<T> \n    {\n        T Bottom { get; }\n    }\n\n    interface BoundedMeetSemilattice<T> \n        : MeetSemilattice<T> \n    { \n        T Top { get; }\n    }\n\n    interface BoundedLattice<T> \n        : Lattice<T>\n        , BoundedJoinSemilattice<T>\n        , BoundedMeetSemilattice<T> \n    { }\n\nAs an example of usage, consider the lattice of substructural properties of types.\n\n\n                Linear\n               /     \\\n              /       \\\n        Affine         Relevant\n              \\       /\n               \\     /\n            Unrestricted\n\nWe can define a type to represent the substructural types, and then implement the instances for each of the above typeclasses. (Unfortunately this requires a bit of duplication in instances because we don't have a way to directly represent the meet and join as symmetric relations).\n\n    data SubstructuralType\n        = Linear\n        | Affine\n        | Relevant\n        | Unrestricted\n        \n    instance Poset SubstructuralType where\n        x <= x = True   -- refl\n        _ <= Linear = True\n        Unrestricted <= Affine = True\n        Unrestricted <= Relevant = True\n        _ <= _ = False\n        \n    instance JoinSemilattice SubstructuralType where\n        x \\/ x = x     -- refl\n        Unrestricted \\/ Affine = Affine\n        Affine \\/ Unrestricted = Affine\n        Unrestricted \\/ Relevant = Relevant\n        Relevant \\/ Unrestricted = Relevant\n        Affine \\/ Relevant = Linear\n        Relevant \\/ Affine = Linear\n        _ \\/ Linear = Linear\n        Linear \\/ _ = Linear\n\n        \n    instance MeetSemilattice SubstructuralType where\n        x /\\ x = x    -- refl\n        Relevant /\\ Linear = Relevant\n        Linear /\\ Relevant = Relevant\n        Affine /\\ Linear = Affine\n        Linear /\\ Affine = Affine\n        Affine /\\ Relevant = Unrestricted\n        Relevant /\\ Affine = Unrestricted\n        _ /\\ Unrestricted = Unrestricted\n        Unrestricted /\\ _ = Unrestricted\n\n    instance Lattice SubstructuralType\n    \n    instance BoundedJoinSemilattice SubstructuralType where\n        bot = Unrestricted\n        \n    instance BoundedMeetSemilattice SubstructuralType where\n        top = Linear\n        \n    instance BoundedLattice SubstructuralType\n\n---\n\n---\n\nAn alternative (and perhaps more optimal) way to represent things is with bit fields to represent states. If we consider again the substructural properties, but instead of considering the vertices of the lattice, we'll consider the edges - in this example, the edges represent the binary properties of contraction (arrow pointing `\\`) and weakening (arrow pointing `/`). If we take a bit to mean 1 = disallow contraction and 0 = allow contraction, and another bit to say 1 = disallow weakening and 0 = allow weakening, each of the types has a two-bit representation `00` where the MSB is the contraction bit and the LSB is the weakening bit.\n\n    11 = linear       (disallow contraction and weakening)\n    10 = affine       (disallow contraction, allow weakening)\n    01 = relevant     (allow contraction, disallow weakening)\n    00 = unrestricted (allow contraction and weakening)\n\nThen the LeastUpperBound (`\\/`) is just bitwise-or, and the GreatestLowerBound (`/\\`) is just bitwise-and.\n\n`x <= y` if all bits in `x` are `<=` all bits in `y` (where `0 < 1`).\n\nTop is `11` and bottom is `00`.\n\nIf we change the data type to use two bools (in practice we could do it more optimally with bit vectors).\n\n    data SubstructralProperty = SubstructuralProperty \n        { disallowContraction :: Bool\n        ; disallowWeakening :: Bool\n        }\n        \n    let linear = SubstructrualProperty True True\n    let affine = SubstructuralProperty True False\n    let relevant = SubstructuralProperty False True\n    let unrestricted = SubstructrualPropery False False\n\nThen the instances become simpler to implement:\n    \n    instance Poset Bool where\n        True <= False = False\n        _ <= _ = True\n\n    instance JoinSemilattice Bool where\n        (\\/) = (||)\n\n    instance MeetSemilattice Bool where\n        (/\\) = (&&)\n\n    instance BoundedJoinSemilattice Bool where\n        bot = False\n\n    instance BoundedMeetSemilattice Bool where\n        top = True\n\n\n    instance Poset SubstructrualProperty where\n        (SubstructrualProperty c0 w0) <= (SubstructuralProperty c1 w1) =\n            SubstructuralProperty (c0 <= c1) (w0 <= w1)\n            \n    instance JoinSemilattice SubstructuralProperty where\n        (SubstructuralProperty c0 w0) \\/ (SubstructuralProperty c1 w1) =\n            SubstructuralProperty (c0 \\/ c1) (w0 \\/ w1)\n            \n    instance MeetSemilattice SubstructuralProperty where\n        (SubstructuralProperty c0 w0) /\\ (SubstructuralProperty c1 w1) =\n            SubstructuralProperty (c0 /\\ c1) (w0 /\\ w1)\n    \n    instance BoundedJoinSemilattice SubstructuralProperty where\n        bot = SubstructuralProperty bot bot\n        \n    instance BoundedMeetSemilattice SubstructuralProperty where\n        top = SubstructuralProperty top top",
        "author": "WittyStick",
        "created_utc": 1744442648,
        "score": 3,
        "parent_id": "t3_1jwujre",
        "depth": 0
      }
    ],
    "1jvx0g1": [
      {
        "id": "mmdu3ne",
        "body": "I just do it for Minecraft cpus :3",
        "author": "Rude-Pangolin8823",
        "created_utc": 1744291324,
        "score": 17,
        "parent_id": "t3_1jvx0g1",
        "depth": 0
      },
      {
        "id": "mmiixeu",
        "body": "I went to Hackaday Supercon 6 2022 and have the badge in my office. I made Conway's GoL using the assembler they provided at the conference. It's pretty straightforward as far as assembly programming is concerned.",
        "author": "SteeleDynamics",
        "created_utc": 1744347379,
        "score": 5,
        "parent_id": "t3_1jvx0g1",
        "depth": 0
      },
      {
        "id": "mmdtesm",
        "body": "I got one and it comes with a USB connector so I can upload assembly coded programs in hex. Pretty neat stuff. I got motivated watching the hackathon wizards programming on it: https://www.youtube.com/live/X-XJmlMLx7k",
        "author": "spocek",
        "created_utc": 1744291082,
        "score": 2,
        "parent_id": "t3_1jvx0g1",
        "depth": 0
      }
    ],
    "1jvrj24": [
      {
        "id": "mmco6no",
        "body": ">(or return -1 if no such value exists)\n\nWhen you build the most powerful computer yet but somehow still can't figure out how to build a fucking type system",
        "author": "SV-97",
        "created_utc": 1744269955,
        "score": 106,
        "parent_id": "t3_1jvrj24",
        "depth": 0
      },
      {
        "id": "mmcml09",
        "body": "Given your title, the closest precise definition I can think of is \"What would you do if you could solve all NP problems in polynomial time?\" (since the NP in the famous 'P vs NP' means \"Nondeterministic Polynomial\").\n\n\nIn which case, with such a machine, you could :\n\n- Break all cryptography\n- Solve **exactly** many difficult applied problems (scheduling, path planning, allocation,...)\n- Help mathematician and physicists by having way better algorithms to explore hypothesis\n\nThose are my main thoughts, and as you can see, it would have a very broad impact.\n\n\nA tamer version of that is a quantum computer, which is arguably nondeterministic, but with a caveat: you don't get the exact answer *every time*, but with *good probability*. It is not as strong as solving NP, but still has strong implications (breaks most of commonly used cryptography, solves some known problems even faster).",
        "author": "spacewolfXfr",
        "created_utc": 1744268930,
        "score": 45,
        "parent_id": "t3_1jvrj24",
        "depth": 0
      },
      {
        "id": "mmcn6d2",
        "body": "Obviously the first thing would be getting Doom to run on that thing.",
        "author": "Yoghurt42",
        "created_utc": 1744269303,
        "score": 21,
        "parent_id": "t3_1jvrj24",
        "depth": 0
      },
      {
        "id": "mmcuo9e",
        "body": "Figuring out the answer to the unvierse for sure",
        "author": "Potential_Corner_268",
        "created_utc": 1744274230,
        "score": 4,
        "parent_id": "t3_1jvrj24",
        "depth": 0
      },
      {
        "id": "mmd3bcc",
        "body": "Run two threads on it and making them compete with one another on creating a problem that cannot be solved on a non deterministic computer.\n* Who am i kidding, i wold watch some non deterministic porn, like \"busy beaver parody\"",
        "author": "DaveAstator2020",
        "created_utc": 1744279689,
        "score": 3,
        "parent_id": "t3_1jvrj24",
        "depth": 0
      },
      {
        "id": "mmdaaui",
        "body": "Determine",
        "author": "Cybasura",
        "created_utc": 1744283377,
        "score": 3,
        "parent_id": "t3_1jvrj24",
        "depth": 0
      },
      {
        "id": "mmd3miv",
        "body": "Hardware is in theory non-deterministic\nSoftware is not.",
        "author": "wlynncork",
        "created_utc": 1744279870,
        "score": 2,
        "parent_id": "t3_1jvrj24",
        "depth": 0
      },
      {
        "id": "mmeolta",
        "body": "The runtime in the case that there is no solution isn't well defined, I think.\n\nIf I understand you correctly, your hypothetical machine is equivalent to having a machine with an unlimited number of cores that runs the function simultaneously for all possible inputs.\n\nThat would let you solve any problem in NP in polynomial time.\n\nYou still can't compute busy beaver or solve the halting problem. At least if the runtime can be infinite if there's an input for which the function does not terminate.\n\nIn practical terms, the most interesting problems it would let you solve is finding the pre-image of any hash function output. It would also break all asymmetric crypto. Funnily enough, it doesn't really break symmetric cryptography algorithms (as much, practically it likely still does) because you can't trivially decide which of the possible decrypted outputs is the correct one. In practice, symmetric is likely still broken just by doing frequency analysis or other sanity checks on each potential decrypted text and then only outputting 1 for decryption that pass some threshold of sensibility until there's only a practical number of possible results to check manually.",
        "author": "Firzen_",
        "created_utc": 1744300673,
        "score": 2,
        "parent_id": "t3_1jvrj24",
        "depth": 0
      },
      {
        "id": "mming6i",
        "body": "If I had a non-deterministic computer, I'd use it to generate truly random numbers",
        "author": "ryanstephendavis",
        "created_utc": 1744349761,
        "score": 2,
        "parent_id": "t3_1jvrj24",
        "depth": 0
      },
      {
        "id": "mmondqg",
        "body": "I would run stochastic computations.",
        "author": "LoopVariant",
        "created_utc": 1744432549,
        "score": 2,
        "parent_id": "t3_1jvrj24",
        "depth": 0
      }
    ],
    "1jvdxdi": [
      {
        "id": "mm9fxda",
        "body": "Looks like a variant of Kahn's Algorithm: https://en.wikipedia.org/wiki/Topological_sorting#Kahn's_algorithm",
        "author": "apnorton",
        "created_utc": 1744225818,
        "score": 11,
        "parent_id": "t3_1jvdxdi",
        "depth": 0
      },
      {
        "id": "mm9swmo",
        "body": "I can't talk about the technical content but kudos for the report and the detailed README.md. You've obviously put lots of time and love into this.",
        "author": "DeGamiesaiKaiSy",
        "created_utc": 1744229593,
        "score": 4,
        "parent_id": "t3_1jvdxdi",
        "depth": 0
      },
      {
        "id": "mmacbh8",
        "body": "It's a pretty cool variation of Topological Sort and its cool you wrote a proper benchmark etc. for it.\n\nSome friends and I organized an algorithm engineering course a while back and one of the problems we set for it was the same variation of topsort you came up with. Funnily enough we arrived at the exact same algorithm. The source code can be found here: [https://github.com/TheoreticalTree/Algo\\_Engineering\\_CPP/blob/main/src/topsort/basic\\_topsort.cpp](https://github.com/TheoreticalTree/Algo_Engineering_CPP/blob/main/src/topsort/basic_topsort.cpp)",
        "author": "LoloXIV",
        "created_utc": 1744235464,
        "score": 4,
        "parent_id": "t3_1jvdxdi",
        "depth": 0
      }
    ],
    "1jviwhx": [
      {
        "id": "mmawd8n",
        "body": "“the 4 to 16 decoder is used to generate write signal for a concrete byte”\n\nNot quite. The 4 to 16 decoder generates 16 intermediate signals, each of which go into an AND gate WITH THE WRITE signal. It’s Important to note this. These AND gates are in the third screenshot you’ve attached.\n\nThe outputs of these AND gates are W0 to w15, as shown in the third screenshot. These outputs then go into the bytes in the first screenshot as the write signals. \n\n“What is that second write signal? Where does it come from?”\n\nThere’s only one “Write” signal that goes into the 16 AND gates with the 16 decoder outputs.\n\nI’m currently deciphering your other two points of confusion but please let me know if that makes sense for now. Hope it helped!!",
        "author": "nineinterpretations",
        "created_utc": 1744242305,
        "score": 3,
        "parent_id": "t3_1jviwhx",
        "depth": 0
      }
    ],
    "1jv3db7": [
      {
        "id": "mm9hidq",
        "body": ">ram to accessed quickly\n\nFrom a CPU perspective, RAM is slow.  The CPU pulls the data from the RAM, into L3 cache. L3 cache is faster but still too slow.  CPU pulls again into L2 cache where it can finally work on the data. It can even use its L1 cache if it needs to access it more often. (simplified).\n\nTo give you an idea how big of a difference between the caches.  If you are sitting in your office desk, L1 cache is desk size.  L2 is your draws and cubbies under your desk, L3 is your office floor, and RAM is your city.  If you want something from RAM aka city, best case is it will be in L3 or your building.  Otherwise, it will take an delivery service to bring it to you.",
        "author": "yuehuang",
        "created_utc": 1744226290,
        "score": 27,
        "parent_id": "t3_1jv3db7",
        "depth": 0
      },
      {
        "id": "mm72xbv",
        "body": "https://cpu.land/the-basics#:\\~:text=The%20CPU%20always%20reads%20machine,moves%20the%20pointer%20and%20repeats.",
        "author": "_d0s_",
        "created_utc": 1744199534,
        "score": 5,
        "parent_id": "t3_1jv3db7",
        "depth": 0
      },
      {
        "id": "mm73860",
        "body": "Kind of. This is an oversimplification: \n\n  \nThe CPU has a very limited memory; so it offloads some of the storage of data to RAM (including code and data as you call it) and load data from it to its own internal memory (registers, etc.) and stores computation results back to RAM.\n\n  \nBut also RAM is limited so there almost all of the code and data is on another storage (often disk) and are loaded to RAM (in bigger pages).",
        "author": "MCSajjadH",
        "created_utc": 1744199658,
        "score": 5,
        "parent_id": "t3_1jv3db7",
        "depth": 0
      },
      {
        "id": "mm87h7t",
        "body": "Im a junior CS major and I plan on specializing in OS work or systems level programming.\n\nThreads are very similar to processes. They run lighter weight strings of executions (series of instructions). Threads are nice because they allow.a co-operative execution. If you are interested in them, a good entry is pthreads which is a part of the C library.\n\nWhen an app is opened it is in a ready state. So it doesn't actually get to use all of RAM yet. This i made obvious when you consider that on a 32 bit system, a program is promised 2\\^32 available address space. So if you have a lot of programs open, they can't all have exclusive access to RAM( exclusive access is the idea that something is truly yours). In reality, most systems utilize virtualization(the lie that each process gets it's own address space, CPU, and any other system resource. \n\nThe RAM and CPU work together in the sense that in a von neumann architecture, all data and instructions reside in memory (RAM). \n\nFurther more, CPU cores are really just mini processors. If you know anything about the pigeonhole principle- if you have N buckets and more than N pigeons, they will have to double up or triple up in one bucket - cores aim to reduce the workload caused by one processor. It's important to know that CPU (or any processor afaik, can only one instruction at a time).",
        "author": "dggilson",
        "created_utc": 1744212963,
        "score": 2,
        "parent_id": "t3_1jv3db7",
        "depth": 0
      }
    ],
    "1jv1l1l": [
      {
        "id": "mm8xjdx",
        "body": "I actually view the algorithm/computation as the more fundamental thing and the instances of it cropping up in physics as just being instantiations of it.",
        "author": "matthkamis",
        "created_utc": 1744220527,
        "score": 39,
        "parent_id": "t3_1jv1l1l",
        "depth": 0
      },
      {
        "id": "mm9slyr",
        "body": "The chemist says: \"Biology? Hah! It's all just chemistry\"\n\nThe physicist says: \"Chemistry? Hah! It's all just physics\"\n\nThe mathematician says: \"Physics? Hah! It's all just math\"\n\nThe philosopher says: \"Math? Hah! It's all just abstract thought.\"\n\nThe psychologist says: \"Abstract thought? Hah! It's all just neural activity.\"\n\nThe biologist says: \"Neural activity? Hah! It's all just biology.\"",
        "author": "SirTwitchALot",
        "created_utc": 1744229507,
        "score": 23,
        "parent_id": "t3_1jv1l1l",
        "depth": 0
      },
      {
        "id": "mm6zxgj",
        "body": "[https://en.wikipedia.org/wiki/Systolic\\_array](https://en.wikipedia.org/wiki/Systolic_array)\n\nHuge stretch, but \"The name is derived from [systole](https://en.wikipedia.org/wiki/Systole) as an analogy to the regular pumping of blood by the heart.\" I doubt that this is what specifically motivated it. Probably just a more vague notion of flow.\n\nIt's basically pipelining but on crack.",
        "author": "TheBlasterMaster",
        "created_utc": 1744198248,
        "score": 4,
        "parent_id": "t3_1jv1l1l",
        "depth": 0
      },
      {
        "id": "mm93j2b",
        "body": "That sounds familiar.\n\nGerman philosopher Ernst Kapp (1808 – 1896) argued that everything mankind produces is inspired by body parts; that tools, weapons, machine parts, etc. represent unconscious projections of human organs.",
        "author": "Raccoonridee",
        "created_utc": 1744222204,
        "score": 5,
        "parent_id": "t3_1jv1l1l",
        "depth": 0
      },
      {
        "id": "mm9coku",
        "body": "Stereoscopic vision (using 2 cameras) was derived from how a pair of eyes do it. \n\nRobotics and AI have spent decades studying MANY life forms, not just humans but insects, fish, birds, etc. to come up with better ways to move, adapt, etc.",
        "author": "Independent_Art_6676",
        "created_utc": 1744224860,
        "score": 3,
        "parent_id": "t3_1jv1l1l",
        "depth": 0
      },
      {
        "id": "mmm43mq",
        "body": "Math was created to describe the natural world — it’d be weird if it didn’t.",
        "author": "iOSCaleb",
        "created_utc": 1744399197,
        "score": 2,
        "parent_id": "t3_1jv1l1l",
        "depth": 0
      },
      {
        "id": "mmmjoit",
        "body": "Well even I learnt this stuff but never looked at it this way. Sounds good when you say it like this. It's actually quite fascinating how computer scientists look at things. It's crazy how a flock of birds must have inspired particle swarm intelligence and how the evolution process inspired the genetic algorithm in ai search. Maybe it comes to people who just look for algorithms and logics in the tiniest of things. I want to be someone who just thinks in binary. How do you find patterns everywhere? Maybe you just keep looking for them everywhere !",
        "author": "Illustrious_Echo_232",
        "created_utc": 1744403957,
        "score": 2,
        "parent_id": "t3_1jv1l1l",
        "depth": 0
      },
      {
        "id": "mmnpqug",
        "body": "Well. Knowledge connects. Cool stuff.\n\nAll computation can be modeled as manipulating objects in a physical space of some sort, so techniques for manipulating mathematical or physical objects tend to transfer.",
        "author": "shifty_lifty_doodah",
        "created_utc": 1744418633,
        "score": 2,
        "parent_id": "t3_1jv1l1l",
        "depth": 0
      }
    ],
    "1juf5zj": [
      {
        "id": "mm1oaz8",
        "body": "So first and foremost, you prevent them by using numerically stable methods. \n\nBut the point of game physics is to support gameplay, not to make realistic physics, so you clamp and dampen values. Eg if an object is moving very slowly according to the engine then just stop it from moving at all, with a better engine it would probably converge to standing still and it's not worth the compute. Likewise if an object is going very fast then probably something went wrong so you keep it at a max speed or delete it. \n\nAnd the more you can fake, the better. How would you do a collision in an altered gravity racing game that's dramatic but still possible to recover from? Just fake it! Make the ship model bounce around, but also keep an invisible parametrically controlled object to ease back to after a few seconds.",
        "author": "UnicornLock",
        "created_utc": 1744125110,
        "score": 135,
        "parent_id": "t3_1juf5zj",
        "depth": 0
      },
      {
        "id": "mm22ell",
        "body": "An important distinction between game physics engines and \"serious\" physics engines used in things like professional flight simulators is that when accutate computations aren't possible game engines are allowed to \"cheat\" (e.g. if a collision between two objects causes one of them to get moved in such a way that it gets stuck within a third object, a game engine may start having one of the object teleport upward a certain amount each frame until it's not in contact with anything else), while serious physics engines would be required to stop.  Serious simulation runs showing things like Sully's \"Miracle on the Hudson\" landing stop as soon as the plane hits the water because the physics engines aren't programmed to handle the complex interactions of the airframe with the surface of the water, and it would be better to have the simulation stop than to give pilots inaccurate expectations regarding airplane behavior.",
        "author": "flatfinger",
        "created_utc": 1744129302,
        "score": 45,
        "parent_id": "t3_1juf5zj",
        "depth": 0
      },
      {
        "id": "mm2wcaj",
        "body": "Here’s a fun video about Outer Wilds and Kerbal Space Program that kind of covers this issue:\n\nhttps://youtu.be/aXQw-UVmInE?si=4eEmKC6B8L9umf8S\n\nIt mainly focuses on errors relating to floating point numbers at high distances, but I think you’d appreciate how both of these games handle their physics errors with different approaches.",
        "author": "Vortex6360",
        "created_utc": 1744137903,
        "score": 17,
        "parent_id": "t3_1juf5zj",
        "depth": 0
      },
      {
        "id": "mm2la53",
        "body": "Physics engines make a lot of non-realistic assumptions/calculations to begin with (search about the Three-body problem for an example), so a mathematical error like that rarely matters.\n\nAlso, there are (sometimes) mechanisms actively fixing potential problems or deviations anyway. For example: \n- Limiting the velocity of objects actively reduces the energy in the scene when an object reaches it\n- Collisions and friction also do that, as there's usually no sense of non-mechanical energy in games (IRL it would transform to heat, for example)\n- And any other rule you could add to keep the system \"sane\"\n\nI'm mostly commenting about energy loss there. Not because it's usually in gamedevs heads, but because it's a clear way to say: physics engines already break many physics rules, so if those numerical errors are important, you should dampen then with your own rules",
        "author": "ivancea",
        "created_utc": 1744134712,
        "score": 8,
        "parent_id": "t3_1juf5zj",
        "depth": 0
      },
      {
        "id": "mm2g139",
        "body": "There are a few ways:\n\n* Scale floating point values such that errors are not visible to the player\n* If you use iterative algorithms for performance you can warm-start the algorithm with a decent starting value. It reduces the error as well as reduce the number of iterations needed (better performance)\n* Use different algorithms for different processes. For example, you might use an iterative algorithm for force calculations (side effect is only it creates bouncy/elastic collisions), but for collision resolution of high-velocity objects, you might want to use a different solver algorithm to avoid overflows.\n* Use numerically stable calculations. Reordering variables/operators a bit in an equation can avoid error propagation and other bad things (divide by zero for example).\n* Use 64-bit floating point calculations where precision is needed and downcast to 32-bit floating points when it isn't.\n* Another trick for iterative solvers is to have a point-to-point constraint on the solution. Let's say you simulate a spring and put a heavy weight at the end of it. A few iterations in it might explode. Of course you can add more iterations to the solver, but at a certain point, it might not be able to overcome the accumulated delta. Adding a constraint that says *this body must not be more than 10 meters away from this body* will stabilize the simulation.",
        "author": "TheGenbox",
        "created_utc": 1744133265,
        "score": 7,
        "parent_id": "t3_1juf5zj",
        "depth": 0
      },
      {
        "id": "mm2xa3r",
        "body": "That's the neat part - they don't!\n\nr/gamephysics",
        "author": "MooseBoys",
        "created_utc": 1744138180,
        "score": 6,
        "parent_id": "t3_1juf5zj",
        "depth": 0
      },
      {
        "id": "mm224za",
        "body": "A really common mistake, if you use floating point computation (most do), is that adding two values of significantly different magnitude will result in big error.\n\nThis typically happens when doing a sum of many small values together, as the partial sum accumulated to a big value and now you are trying to add small values to it. Interestingly, parallelization of this sum will improve its precision as you will split it in smaller partial sums that you then add together. \n\nBut yes, precision error is tricky to deal with. There are error free ways to compute but they are not practical for most uses that require a lot of computation.",
        "author": "surfmaths",
        "created_utc": 1744129222,
        "score": 2,
        "parent_id": "t3_1juf5zj",
        "depth": 0
      }
    ],
    "1jtgdi7": [
      {
        "id": "mlu0864",
        "body": "For the fields you describe, extremely. Linear algebra is directly transferable to matrix computations, which are the basis for all kinds of data transformations and computations. It's something that is difficult at first but once you get back into it, gets a lot easier.",
        "author": "Mcby",
        "created_utc": 1744014925,
        "score": 113,
        "parent_id": "t3_1jtgdi7",
        "depth": 0
      },
      {
        "id": "mlu4yhj",
        "body": "Linear algebra is freakishly important, especially if you want to do ML work and especially if you want to do graphics work.",
        "author": "fntdrmx",
        "created_utc": 1744018141,
        "score": 54,
        "parent_id": "t3_1jtgdi7",
        "depth": 0
      },
      {
        "id": "mlucw3g",
        "body": "Personally, I relearned linear algebra just so I could get into ML and Data Science. It is worth it. Also, multivariable calculus and statistics are important for ML and Data Science, too.\n\nIf you're curious, gradient descent is an optimization algorithm. The weights and bias of the model are updated by subtracting the calculated partial derivates of the error/cost function multiplied by the learning rate.\n\nHave fun!",
        "author": "Real-Total-2837",
        "created_utc": 1744022935,
        "score": 28,
        "parent_id": "t3_1jtgdi7",
        "depth": 0
      },
      {
        "id": "mlubmoo",
        "body": "In vectors we trust.",
        "author": "Ellipsoider",
        "created_utc": 1744022228,
        "score": 25,
        "parent_id": "t3_1jtgdi7",
        "depth": 0
      },
      {
        "id": "mluuq6q",
        "body": "Let me put it in this way: all 3D graphics are pure linear algebra, with GPUs being basically CPUs optimized for linear algebra.",
        "author": "MasterGeekMX",
        "created_utc": 1744030952,
        "score": 19,
        "parent_id": "t3_1jtgdi7",
        "depth": 0
      },
      {
        "id": "mlunxlj",
        "body": "If you're interested in ML, the three most important math classes you'll take at uni are, in order, linear algebra, probability/statistics, and vector calculus. ",
        "author": "apnorton",
        "created_utc": 1744028193,
        "score": 6,
        "parent_id": "t3_1jtgdi7",
        "depth": 0
      },
      {
        "id": "mlu195d",
        "body": "Don't know how directly related this is necessarily, but I do have to use it for the computer graphics subject I am taking at the moment.",
        "author": "Plowzone",
        "created_utc": 1744015637,
        "score": 6,
        "parent_id": "t3_1jtgdi7",
        "depth": 0
      },
      {
        "id": "mludey6",
        "body": ">have learnt it before in uni but I couldn't see the real life applications and now I forgot everything 🤦🏻‍♂️\n\nI can relate to that so hard....",
        "author": "Danuz991",
        "created_utc": 1744023203,
        "score": 4,
        "parent_id": "t3_1jtgdi7",
        "depth": 0
      },
      {
        "id": "mluc0ez",
        "body": "Matrix operations are pretty useful.",
        "author": "P-Jean",
        "created_utc": 1744022442,
        "score": 4,
        "parent_id": "t3_1jtgdi7",
        "depth": 0
      },
      {
        "id": "mlv7ffm",
        "body": "It’s also basis for all 3D computer graphics.\n\nI also found it extremely hard my first class it wasn’t until my second or third class that it really started making sense.",
        "author": "solarmist",
        "created_utc": 1744035438,
        "score": 5,
        "parent_id": "t3_1jtgdi7",
        "depth": 0
      },
      {
        "id": "mlwmzx4",
        "body": "Genuinely the most applicable study of mathematics for anyone with an interest in computation, eclipsing even calculus.",
        "author": "Smart-Button-3221",
        "created_utc": 1744051192,
        "score": 3,
        "parent_id": "t3_1jtgdi7",
        "depth": 0
      },
      {
        "id": "mlz0mrx",
        "body": "Any time you translate, stretch, rotate, shear, or reflect an object in a space you’re using linear algebra.\n\nThat comes up a lot.",
        "author": "shifty_lifty_doodah",
        "created_utc": 1744080222,
        "score": 3,
        "parent_id": "t3_1jtgdi7",
        "depth": 0
      },
      {
        "id": "mlwplh1",
        "body": "It's probably one of the most useful things mathematics has produced for anything computer science related. Graphics, physics, machine learning, and, of course, just pure mathematics all have significant uses for it.",
        "author": "PierceXLR8",
        "created_utc": 1744051979,
        "score": 2,
        "parent_id": "t3_1jtgdi7",
        "depth": 0
      }
    ],
    "1js796v": [
      {
        "id": "mllm8l9",
        "body": "Any idea of \"dimensionality\" is an abstraction. Computer memory can be thought of as an address space, because that is how it is actually accessed. Memory starts at address 0, and ends at address x, where x is the size of the computers memory. The lowest level of abstraction you can have is that they are \"on a line\" aka one dimensional. If you increment the address value by 1, you go \"one address to the right\".\n\nTwo dimensional arrays is thought of as an extra level of abstraction, because if you store a 20x20 matrix, then to go one step \"down\" really just means to increment the address by 20.",
        "author": "Senguash",
        "created_utc": 1743887460,
        "score": 301,
        "parent_id": "t3_1js796v",
        "depth": 0
      },
      {
        "id": "mlll8hu",
        "body": "We address memory in a single-dimensional fashion because it’s simple. Computationally, the computer can still “simulate” other memory-access patterns",
        "author": "gboncoffee",
        "created_utc": 1743887106,
        "score": 41,
        "parent_id": "t3_1js796v",
        "depth": 0
      },
      {
        "id": "mllphc5",
        "body": "Hard disks used to be multidimensional - see CHS addressing. Cylinders heads sectors. Floppy disk addressing was 2d with tracks and sectors. It was replaced with one-dimensional addressing, after drives with more complex addressing schemes (e.g. fewer sectors on inner cylinders/tracks, or more sectors or cylinders than the limits) were _emulating_ the 3d scheme using entirely fake values.\n\nModern RAM is also multidimensional, having rows and columns with separate latency characteristics for reading from the same row or swapping rows. But it's again abstracted away.\n\nIf the different dimensions are powers of two (like in RAM) then the abstraction is even trivial - just concatenate the bits representing different dimensions and you get a single number, and vice-versa. GPUs regularly pull this trick for textures and render buffers - they're padded to a power of two line length so converting coordinates to a RAM location doesn't have to involve an arbitrary multiplication, just a concatenation.",
        "author": "TheThiefMaster",
        "created_utc": 1743888606,
        "score": 36,
        "parent_id": "t3_1js796v",
        "depth": 0
      },
      {
        "id": "mllt4yp",
        "body": "You can arbitrarily decide that the top 22 bits of a memory address are the 'z coordinate', the middle 21 bits are the 'y coordinate', and the lower 21 bits are the 'x coordinate'.\n\nIf you asked a hardware engineer to give you \"3-dimensional memory\" they would give you an interface nearly identical to that...maybe they'd split out three separate address registers rather than defining bit fields within a single register.\n\nAllocating on the heap is already slow... Imagine if, instead of finding the smallest linear region capable of accommodating your request, you had to search for the smallest unallocated cube in a 3-space instead...",
        "author": "lockcmpxchg8b",
        "created_utc": 1743889912,
        "score": 18,
        "parent_id": "t3_1js796v",
        "depth": 0
      },
      {
        "id": "mllmfxx",
        "body": "In order to index some hypothetical 2d memory, you would need 2 addresses, and X index and a Y index. Lets say they're both 16 bits long. In order to access the memory, we need to put those two addresses somewhere the memory can see. To do that we would have to move one, and then the other. This would obviously take longer than typical memory, where you only have to move a single address around.  \n  \nInstead of treating the two addresses separately, why don't we stick them together, to make a combined address that uniquely identifies any position in memory in 32 bits that can be moved around all at once .... which is exactly how a 32 bit address works. There is functionally no difference to considering a 32 bit address as two 16 bit addresses accessing 2d memory.\n\nThere isn't really any need for higher dimensioned memory. Having a single address for every single position is just much easier than having to manage multiple different addresses.",
        "author": "Peanutbutter_Warrior",
        "created_utc": 1743887532,
        "score": 8,
        "parent_id": "t3_1js796v",
        "depth": 0
      },
      {
        "id": "mlmgxxv",
        "body": "**Because multi-dimensional structures don't add more space or information.**  \nConsider this: You have four digits and a 2×2 matrix where each field can hold exactly one digit. Both systems can represent 10,000 different combinations. So from a pure information-theoretic perspective (e.g. Shannon entropy), both structures hold the same amount of information.\n\nTechnically, a matrix seems to store *more structure* rather than more information: instead of only having 2 neighbors per digit in a 1D array (left and right), a digit in a 2D matrix has up to 4 direct (orthogonal) neighbors—or up to 8 if you include diagonals. However, this increase in potential relationships doesn't increase the amount of stored information. It simply introduces a new way of interpreting the data based on spatial relationships.\n\nFor example, in image compression, we can exploit patterns like gradients or edges by storing only changes between pixels instead of raw values. Here, we gain efficiency or derive higher-level features—not because of the matrix itself, but because of how we **interpret** the spatial arrangement of data. The 2D layout supports assumptions about neighborhood correlations, but it doesn't intrinsically carry more information than a 1D layout with the same values.\n\nTherefore, from a computer science perspective, especially at the level of data representation, it doesn't fundamentally matter whether we use one-dimensional or multi-dimensional arrays. What matters is how algorithms interact with these structures. Multi-dimensional arrays are often preferred not because they store more data, but because they align more naturally with the logical structure of the problem (e.g. grids, images, matrices, etc.) and allow more efficient computation due to spatial locality and neighborhood logic.",
        "author": "Eased91",
        "created_utc": 1743898783,
        "score": 7,
        "parent_id": "t3_1js796v",
        "depth": 0
      },
      {
        "id": "mlmcjfl",
        "body": "Simple\nJust imagine every position in a memory address is a dimension . There you go",
        "author": "mauromauromauro",
        "created_utc": 1743897091,
        "score": 3,
        "parent_id": "t3_1js796v",
        "depth": 0
      },
      {
        "id": "mlmg0y6",
        "body": "Dimensions add complexity without benefit.",
        "author": "Classic-Try2484",
        "created_utc": 1743898430,
        "score": 3,
        "parent_id": "t3_1js796v",
        "depth": 0
      },
      {
        "id": "mlol5y7",
        "body": "We hope you are enjoying the course :)\n\nAs we explain in the course, memory is single-dimensional because it's just a flat sequence of addressable units, like a long row of lockers. The CPU only needs to know which \"locker number\" (address) to go to. It's simple, efficient, and fast for hardware.\n\nMulti-dimensional arrays are just an abstraction. The compiler does the math to map 2D or 3D coordinates onto that 1D space. For example, `arr[2][3]` in a 3x4 array becomes `2 * 4 + 3 = 11`.\n\nThere are more experimental ideas out there (graph memory, etc.), but traditional linear memory wins in speed and simplicity, which is why we still use it.\n\nIf you liked this part of the course, wait till you get to how hash tables works ;)",
        "author": "FerretFeisty1180",
        "created_utc": 1743937786,
        "score": 3,
        "parent_id": "t3_1js796v",
        "depth": 0
      },
      {
        "id": "mlpnl1b",
        "body": "As others have said, dimensionality is an abstraction... But there is a reason why we should interpret it as 1D and it's because it's the dimensionality of time. \n\nToday, memory works faster if you access a few continuous memory locations in sequence (a burst). This burst length keeps increasing with each generation of DDR and GDDR. So it is beneficial to access data that are next to each other (in that 1D view). But you may store a 2D array in row-major or column-major or interleaved if you want to.\n\nTypically, rectangular matrix transpose is a hard function to optimize because it singlehandedly hits all the difficult edge cases of memory access while looking simple. Funny enough, it is still a huge pain in machine learning optimization.",
        "author": "surfmaths",
        "created_utc": 1743953346,
        "score": 3,
        "parent_id": "t3_1js796v",
        "depth": 0
      },
      {
        "id": "mlruck0",
        "body": "Computer memory is 2D actually. The first axis is a byte address, the second one is a bit position.",
        "author": "rumata-rggb",
        "created_utc": 1743979006,
        "score": 3,
        "parent_id": "t3_1js796v",
        "depth": 0
      },
      {
        "id": "mlm1v0p",
        "body": "It depends how you look at it. You could equally say that a memory with 32 bits of addressing is a 32D binary array.",
        "author": "wolfkeeper",
        "created_utc": 1743893132,
        "score": 2,
        "parent_id": "t3_1js796v",
        "depth": 0
      },
      {
        "id": "mlm26nr",
        "body": "for memory, you have 1 address and you know where to go having to read 2 addresses or more...\n\nhowever having data physically stored in 3d gives you significantly more storage density",
        "author": "HandbagHawker",
        "created_utc": 1743893254,
        "score": 2,
        "parent_id": "t3_1js796v",
        "depth": 0
      },
      {
        "id": "mlm4mt9",
        "body": "It just makes things easier. If it's multi-dimensional, you have the reverse problem. You need to map a single-dimensional data objects to multi-dimensional. It actually happens in hardware. \n\nAMD's best CPUs for gaming are the 3D V-Cache CPUs (a.k.a. the X3D CPUs like the 9800X3D). 3D V-Cache is RAM that's stacked on top of each-other, making the footprint very small. There was a chance that 3D V-Cache was going to be a gimmick, but the real-world benchmark prove otherwise. \n\nMany RAM chips are 2-dimensional, having rows and columns. 3D V-Cache get a height element, but probably are abstracted. However, because of the stacking, the electrons don't have to travel as far to get to the CPU cores vs the cache being spread out. \n\nIt also turns out 3d stacking happens in SSDs as well! More of the SSD silicon can be located closer to the pins of the PCI Express interface this way.",
        "author": "fuzzynyanko",
        "created_utc": 1743894162,
        "score": 2,
        "parent_id": "t3_1js796v",
        "depth": 0
      },
      {
        "id": "mlmkof7",
        "body": "Besides what others already said, memory allocation and fragmentation problems for multidimensional structures would also become much more difficult than for a linear address space.\n\nMemory allocation in a 1-dimensional address space is finding a continuous free segment of requested size on a line. This is much more likely to succeed than finding a free rectangle of the requested dimensions in a plane or a finding a free cuboid of requested dimensions in a 3D space, which has more constraints and thus leads to more memory waste.\n\nThe amount of memory wasted by the usual first-fit or best-fit strategies will grow exponentially in the dimensionality.",
        "author": "mordoboy54",
        "created_utc": 1743900224,
        "score": 2,
        "parent_id": "t3_1js796v",
        "depth": 0
      },
      {
        "id": "mln1bys",
        "body": "\\>Why is memory single-dimensional?\n\n  \nCore memory was/is not.  It all comes down to performance and manufacturing limitations.  For IC's manufacturing multiple layers is complicated and difficult.  Furthermore, cooling multiple layer IC is also complicated and difficult.",
        "author": "OVSQ",
        "created_utc": 1743906942,
        "score": 2,
        "parent_id": "t3_1js796v",
        "depth": 0
      },
      {
        "id": "mlnbym3",
        "body": "It is one dimensional because memory addresses are just natural numbers, and you can express any number of dimensions in one dimension.",
        "author": "Legitimate_Plane_613",
        "created_utc": 1743911603,
        "score": 2,
        "parent_id": "t3_1js796v",
        "depth": 0
      },
      {
        "id": "mlsxg11",
        "body": "Mathematically any higher dimension has the exact same cardinality as the first dimension. For example, the set of all integers has the same cardinality as the set of all 2D points with integer components.",
        "author": "ESHKUN",
        "created_utc": 1743993946,
        "score": 2,
        "parent_id": "t3_1js796v",
        "depth": 0
      },
      {
        "id": "mlt5fu2",
        "body": "Try learning computer organization and architecture first and you will understand why",
        "author": "Roodni",
        "created_utc": 1743997380,
        "score": 2,
        "parent_id": "t3_1js796v",
        "depth": 0
      },
      {
        "id": "mltq1fb",
        "body": "Are you trying to play Tetris with memory management? Adding dimensions on the abstraction would just make it harder to keep memory access contiguous.",
        "author": "Fidodo",
        "created_utc": 1744008429,
        "score": 2,
        "parent_id": "t3_1js796v",
        "depth": 0
      }
    ],
    "1jrgesk": [
      {
        "id": "mlem189",
        "body": "Certain sorts, like Bucket Sort, assume you have some a priori information about the data. For example, that you know (or suspect) it is well distributed and ranges from X to Y. For example, temperatures tend to be fairly well distributed and have fairly well known ranges (with upper bounds that are sadly increasing). There is a lot of data that works this way. Even if it is not evenly distributed, if you have a priori knowledge of the likely distribution you can choose your buckets accordingly.\n\nThe principle of bucket sort is if you have an expensive sort, then it is faster to subdivide the data into many small lists and sort them; thereby, keep the value of N small for the more expensive sorts. Often, insertion sort is used, which is efficient for small values of N.",
        "author": "Magdaki",
        "created_utc": 1743787030,
        "score": 21,
        "parent_id": "t3_1jrgesk",
        "depth": 0
      },
      {
        "id": "mlenus2",
        "body": "It depends on your data distribution. Bucketsort works well for when you know the distribution of your data, whereas quicksort doesn't rely on the distribution of your data as it partitions based on comparisons, not predefined buckets.\n\nIf you know your data is only going to be integers between 0 and 999, making 1000 buckets will sort your data in linear time, as it's just a tally.\n\nSimilarly, if your data is evenly distributed and within a bounded range, e.g. floats between 0 and 1, then you can get 10 evenly distributed buckets for each 0.1, giving an advantage and you can often get closer to linear than quicksort.\n\nIf you're sorting a set of integers with no duplicates (or data with very few duplicates) then your buckets will never each be very large, thus giving an advantage.\n\nOn top of this, if you're parallelizing: after bucketing, each bucket can be sorted in parallel independently of one other.\n\n\nWhen would quicksort/mergesort etc do better?\n\nIf the data is heavily clustered or skewed, some buckets will be overloaded and others empty - thus removing bucketsort's advantage (work is not split evenly). Quicksort doesn't rely on the data's distribution or any predefined partitioning strategy, it compares things to work out how to partition.\n\nIf the data has a huge distribution of values, it's hard to work out how many buckets to use - quicksort only cares about relative order, not the magnitude, range, or distribution of values.\n\nLastly, bucketsort isn't a comparison sort so it works well on numbers that have both order and a determinable magnitude, but it won't work on any arbitrary \"comparable\" items. Quicksort only needs to know how to compare two values.",
        "author": "unsignedlonglongman",
        "created_utc": 1743787570,
        "score": 2,
        "parent_id": "t3_1jrgesk",
        "depth": 0
      }
    ],
    "1jqgyzj": [
      {
        "id": "ml6v41p",
        "body": "No. Kibibyte was specifically created to mean 1024 bytes. \n\n\nKilobyte, on the other hand, could mean either 1000 or 1024 - depending on the context. Because of this very confusion, IEC created binary prefixes (kibi-, mebi-, gibi-, etc). After that, kilobyte was officially defined as 1000 bytes.",
        "author": "RSA0",
        "created_utc": 1743683791,
        "score": 113,
        "parent_id": "t3_1jqgyzj",
        "depth": 0
      },
      {
        "id": "ml6ugj8",
        "body": "I think you are half right in a way. If I recall it correctly the \"kilo\" prefix applied to computer systems often/sometimes meant 1024.\n\n\nIt looks like kibibyte (I think the \"bi\" is probably for \"binary\") was introduced in 1998 or so to fix the problem that kilobyte could refer to 1024 bytes.\n\n\nI don't think kibi ever meant 1000 though. Just that kilo used to mean 1024 when applied to computer data, at least frequently. I remember it being a little confused and vague and some people would use both.",
        "author": "qTHqq",
        "created_utc": 1743683534,
        "score": 47,
        "parent_id": "t3_1jqgyzj",
        "depth": 0
      },
      {
        "id": "ml6u8cd",
        "body": "Recall that \n\na) kilo is the SI prefix in the metric system (which is base 10) and \n\nb) the \"bi\" in kibi is related to the \"bi\" in binary - though I am not sure exactly of the history, I can't find a reference.",
        "author": "ccppurcell",
        "created_utc": 1743683444,
        "score": 19,
        "parent_id": "t3_1jqgyzj",
        "depth": 0
      },
      {
        "id": "ml6v3uc",
        "body": "It's.. complicated\n\nIn the 90s, hard drives were getting big enough that those extra 24 bytes really added up. Hard drive manufacturers of course wanted to advertise their product as having the highest possible capacity. Since giga means billion, it technically wasn't wrong to call a billion byte drive 1GB. There were arguments in the tech media, some lawsuits that never really went anywhere, and eventually everyone just accepted that storage devices would report as smaller than expected in base 2. Then as we transitioned from dialup to broadband, ISPs realized they could use the same trick. The term kibibyte was coined later to help resolve ambiguity.",
        "author": "SirTwitchALot",
        "created_utc": 1743683789,
        "score": 8,
        "parent_id": "t3_1jqgyzj",
        "depth": 0
      },
      {
        "id": "ml6ug6i",
        "body": "There was a time where kilobyte meant 1024 (in popular culture at least) and the word kibibyte probably did not even exist.\n\nNote that what we have now is not exactly the \"opposite\" of what we had before.",
        "author": "NakamotoScheme",
        "created_utc": 1743683529,
        "score": 6,
        "parent_id": "t3_1jqgyzj",
        "depth": 0
      },
      {
        "id": "ml6yyde",
        "body": "\\> kilobyte to be 1024 bytes and a kibibyte to mean 1000 bytes\n\nIt was never this, well the second half was never this.  There was some disagreement over whether kilobyte should be 1024 or 1000, which is why the \"bi\" versions were created to represent the \"binary\" sizes, i.e., the powers of 2 to settle the matter.  It would have helped if the \"bi\" versions of the terms didn't sound so stupid.",
        "author": "ConceptJunkie",
        "created_utc": 1743685217,
        "score": 5,
        "parent_id": "t3_1jqgyzj",
        "depth": 0
      },
      {
        "id": "mlayr44",
        "body": ">I could have sworn that we learned a kilobyte to be 1024 bytes and a kibibyte to mean 1000bytes - and now I see it's actually the other way around? Is my brain just this fucked or was there a time where these two terms were applied the other way around? \n\nNo. I've been using computers since the early 70s (when my storage came in increments of 80 bytes) and kibibyte has never meant 1000 bytes.\n\nFrom at least the 70s it was common to use K for 1024, rather than the standard abbreviation of k for 1000. So 16 bit computers would be described as having a 64K address space (2^16). The binary prefix kibi was standardised by the [IEC](https://en.wikipedia.org/wiki/IEC_60027) in 1999 and has always meant 1024.",
        "author": "loafingaroundguy",
        "created_utc": 1743730937,
        "score": 4,
        "parent_id": "t3_1jqgyzj",
        "depth": 0
      },
      {
        "id": "ml6v36p",
        "body": "The bit on the JEDEC standard here (and that it's the \"customary\" convention) is the old usage I think:\n\n\nhttps://en.m.wikipedia.org/wiki/Byte#Multiple-byte_units\n\n\n\"An alternative system of nomenclature for the same units (referred to here as the customary convention), in which 1 kilobyte (KB) is equal to 1,024 bytes,[38][39][40] 1 megabyte (MB) is equal to 1024^2 bytes and 1 gigabyte (GB) is equal to 1024^3 bytes is mentioned by a 1990s JEDEC standard.\"",
        "author": "qTHqq",
        "created_utc": 1743683782,
        "score": 2,
        "parent_id": "t3_1jqgyzj",
        "depth": 0
      },
      {
        "id": "ml6vz9r",
        "body": "The base 10 came in due to IBM.  Wayyy back in the day they started redefining K to be 1000 so they can advertise larger sizes.  Now it's gotten ridiculous, and you are 100% right.  When talking about computer memory, you should reference it in base 2 where one K is 1024.\n\nIdentifying the very first advertisement that used the decimal definition of storage capacity is challenging, as this practice became widespread over time among various manufacturers. However, **IBM** was among the early adopters of this approach. In the late 1980s and early 1990s, IBM began advertising their hard drives using the decimal measurement system. For instance, their Deskstar series hard drives were marketed with capacities defined using the decimal system, which led to consumer confusion when the actual usable space appeared less than advertised.\n\n[https://www.zdnet.com/article/seagate-pays-out-over-gigabyte-definition/](https://www.zdnet.com/article/seagate-pays-out-over-gigabyte-definition/)\n\n[https://www.crn.com/news/channel-programs/189602434/western-digital-settles-hard-drive-capacity-lawsuit](https://www.crn.com/news/channel-programs/189602434/western-digital-settles-hard-drive-capacity-lawsuit)",
        "author": "DorkyMcDorky",
        "created_utc": 1743684126,
        "score": 2,
        "parent_id": "t3_1jqgyzj",
        "depth": 0
      },
      {
        "id": "ml6wfkh",
        "body": "It definitely was commonly used to refer to 1024 bytes. \n\nHere's a reddit result from a few years ago where it's referred to as such [https://www.reddit.com/r/AskComputerScience/comments/nl98vr/why\\_does\\_a\\_kilobyte\\_1024/](https://www.reddit.com/r/AskComputerScience/comments/nl98vr/why_does_a_kilobyte_1024/)",
        "author": "ooter37",
        "created_utc": 1743684296,
        "score": 2,
        "parent_id": "t3_1jqgyzj",
        "depth": 0
      },
      {
        "id": "ml6y4a6",
        "body": "To be honest, I don't recall ever seeing kibi being used anywhere except that one Wikipedia article explaining it. Everyone just uses kilo regardless of whether the mean 1000 or 1024. Sometimes, you can figure it out from context. Ram is really binary prefixes, but storage is decimal. Of course, ram and storage technology seem to be evolutionarily converging, so we can't count on that convention forever.\n\nFor end users, it doesn't matter too much. If you are using all your ram or all your storage, you will already suffer performance issues. You will want your system to have way more than 2.4% headroom. More like 20% to 50% would be better.\n\nI guess it really matters for engineers. You might need to specify exactly how much space a variable or its data type occupies. This is generally going to be a multiple of 2.",
        "author": "EarthTrash",
        "created_utc": 1743684912,
        "score": 3,
        "parent_id": "t3_1jqgyzj",
        "depth": 0
      },
      {
        "id": "ml70xqo",
        "body": "If I'm not mistaken I believe I read recently somewhere that the modern method of distinguishing between the two is to use the lower case 'k' when referencing 1000 and upper case 'K' for 1024.",
        "author": "Soft-Escape8734",
        "created_utc": 1743685937,
        "score": 2,
        "parent_id": "t3_1jqgyzj",
        "depth": 0
      },
      {
        "id": "ml7lfwu",
        "body": "It used to be that things which were organized in power-of-two arrangements adapted decimal prefixes to refer to the appropriate power of 1024 rather than powers of 1000, and things such as mass storage drives, which were organized as a linear collection of power-of-two sized chunks would use hybrid that referred to 1024 times a power-of-1000.  A so-called 1.44MB floppy held 2880 sectors of 512 bytes each.  For the most part, this style of hybrid unit until well into the twentieth century, when people started pushing for the use of kibi, mebi, etc. prefixes even though in most cases there really hadn't been that much ambiguity.  I suspect problems arose with flash-based mass-storage devices where the numbers end up being a bit fuzzy anyway.\n\nA \"32 gig\" USB drive will typically contain a flash memory chip with 67,108,864 (2\\^26) pages of 528 bytes (not 512!) bytes each, but a certain number of those pages may be defective on any given chip, and most drives will need to keep track of a fair amount of bookkeeping and wear-leveling data beyond the contents of all the data sectors, and would also need to leave a fair amount of slack space to minimize fragmentation.  Thus, a \"32 gig\" drive would typically have more than 32GiB of raw storage, but end up with less than 32GiB of usable drive capacity.",
        "author": "flatfinger",
        "created_utc": 1743692440,
        "score": 2,
        "parent_id": "t3_1jqgyzj",
        "depth": 0
      },
      {
        "id": "mlh7pmw",
        "body": "Most of the programmers would tell you that kilobyte is 1024 bytes",
        "author": "Similar_Past",
        "created_utc": 1743818693,
        "score": 2,
        "parent_id": "t3_1jqgyzj",
        "depth": 0
      }
    ],
    "1jpydd0": [
      {
        "id": "ml30rj3",
        "body": "Since L\\_N = { w | w ∈ {a, b}\\* and |w| >= 2 } is decidable (we can always determine if a string has length ≥ 2), each input has a clear accept/reject outcome with no diverging computation paths), then L\\_coN would be the complement of L\\_N, which is: L\\_coN = { w | w ∈ {a, b}\\* and |w| < 2 }. I am operating off the assumption that L\\_coN was shorthand for \"complement N\", in which that would be the language.",
        "author": "AquaticSnail",
        "created_utc": 1743625050,
        "score": 2,
        "parent_id": "t3_1jpydd0",
        "depth": 0
      },
      {
        "id": "ml3owmj",
        "body": "The key thing with the co-nondet semantics is that you can force a transition into z2 with a b, and a transition into z3 with an a. Thus, ba, bbbbbbbbba, aaaaaaba etc are all in LcoN.\n\nIf there's a `b` before an `a` in the string, it can only be processed by the machine by first moving into z2, then to z3. Whereas a string like aaaaabbbb could loop in z1 a bunch, move to z2, and loop there a bunch until the end is reached, in which the machine goes to the implicit error state.",
        "author": "dude132456789",
        "created_utc": 1743632198,
        "score": 2,
        "parent_id": "t3_1jpydd0",
        "depth": 0
      }
    ],
    "1jnz0aq": [
      {
        "id": "mkoq080",
        "body": "how did you go through all this and still forget TLS",
        "author": "SomeHybrid0",
        "created_utc": 1743429669,
        "score": 5,
        "parent_id": "t3_1jnz0aq",
        "depth": 0
      }
    ],
    "1jngz27": [
      {
        "id": "mkjo36i",
        "body": "A “buffer” is just an area of memory you put data into.",
        "author": "ThunderChaser",
        "created_utc": 1743354595,
        "score": 107,
        "parent_id": "t3_1jngz27",
        "depth": 0
      },
      {
        "id": "mkjprjs",
        "body": "A buffer is just data stored somewhere (e.g. memory) for later.\n\nLike many cases, this is a general term that is being used to mean a specific thing in this specific circumstance. In this case, the standard input is \"buffered\" so it (or some of it) is sat in memory somewhere, and scanf is reading that memory.\n\nThe problem in your code is two-fold: (1) scanf can fail to match, and (2) when scanf fails to match it does not consume the input, leaving it there.\n\nSo what's happening is that your scanf(\"%d\", ...) tries to match an integer to the start of the input, and scanf returns an integer saying how many things it matched against (in this case 0 or 1). If it fails to match, it simply returns 0 and leaves the input in the buffer, that is, the 'A' you input is still there waiting to be consumed by the next scanf. In general, scanf cannot tell you how many characters were consumed from the buffer, and so it's really hard to recover from invalid input like this. That's not a problem with buffers or your code, it's a problem with scanf really.\n\nSo what's happening is that after failing to scan the 'A', your loop then goes around, scanfs again, sees that same 'A' again, returns 0 again, and the whole program goes around in a loop like this forever. In theory, when the scanf fails to match, the choice variable remains uninitialized, and so your program has UB when it tries to access it so the fact the program is an infinite loop is more incidental than intentional.",
        "author": "lfdfq",
        "created_utc": 1743355099,
        "score": 48,
        "parent_id": "t3_1jngz27",
        "depth": 0
      },
      {
        "id": "mkjrfry",
        "body": "A buffer is just some memory that you use to temporarily store data.\n\nWith file reads and writes: you want to avoid \"talking to the OS\" (i.e. making syscalls) as much as possible because that's expensive. Say your code processes characters from a file one by one. Then you don't want to go \"hey give me one character\"...\"okay I got it give me the next one\" etc. because each of those \"question and answer\" roundtrips takes time. It's instead more efficient to say \"give me the next 256 bytes (or whatever)\", store all of those in an intermediary buffer and then work from there. Similarly with writes you want to accumulate a bunch of data and write all of that out at once.",
        "author": "SV-97",
        "created_utc": 1743355610,
        "score": 17,
        "parent_id": "t3_1jngz27",
        "depth": 0
      },
      {
        "id": "mklqv3a",
        "body": "A buffer dates back to the days when disk writing was exponentially slower than memory writing. It still is, but it was an absolute necessity early on.\n\nIt's also used any time there is latency between read and write generally or there is limited storage in your \"read space\"\n\nThe concept is that you have a very large piece of data that you want to read from one area (like a web server) and write to another (your pc). PCs can only really deal in small chunks, so you read one chunk to memory (very fast), but your disk drive isn't at the right location to write yet, so your PC will store it in a little side box, a holding queue of sorts, to be handled later. That is the buffer.\n\nBit by bit, the server hands your computer more and more chunks, and your computer assembles the final piece in the side box. Once your computer is ready to write to the final disk location (like your folder on desktop or downloads), it will save those fragments from the memory buffer onto the disk.\n\nIt doesn't even need to be completed to \"move\" (write to disk), think of it as a puzzle and your computer slowly receives pieces onto a side board and assembles them. Then periodically it will move those chunks onto a final frame, clearing out the side board for more pieces.\n\nThis style also means that the read and write don't need to be in sync in order to work and your data won't be overwritten or missing chunks at the end (asynchronous design)\n\nGraphics cards do this as well when drawing to your monitor to avoid jarring transitions and artifacting from data overlap. The GPU draws to a buffer for what your monitor should display several hundreds of times per second, then your monitor, on its own time, checks the buffer and draws that to its display.\n\nThe setting \"double / triple buffering\" for graphics cards is alluding to this. It means it is using two or three buffers to draw, so there are smoother transitions.",
        "author": "FrostWyrm98",
        "created_utc": 1743378570,
        "score": 4,
        "parent_id": "t3_1jngz27",
        "depth": 0
      },
      {
        "id": "mkl5qf7",
        "body": "I’d like to slightly expand on the definition others have provided. Using the word buffer often carries the implication that the data is being stored while in transit somewhere else. E.g. a “keyboard buffer” is the memory where keystrokes are sorted before being picked up (loosely speaking) by the CPU.\n\nC terminology often stretches this definition, as in your example.",
        "author": "thx1138a",
        "created_utc": 1743371191,
        "score": 2,
        "parent_id": "t3_1jngz27",
        "depth": 0
      }
    ],
    "1jmawcn": [
      {
        "id": "mkabi33",
        "body": "Here you go:\n\n[consensus mechanisms - Google Scholar](https://scholar.google.ca/scholar?as_ylo=2021&q=consensus+mechanisms&hl=en&as_sdt=0,5)",
        "author": "Magdaki",
        "created_utc": 1743210849,
        "score": 6,
        "parent_id": "t3_1jmawcn",
        "depth": 0
      }
    ],
    "1jlrumb": [
      {
        "id": "mk5xrr0",
        "body": "Because for most consumers, downloads dwarf uploads.  Typical consumer use is to make a small request to a server and get a large response - download a file, stream a show, whatever.  Most people don't upload large files often and when they do, often it happens as a background process (syncing Google Photos and so on).\n\nSo if there is a constrained bandwidth somewhere, it makes sense to use more of the available bandwidth for download than for upload.  This was really normal on DSL lines, so much that they tended to be called ADSL - Asymmetric Digital Subscriber Line.  Back when a DSL line could carry a few megabits, this made a large difference to user perception of the quality of the connection.\n\nAs bandwidth has gone up, this has got less common, but where I am (UK) a DSL connection with a 70Mbit download rate probably still only has 10-20Mbit upload rates, for exactly this reason - for most people, being able to download at 70Mbit instead of 45Mbit is more important than being able to upload at 45Mbit than 20 Mbit.\n\nAs fibre-to-the-premises connections have got more common, this is falling out of fashion, because the fibre link provides more bandwidth than the consumer can possibly use so there's no point making it asymmetric.  In my case, my FTTP connection is actually asymmetric the other way - it's limited to 350Mbps downlink, because that's what I pay for, but the uplink is unconstrained because most people won't hammer it so the ISP hasn't bothered to limit it.  The fibre-to-ethernet media converter is the bottleneck on the connection - I've connected a device with a 5Gbit ethernet PHY to it and confirmed that I get 5Gbps uplink and 350Mbps downlink.  Usually I only have a 1Gbps device connected to it and I get 1Gbps up / 350Mbps down.  I could pay an extra £20 per month to get 1Gbps in both directions, but there isn't much point; the WiFi conditions in my house impose more constraints than the existing 350Mbps downlink.",
        "author": "Conscious-Ball8373",
        "created_utc": 1743159894,
        "score": 70,
        "parent_id": "t3_1jlrumb",
        "depth": 0
      },
      {
        "id": "mk61acd",
        "body": "Good to see no one actually answered the question.\n\nIt's because the underlying technology favours asymmetrical speeds and most users need more download than upload.\n\nFor the first issue, the connection that provides the internet was once delivered over long strains of cable and at high speed of data transmission would interfere with other cable and even itself limiting how much data could be sent. You could get a lot going one direction but that limited what could go back. You could reduce the speed and pick up more return but that wasn't worthwhile for reason two \n\nAs an example you might send a request for a webpage. This request is small but the webpage sent back is large and all you need to do is send a few more small requests to confirm you've got it. A typical ratio of what you sent for what you get is about 1:10. This means you won't notice if your upload is only 1mbs if you have a 10mba connection.\n\nWhat about fibre?\nThe same physics limitations apply that favour asymmetrical links however they don't really kick in until well beyond what a typical home user would need for direct fibre so symmetrical connections are becoming common but the typical users data usage still has that roughly 1:10 ratio  so it doesn't actually matter. Now if everyone's actual usage changed to more high bandwidth with a 1:1 ratio prices would go up \n\nAt the aggregate link level those laws of physics matter and all the infrastructure is built around this asymmetric usage pattern. There is also one home fibre tech(gpon) which has the same limitation and that's because the fibre link is basically shared with lots of houses and the the physics that favour asymmetrical speed start to matter again.",
        "author": "morgecroc",
        "created_utc": 1743161609,
        "score": 11,
        "parent_id": "t3_1jlrumb",
        "depth": 0
      },
      {
        "id": "mk63o1q",
        "body": "Fundamentally it's because long distance transmission over copper only has a limited frequency band, and doesn't overlap frequencies between upload and download.\n\nThe specification developers _choose_ how the frequency spectrum is allocated between upload and download. For example, for ADSL, 25.875-138 kHz is used for upload, and 138-1104 is used for diwnload: https://en.wikipedia.org/wiki/ADSL#/media/File%3AADSL_frequency_plan.svg\n\nThey choose as they do because it makes the consumer device cheaper and smaller (I believe it takes more power to transmit the higher frequencies long distance) and because download is more important than upload to most consumers.",
        "author": "TheThiefMaster",
        "created_utc": 1743162681,
        "score": 5,
        "parent_id": "t3_1jlrumb",
        "depth": 0
      },
      {
        "id": "mk7ohdc",
        "body": "They could design it to be the same speed both ways, but because most people don't upload nearly as much as they download, all that extra bandwidth would be wasted.",
        "author": "VoiceOfSoftware",
        "created_utc": 1743181033,
        "score": 3,
        "parent_id": "t3_1jlrumb",
        "depth": 0
      }
    ],
    "1jlnno8": [
      {
        "id": "mk51moz",
        "body": "There is no \"simply\" when it comes to optimisation. Every program is different, and will react in different ways. The most important thing when trying to improve performance is profiling. You need to see where your program is spending the most time, and see how changes you make affect that. For toy programs you can just record the time it takes to get through each section, but you really want to use a profiler. Profiling is a whole field in itself, and does vary somewhat by language.\n\nYou are worrying about the wrong things for performance. The internals of your cpu and operating systems are unimportant for all but the most extreme optimisations. Don't worry about the scheduler, focus on the code you write. The algorithms you use are the most important thing, there is no replacement for simply doing less work for the same result.",
        "author": "Peanutbutter_Warrior",
        "created_utc": 1743140052,
        "score": 25,
        "parent_id": "t3_1jlnno8",
        "depth": 0
      },
      {
        "id": "mk56t0z",
        "body": "> I hear a lot about programs being “cache friendly.” Does this just mean maintaining a relatively small memory footprint and accessing close by memory chunks more often?\n\nPartly. When you dereference a pointer, the CPU fetches a *cache line* into the cache, which is typically 64-bytes, but size may vary. This means, if you're accessing say, an array of 64-bit values in order, when you access element `0` the CPU is actually fetching the first 8 elements, so when you access elements 1..7, you don't need a full memory lookup, but a much faster cache lookup. Additionally, if you are accessing them in sequence, the CPU can recognize the access pattern, or be given a hint, and actually prefetch elements 8..15 before you need to access them, and then elements 16..23 before you need to access them, etc. There are however, limitations to this - the CPU typically won't perform prefetching over 4ki aligned page boundaries.\n\nWhen you have some large set of data that spans over multiple pages, it can sometimes be more efficient to access the elements *out of order* - in order to minimize the cache misprediction that comes where data spans a page boundary.\n\nThere are instructions to manually provide cache prefetch hints to the CPU, but you should only do this if you know what you're doing, because misusing them can degrade performance.\n\nWhen you are accessing data structures out of order, the cache doesn't help so much - but if you access elements repeatedly in the same array, and the whole array is small enough to fit into cache - then you will usually incur some latency only the first time elements are accessed, but subsequent accesses are faster.\n\nOne goal of high performance code is to try and reduce arbitrary pointer dereferences where possible, as they can incur a cache miss. This is one reason OOP is not the best for performance - because every object is some random pointer. Game developers often avoid typical OOP styles and follow a pattern known as Entity-Component-System, which arranges data to be more cache friendly and avoid cache misses.\n\n> Does having immutable data effect this by causing fewer cache invalidations?\n\nNot strictly, but it will probably help. If data is marked `volatile`, then each write to the data will invalidate the cache entry and perform a writeback to memory. This is necessary if your data is accessed by multiple threads and written to, because each CPU core has its own L1 and L2 cache, a write from one thread is not visible to other threads until the memory writeback occurs.\n\n> Are there ways of spacing out CPU and IO bound operations in such a way as to be more beneficial for my process in the eyes of the scheduler? \n\nYes, compilers perform *instruction scheduling*, to order instructions that don't have data dependencies in a way that maximizes throughput.\n\n> In practice, if these are possible, how would you actually accomplish this in code?\n\nMost of it is automatically done by the compiler and/or CPU when you have the right access patterns over data. One thing you can do is make sure data is properly aligned in memory - because misalignment comes at a cost, and cache prefetching has limitations for page boundaries.\n\n---\n\nAside from this, the best way you can improve code efficiency as the programmer, for specific problems, is to utilize SIMD intrinsics where possible. If using Intel AVX-512 for example, you can perform operations on 8 64-bit integers or floats, 16 32-bit integers or floats, 32 16-bit integers or floats, or 64 8-bit integers in a single CPU instruction - with these SIMD instructions typically having 1/3 the throughput of ALU instructions. As an example, if doing some trivial operation on 24 64-bit values, this can be done in 3 SIMD instructions on 8 values at a time, each taking 3 cycles, for a total of 9 cycles. The ALU equivalent would be 24 ALU operations, each taking one cycle, for a total of 24 cycles.\n\nAVX-512 also has *masked instructions*, where you supply a bitmask to specify which of the elements to perform the operation on, and other elements are just copied to the destination. These can be used to speed up some problems, and can also be used in a way to reduce branches when operating on sequences. If, for example, you have an `if/else` inside a loop over an array of ints/floats where each branch just does a trivial operation, it's possible to perform this without branches, by performing the `if` branch on all elements using a bitmask, then inverting the bitmask and performing the `else` branch on all the elements. This can be faster than a branched version.\n\nThe compiler will attempt to \"auto vectorize\" some access patterns where it can, but sometimes it doesn't get the right result, and you can achieve something faster by manually using intrinsics. Best bet is put your code into [godbolt](https://godbolt.org/z/dTP9b4Es8), with `-O2` and `-march=skylake` (or whatever your CPU is) in the command line, and see what the compiler produces.\n\n---\n\nAnother small micro-optimization you can make is, if you as the programmer know whether a branch is likely to be taken or not, you can give *branch prediction hints* to the compiler/CPU. In GCC, these are typically done with a pair of macros named `likely` and `unlikely`.\n\n    #define unlikely(x) __builtin_expect(!!(x), 0)\n    #define   likely(x) __builtin_expect(!!(x), 1)\n\nYou then surround your condition on branches in `if`/`where` etc with one of these. - `if (likely(condition))` - and the compiler will arrange the labels and branches in the most optimal way, and may chose the appropriate instruction encoding to give branch hints to the CPU. On x86_64 for example, branch instructions can be prefixed with an `F2` or `F3` byte to indicate a branch taken/not-taken hint, and smart use of this can reduce the number of branch mispredictions.\n\n---\n\nFor problems where recursion is used in the solution, you can benefit greatly by using tail call optimization, which can be done with the `[[gnu::musttail]]` or `[[clang::musttail]]` attribute on a return. This prevents the stack from growing and you can have the recursion use constant space without having to manually rewrite it into an iterative solution.\n\n---\n\nOther micro-optimizations can come from understanding the CPU better - read the X86_64 manuals to see what instructions are available that aren't typically made available in programming languages. Some examples: The `andn` instruction performs `a & ~b` in one instruction rather than multiple, and can be used from GCC with intrinsics: `_andn_u64(b, a)`. (The compiler may do this for you, but some won't).\n\nThere are instructions for counting leading/trailing zeroes, and population counts, which are often absent from programming languages. GCC has `__builtin_clzll`, `__builtin_ctzll`, `__builtin_popcountll`, etc. If using `-std=c23`, these are now available as standard if you `#include <stdbit.h>`. `stdbit.h` also includes bit rotate, which is often not included in programming languages and is done using a pair of shifts with bitwise or.\n\nX86 also has some neat instructions `pdep` and `pext`, which can perform a \"parallel bit deposit/extract\", which would take multiple instructions to achieve the same thing manually. Compilers don't typically make use of these because they're very problem specific and it's hard for a compiler to detect whether it can apply these optimizations - but compilers provide the intrinscs `_pdep_u64` and `_pext_u64` to do them manually.\n\nAnother clever instruction is the `vpternlog` instruction in AVX-512, which can do things like `a & b | c` in one instruction, on multiple values at once, and it supports every possible pair of binary logic instructions (including `nor`, `nand`, `imply`, `nimply` (aka `andn`) etc - it's essentially 256 different operations combined into one instruction).\n\nI suspect the nonogram problem could benefit from using these kinds of instructions, because a black/white image can be optimized by holding it as bits, where 0=black and 1=white.\n\n---\n\nFinally, you should also familiarize yourself with the *calling convention* used on your platform. When calling functions, some values are passed (and returned) directly in registers rather than placed onto the stack. The SYSV convention for X86_64 for example, you can pass data structures <=16 bytes entirely in registers - using multiple if necessary, if they contain only int/float data.",
        "author": "WittyStick",
        "created_utc": 1743143099,
        "score": 7,
        "parent_id": "t3_1jlnno8",
        "depth": 0
      },
      {
        "id": "mk54fxq",
        "body": "It depends on *why* you're looking to optimize.  Algorithmic improvements will almost always trump system programming improvements, but there is certainly a place for bare-metal optimization (and it can be a fun hobby/toy problem to work with)!\n\n>I hear a lot about programs being “cache friendly.” Does this just mean maintaining a relatively small memory footprint and accessing close by memory chunks more often?\n\nBroadly speaking, it means accessing memory so that you don't have to invalidate a cache line.  A common example of cache-friendly vs not-cache-friendly code is the difference in processing a 2D array in row- vs. column-major order.  Locality is generally the key thing.\n\n>Are there ways of spacing out CPU and IO bound operations in such a way as to be more beneficial for my process in the eyes of the scheduler?\n\nIf, by IO-bound operations, you mean something like \"read from network\" or other operations that would happen in human-scale time, async code is useful for letting the long waits not tie up your machine.\n\nAs a general rule, the key for optimization is measurement.  If you're working with Rust, look at the [performance book](https://nnethercote.github.io/perf-book/introduction.html).  Learn how to use a profiler and [how to read a flamegraph](https://github.com/flamegraph-rs/flamegraph).  If you're working with Python, the secret is to do as little as possible in the \"Python world\" and as much as possible in precompiled binary dependencies --- [this talk is a good one](https://www.youtube.com/watch?v=vVUnCXKuNOg).\n\nUnderstanding the general idea of how a processor works, how memory is cached, etc., all help in the pursuit of optimization.  [This book](https://csapp.cs.cmu.edu/) isn't primarily about optimization, but rather about how computers work from a systems perspective.  It's pretty good if you need a deep dive into, e.g., what pipelining is at a processor level.\n\nAlso, as a general note on high-performance code, this is a pretty good resource: [https://theartofhpc.com/istc.html](https://theartofhpc.com/istc.html)",
        "author": "apnorton",
        "created_utc": 1743141669,
        "score": 3,
        "parent_id": "t3_1jlnno8",
        "depth": 0
      }
    ],
    "1jlk2d7": [
      {
        "id": "mk48o2p",
        "body": "is this roblox?",
        "author": "halllooooo3333",
        "created_utc": 1743127777,
        "score": 6,
        "parent_id": "t3_1jlk2d7",
        "depth": 0
      },
      {
        "id": "mk5tsbr",
        "body": "Nandgame.com",
        "author": "tentenfive",
        "created_utc": 1743157791,
        "score": 5,
        "parent_id": "t3_1jlk2d7",
        "depth": 0
      },
      {
        "id": "mkxtmci",
        "body": "That's so cute lol. I remember making logic gates with my friends in Minecraft. Nostalgia...",
        "author": "Younes1203",
        "created_utc": 1743549765,
        "score": 3,
        "parent_id": "t3_1jlk2d7",
        "depth": 0
      }
    ],
    "1jkir4v": [
      {
        "id": "mjvy5mv",
        "body": "If you’re interested in AI/ML/RL, check out this blurb from this year’s Turing Award Winner, Richard Sutton.\n\n[The Bitter Lesson (4 min read)](http://www.incompleteideas.net/IncIdeas/BitterLesson.html)",
        "author": "theBarneyBus",
        "created_utc": 1743017758,
        "score": 44,
        "parent_id": "t3_1jkir4v",
        "depth": 0
      },
      {
        "id": "mjvl0xk",
        "body": "Other than mine? ;P\n\nThe No Free Lunch Theorem if you're interested in machine learning.",
        "author": "Magdaki",
        "created_utc": 1743013887,
        "score": 16,
        "parent_id": "t3_1jkir4v",
        "depth": 0
      },
      {
        "id": "mjw1a11",
        "body": "I personally think Structure and Interpretation of Computer Programs by Abelson and Sussman is a must",
        "author": "GruncleStan1255",
        "created_utc": 1743018667,
        "score": 12,
        "parent_id": "t3_1jkir4v",
        "depth": 0
      },
      {
        "id": "mjwhv20",
        "body": "Joel Spolsky has a lot of sensible things to say - *Joel on Software* is a decent collection and worth a read.\n\n[How to write unmaintainable code](https://github.com/Droogans/unmaintainable-code) is entirely tongue-in-cheek but well worth looking through with a self-critical eye\n\n[Falsehoods programmers believe about time](https://gist.github.com/timvisee/fcda9bbdff88d45cc9061606b4b923ca) and [about addresses](https://gist.github.com/almereyda/85fa289bfc668777fe3619298bbf0886) are both full of wisdom that should be instigorated.",
        "author": "Conscious-Ball8373",
        "created_utc": 1743023224,
        "score": 8,
        "parent_id": "t3_1jkir4v",
        "depth": 0
      },
      {
        "id": "mjwn5sr",
        "body": "\"A Mathematical Theory of Communication\" https://people.math.harvard.edu/~ctm/home/text/others/shannon/entropy/entropy.pdf\n\nThe Graphics Gems series is good, if rather dated.",
        "author": "nanonan",
        "created_utc": 1743024725,
        "score": 5,
        "parent_id": "t3_1jkir4v",
        "depth": 0
      },
      {
        "id": "mjw9e2v",
        "body": "Gödel, Escher, Bach.",
        "author": "WE_THINK_IS_COOL",
        "created_utc": 1743020925,
        "score": 5,
        "parent_id": "t3_1jkir4v",
        "depth": 0
      },
      {
        "id": "mjxoc52",
        "body": "Check out C++ metaprogramming book written by David Abraham, its endorsed by Bjarne and it goes over plenty of functional style computations and relates real life examples to most if not all sections very valuable stuff, though you should be a little familiar with templates",
        "author": "Party_Ad_1892",
        "created_utc": 1743036729,
        "score": 3,
        "parent_id": "t3_1jkir4v",
        "depth": 0
      },
      {
        "id": "mjwd6n2",
        "body": "geb",
        "author": "krrishnix",
        "created_utc": 1743022009,
        "score": 2,
        "parent_id": "t3_1jkir4v",
        "depth": 0
      },
      {
        "id": "mjyfzqc",
        "body": "Design Patterns: Elements of Reusable Object-Oriented Software. You'll see this referred to as the gang of four design patterns books sometimes for the four authors.\n\nThe Algorithm Design Manual. I've always liked the coverage and explanations.\n\nProgramming Sucks (https://www.stilldrinking.org/programming-sucks). Because a dose of reality is important.",
        "author": "StupidBugger",
        "created_utc": 1743046992,
        "score": 2,
        "parent_id": "t3_1jkir4v",
        "depth": 0
      },
      {
        "id": "mjzulrz",
        "body": "[The Part-Time Parliament](https://lamport.azurewebsites.net/pubs/lamport-paxos.pdf) (Paxos) by Leslie Lamport\n\nOk, not every programmer, just insane ones.",
        "author": "anaptyxis",
        "created_utc": 1743075866,
        "score": 2,
        "parent_id": "t3_1jkir4v",
        "depth": 0
      },
      {
        "id": "mk0ycro",
        "body": "Both that were on my mind were mentioned of course. A mathematical theory of communication, and the bitter lesson.\n\nMaybe Gödel, Escher, Bach if you’re interested.",
        "author": "Fruitspunchsamura1",
        "created_utc": 1743089331,
        "score": 2,
        "parent_id": "t3_1jkir4v",
        "depth": 0
      }
    ],
    "1jj5dod": [
      {
        "id": "mjkmdf9",
        "body": "Cryptography and cybersecurity research continues mostly untouched by ML (so far.)\n\nI would say that research in CS goes in phases.\n\nResearchers in Knuth's era were still figuring out the basics, like sort algorithms and parsers and pathfinders. In the 80s/90s there was more research into networking protocols and compression and 3D graphics. In the early 2000s, Google and Facebook drove research into large-scale distributed systems and fault-tolerant databases. \n\nNow everybody's into ML because GPUs can run really big neural networks that do really cool things. But this too will pass, there will be other trends in the future! We just don't know what yet.",
        "author": "currentscurrents",
        "created_utc": 1742860973,
        "score": 43,
        "parent_id": "t3_1jj5dod",
        "depth": 0
      },
      {
        "id": "mjkqvqz",
        "body": ">\"My research lies at the intersection between theoretical computer science and machine learning.\"\n\nFwiw, this is often said merely because that's where the money is.  You'll frequently find people who are nominally interested in researching \"the intersection between \\[thing\\] and machine learning,\" but really their interest is in \\[thing\\].",
        "author": "apnorton",
        "created_utc": 1742862535,
        "score": 30,
        "parent_id": "t3_1jj5dod",
        "depth": 0
      },
      {
        "id": "mjkm4kw",
        "body": "All the usual big areas are still being actively researched:\n\n* Programming languages, semantics, and type systems.\n* Computation and Complexity theory\n* Computer architecture\n* Computer security\n* Information theory\n* Quantum computing\n\nMany of these areas will have some intersection with ML, because almost every part of CS has some intersection with the other parts.\n\nNo matter what's happening with ML we'll still be using programming languages for the time being, and need to compile and run programs on hardware, running software which might be wrong and that we don't trust. None of these are 'solved' problems, so at least for now they will remain active areas of research. \n\nAnd let's not forget that the biggest unsolved problem in Computer Science is still in computation and complexity theory!",
        "author": "lfdfq",
        "created_utc": 1742860888,
        "score": 31,
        "parent_id": "t3_1jj5dod",
        "depth": 0
      },
      {
        "id": "mjl00ud",
        "body": "SAT solvers are interesting",
        "author": "DeGamiesaiKaiSy",
        "created_utc": 1742865716,
        "score": 8,
        "parent_id": "t3_1jj5dod",
        "depth": 0
      }
    ],
    "1jiyqpp": [
      {
        "id": "mjj05i1",
        "body": "Data transfer rate is normally the hypothetical maximum, while throughput is the actual real rate at a given moment in time (or an average over some period). But people do misuse terms from time to time so somebody might say \"The transfer rate is varying between 1 Mbps and 2 Mbps.\"",
        "author": "Magdaki",
        "created_utc": 1742843439,
        "score": 6,
        "parent_id": "t3_1jiyqpp",
        "depth": 0
      }
    ],
    "1ji5oea": [
      {
        "id": "mjcqrrd",
        "body": "One thing to note is that the big O hides constants, so the base of the logarithm does not matter. You can change from one constant base (e.g. base e) to another constant base (e.g. base 2) by multiplying by a constant using the change of base formula. Big O notation hides constants so O(ln n) is the same as O(log2 n).\n\nIn terms of proving the complexity, you need to enforce some kind of bound on the height of the tree. Without a bound you’ll end up with linear complexity. I like [these lecture notes](https://www.cs.cmu.edu/~ckingsf/bioinfo-lectures/quadtrees.pdf) from CMU. The part that proves the depth bound is in the slide titled “Height Lemma.”",
        "author": "LemurFemurs",
        "created_utc": 1742756005,
        "score": 6,
        "parent_id": "t3_1ji5oea",
        "depth": 0
      }
    ],
    "1jhx2c6": [
      {
        "id": "mjbajn2",
        "body": "Not a book, but you might like this course from Rice uni. Downside (for some): uses java.\n\nhttps://coursera.org/learn/parallel-programming-in-java\n\nEdit: I see that the Rice class wiki has some resources (books) that you might like:\n\nhttps://wiki.rice.edu/confluence/plugins/servlet/mobile?contentId=4435861#content/view/4435861",
        "author": "DeGamiesaiKaiSy",
        "created_utc": 1742739603,
        "score": 6,
        "parent_id": "t3_1jhx2c6",
        "depth": 0
      }
    ],
    "1jh8afp": [
      {
        "id": "mj5ekc9",
        "body": "This is the Chinese Postman Problem. You can use the traditional algorithm match odd link pairs then solve with hierholzerz.",
        "author": "amazingabyrd",
        "created_utc": 1742653691,
        "score": 55,
        "parent_id": "t3_1jh8afp",
        "depth": 0
      },
      {
        "id": "mj5a5dy",
        "body": "I would have two people's walking north/south and two east/west. Have each person start at the opposite end and all meet in the middle to finish. You'll get a little overlap in paths at the end of the streets where people move to the next street but it's simple to remember and should work fine.",
        "author": "TheThiefMaster",
        "created_utc": 1742652183,
        "score": 6,
        "parent_id": "t3_1jh8afp",
        "depth": 0
      },
      {
        "id": "mj567ji",
        "body": "The solution is already discussed at length under \"the travelling salesman\" problem.",
        "author": "g105b",
        "created_utc": 1742650754,
        "score": 5,
        "parent_id": "t3_1jh8afp",
        "depth": 0
      },
      {
        "id": "mj54djg",
        "body": "All all pavements the same? Do they all need one person to walk it?",
        "author": "ehonda40",
        "created_utc": 1742650054,
        "score": 2,
        "parent_id": "t3_1jh8afp",
        "depth": 0
      },
      {
        "id": "mj550k4",
        "body": "What have you come up with so far?\nDo they need to return to the same place?",
        "author": "ehonda40",
        "created_utc": 1742650301,
        "score": 2,
        "parent_id": "t3_1jh8afp",
        "depth": 0
      }
    ],
    "1jggpq7": [
      {
        "id": "miyxzgb",
        "body": "I would recommend starting with \"The Craft of Research\". This is an excellent book for teaching how to conduct and write research. Of course, it is no substitute for graduate school or having an experienced mentor. You can see the pinned post I wrote for some idea of how CS research is conducted in a lab and how to possibly get into a research group.\n\nThe short version is this:\n\n1. Come up with an idea.\n2. Do a literature review to further refine the idea to fit a gap in the literature.\n3. Develop research questions.\n4. Develop a methodology to answer those questions.\n5. Execute the methodology.\n6. Analyze the results.\n7. Write the paper.\n\nNone of these steps are trivial, but step 7 can be particularly challenging. Writing a publishable paper is definitely not easy, and I recommend having somebody with experience to at least review/revise the paper.",
        "author": "Magdaki",
        "created_utc": 1742563635,
        "score": 17,
        "parent_id": "t3_1jggpq7",
        "depth": 0
      },
      {
        "id": "miz6xgt",
        "body": "Are you currently in school studying CS?",
        "author": "MagicalPizza21",
        "created_utc": 1742566555,
        "score": 3,
        "parent_id": "t3_1jggpq7",
        "depth": 0
      },
      {
        "id": "mj3shzp",
        "body": "REUs, as others have said, are the right place to start for undergrads at schools that don't have many research opportunities (you should still talk to some of your professors about wanting to do research, though).",
        "author": "TrafficScales",
        "created_utc": 1742622535,
        "score": 2,
        "parent_id": "t3_1jggpq7",
        "depth": 0
      }
    ],
    "1jfv1tk": [
      {
        "id": "miu30lx",
        "body": "I cannot comment on the algorithm itself. I've never done any work in prime number generation. It seems a bit too simplistic to be better than actual SOTA algorithms. I know that a lot of prime generators use a lot of very complex math.\n\nThe paper itself would likely get desk rejected. For one, there's a \\*severe\\* lack of references. The paper does not investigate the literature. There's a lack of a proof that it generates prime numbers. Table 1 make statements that are not proven. In general, there is insufficient detail. Section 6 has several applications that are described in a sentence or two. This is woefully insufficient, and this problem is present throughout the paper, for example, the conclusions are a mess. Everything is presented as a single sentence.\n\nIf you want to actually publish it, then it would need a lot of revising.",
        "author": "Magdaki",
        "created_utc": 1742494017,
        "score": 111,
        "parent_id": "t3_1jfv1tk",
        "depth": 0
      },
      {
        "id": "miu3ech",
        "body": "Typo in your abstract, you missed the O in O(N).\n\nI’m also a bit confused, you say O(N) space is inefficient (previous works) but your new solution also only reaches O(N)?\n\nAlso not my field of interest, but there’s no correctness proofs or anything?",
        "author": "EatThatPotato",
        "created_utc": 1742494127,
        "score": 38,
        "parent_id": "t3_1jfv1tk",
        "depth": 0
      },
      {
        "id": "miunf1m",
        "body": "It's an impressive piece of work for a 15 year old, but your references stopping at 2003 is my biggest concern. That's a 22 year gap! You don't need to have a huge quantity of references, but you \\_should\\_ have relevant and quality references, and this is a cutting edge area of research that would surely have a wealth of experimentation even from what you can find on Google. For all we know, you could just be re-inventing the wheel (no pun intended).\n\nThe lack of formal, rigorous proof is another concern, but you might need more training to satisfy that issue. What you could do however is add your tests to both your code base and your literature. If you can build a test script that shows that your list of generated primes exactly matches a list of primes obtained from an established algorithm, you can at least make the argument that your code is correct \\_as far as you have tested\\_.",
        "author": "aprg",
        "created_utc": 1742499893,
        "score": 34,
        "parent_id": "t3_1jfv1tk",
        "depth": 0
      },
      {
        "id": "miub1dp",
        "body": "Impressive. Especially if it's true what the other user wrote and you're still a student. Keep it up !\n\nEdit: go to college, if possible financially",
        "author": "DeGamiesaiKaiSy",
        "created_utc": 1742496323,
        "score": 10,
        "parent_id": "t3_1jfv1tk",
        "depth": 0
      },
      {
        "id": "miuyi3o",
        "body": "Your algorithm looks interesting, but I highly doubt the correctness since there is no mathematical proof of it. And your paper doesn’t reference anything tbh. But honestly,  your profile is the biggest red flag here, finding a possible cancer treatment here, a novel approach to AI modeling/learning there.  No thanks.",
        "author": "Fdffed",
        "created_utc": 1742503043,
        "score": 7,
        "parent_id": "t3_1jfv1tk",
        "depth": 0
      },
      {
        "id": "mivwout",
        "body": "Hi\nI'm not in the prime numbers field, but I have a few papers in cs. I won't comment on the correction of the algorithm, but I disagree with several points you make. For example, there are some improvements giving sieves running in sublinear time (and thus sublinear space). \n\nBesides, as other have said, a proof of correction (or at least a solid sketch of proof) is required to convince the reader that what you did is valuable.\n\nFor now, if your algorithm is correct (and original), I would categorize it as a nice mathematical curiosity, but not as something revolutionary.\n\nHowever, may that not discourage you !",
        "author": "Doryael",
        "created_utc": 1742513641,
        "score": 8,
        "parent_id": "t3_1jfv1tk",
        "depth": 0
      },
      {
        "id": "mivsz90",
        "body": "I have a similar result using k-smooth numbers. Maybe you will find it interesting. Your post and the warm reception to it give me some confidence to quickly publish what I have so far! Im just a bit older (30) but the result speaks for itself even if it'll probably take a few drafts and revisions. Combining our methods may be interesting.\n\nMy method generates approximate primes, then the local neighborhood can be Miller-Rabin'd + sieved (or AKS or whatever) to find the exact prime.\n\n\nI am still writing a paper but I have some working code, still refining it, but the proof of concept works.\n\n\nEdit: congrats on doing work like this at 15!",
        "author": "could_be_mistaken",
        "created_utc": 1742512466,
        "score": 5,
        "parent_id": "t3_1jfv1tk",
        "depth": 0
      },
      {
        "id": "miy55rl",
        "body": "Some technical issues I have with this proposal just from the implementation point of view\n\nNote that i'm not a PHD writer, though i'm a computer science graduate in software development and cybersecurity with a current focus in cybersecurity + cryptography\n\n1. Your implementation requires alot on the use of heap, especially heap in python. Is this heap generic? In that can your \"heap\" implementation within the algorithm be changed (i.e. using C's heap or rust's heap) without it affecting the overarching performance benchmarking too much, if at all\n\n2. Your sources are all way too out of date, even C is now like C22 or C23, your citations are from 2003, as others pointed out\n\n3. I noticed someone rightfully pointed out that your algorithm is O(N) which is the same as the time complexity you specified, is there a mistake in the calculation and whats the correct time complexity you found?\n\n4. Your \"proofs\" seem to claim that its somehow more efficient than eratosthenes', can this be mathematically calculatable using physical mathematics, as opposed to a general computing idea?\n\n5. Have the prime numbers generated been tested, verified to be reproducable and accurate?\n\nUntil those are answered (and unfortunately, alot more rewrites and reworking), I dont think this is applicable in any components that requires serious mathematics, especially cryptography where algorithms requiring prime numbers are usually very picky because having unstable prime number generation algorithms can mean the resulting keys are completely unstable, irregular and uncheckable and borderline random, which is unacceptable\n\nI mean, just imagine if you are using a Private Key Encryption scheme like RSA, and your definition of private and public keys are completely broken, where (alpha x beta) = value != (alpha x beta)\n\nHow would you ever hope to verify, as the private and public keys are commonly multi-digit bits length prime numbers, not some 2 or 3 digit numbers",
        "author": "Cybasura",
        "created_utc": 1742550866,
        "score": 3,
        "parent_id": "t3_1jfv1tk",
        "depth": 0
      },
      {
        "id": "mizvy46",
        "body": "OK I can't help myself. Posting under my real name because github reference. Generating prime numbers can be done really efficiently. I wrote a blocked sieve of Eratosthenes that uses O(1) storage and takes half a second to count the number of primes up to one billion and about 10 minutes up to one trillion. You can make it print all the primes but the output takes a long time of course. (OK, maybe it's O(sqrt(n)) with a really small constant, but the arrays are like 1MB because we'll exceed 64 bits before needing more than that.)\n\nIt's for fun and I use it to help teach my class on computer architecture as an example of optimizing for performance and looking at the effect of cache misses and branch mispredictions on performance. \n\nI wouldn't think of trying to publish it in the community of people who actually know anything about this because I don't. I wrote the code over 20 years ago and touched it up a little recently. See https://github.com/djimeneth/sievepi \n\nNot sure what my point is, I don't want to discourage you from trying but do want you to know that a lot of people have given a great deal of thought to this problem and it's good to read as much as you can.",
        "author": "Daniel_A_Jimenez",
        "created_utc": 1742573922,
        "score": 3,
        "parent_id": "t3_1jfv1tk",
        "depth": 0
      },
      {
        "id": "miyzcv5",
        "body": "I strongly recommend republishing with more (recent) citations and mathematical proof for your algorithm. Unfortunately, you currently have zero support for your work. Literature reviews can take 3mo-2years — their importance cannot be understated.",
        "author": "Skepay2",
        "created_utc": 1742564105,
        "score": 2,
        "parent_id": "t3_1jfv1tk",
        "depth": 0
      },
      {
        "id": "mj0j1f5",
        "body": "The complexity analysis is wrong, it assumes heap pushes are O(1), they are O(log N).\n\n\nIt also mentions Mertens' Third Theorem but actually uses Mertens' Second Theorem.\n\n\n\nIn several places there is a confusion between the order of the bound, N, and the order of the size of the bound, n = log N. A realistic value for cryptography would be n=1024, N=2^1024, not N=1024.\n\n\nThat makes this class of algorithms entirely impractical for cryptography; for scale, there are about 2^240 atoms in the universe.\n\n\nWe generate primes by testing random numbers with a fast test like Miller-Rabin, and we factor with number theoretic methods like the Quadratic Sieve or the Number Field Sieve.\n\n\nSections 6 and 7 are full of math formatting errors. They are obviously machine-generated and were not proofread.\n\n\nStrong reject with high confidence for all the reasons above.",
        "author": "Sudden_Collection105",
        "created_utc": 1742580524,
        "score": 2,
        "parent_id": "t3_1jfv1tk",
        "depth": 0
      },
      {
        "id": "mj42ihw",
        "body": "Honestly, you should probably start with a thorough review of prior work. Candidate pruning and space reduction are the two obvious things that can be optimized - heck, half the wikipedia article is on space reduction. Heaps are one of the standard data structures and I would be shocked if no one has considered them for your problem yet. For example the first Google result is this paper (https://www.cs.hmc.edu/~oneill/papers/Sieve-JFP.pdf). I would suggest you search for prior work on Google scholar and compare how they are similar or differ from your solution (if only to have other methods to compare to).\n\nAlso, I don't buy your applications - why would you need to \"discover\" prime numbers on-line for any of those? Especially if memory is constrained, shipping a cache of known prime numbers seems to be the better solution.",
        "author": "Superb-Paint-4840",
        "created_utc": 1742628887,
        "score": 2,
        "parent_id": "t3_1jfv1tk",
        "depth": 0
      }
    ],
    "1jfjirz": [
      {
        "id": "mirfo1u",
        "body": "j += i would be linearithmic",
        "author": "NikitaSkybytskyi",
        "created_utc": 1742457443,
        "score": 60,
        "parent_id": "t3_1jfjirz",
        "depth": 0
      },
      {
        "id": "mirdxt7",
        "body": "Yes, it's probably a typo. This is quadratic.",
        "author": "il_dude",
        "created_utc": 1742456297,
        "score": 49,
        "parent_id": "t3_1jfjirz",
        "depth": 0
      },
      {
        "id": "mirkxuy",
        "body": "Get a pen and paper, draw a table:\n\nFirst column: Header \"iteration,\" values 1, 2, ...\n\nSecond: Header \"i value,\" underneath 1, 2, ..., n\n\nThird: Header \"j value,\" what do you expect to see here?\n\n(This debugging technique generally helps.)",
        "author": "Individual-Artist223",
        "created_utc": 1742460973,
        "score": 10,
        "parent_id": "t3_1jfjirz",
        "depth": 0
      },
      {
        "id": "mirg8wi",
        "body": "What about the `int j = i`?",
        "author": "Alternative-Tie-4970",
        "created_utc": 1742457831,
        "score": 8,
        "parent_id": "t3_1jfjirz",
        "depth": 0
      },
      {
        "id": "mirkuw3",
        "body": "The number of operations is proportional to ½•n². Easy to visualize if thinking it as a 2D matrix where only the top-right corner is calculated. ½ is a constant, so the algorithm is O(n²).\n\n\nThat being said, it's important to not get hung up on the O notation when analyzing performance. The O notation measures \"how fast do their muscles grow\" in a contest of strength.",
        "author": "Better_Test_4178",
        "created_utc": 1742460920,
        "score": 5,
        "parent_id": "t3_1jfjirz",
        "depth": 0
      },
      {
        "id": "mj2z1qh",
        "body": "what is the name of this textbook",
        "author": "houssineo",
        "created_utc": 1742609106,
        "score": 2,
        "parent_id": "t3_1jfjirz",
        "depth": 0
      }
    ],
    "1jfh8pj": [
      {
        "id": "mitc8b3",
        "body": "Not just malware, regular companies seem to be gathering every piece of information they can legally get on you in plain daylight (as long as you consent, of course \\*wink\\*).",
        "author": "SideLow2446",
        "created_utc": 1742486318,
        "score": 6,
        "parent_id": "t3_1jfh8pj",
        "depth": 0
      },
      {
        "id": "mir1tss",
        "body": "Now I am",
        "author": "pseudomonica",
        "created_utc": 1742448822,
        "score": 2,
        "parent_id": "t3_1jfh8pj",
        "depth": 0
      }
    ],
    "1jewm2c": [
      {
        "id": "mim3s00",
        "body": "Everything should be as wired as possible. Dedicated connection vs way more unstable with WiFi and interference.",
        "author": "ImperatorUniversum1",
        "created_utc": 1742390137,
        "score": 37,
        "parent_id": "t3_1jewm2c",
        "depth": 0
      },
      {
        "id": "mim87of",
        "body": "This is irrelevant to r/computerscience \nGo bother the electrical engineers instead or something",
        "author": "fntdrmx",
        "created_utc": 1742391689,
        "score": 26,
        "parent_id": "t3_1jewm2c",
        "depth": 0
      },
      {
        "id": "mim4srt",
        "body": "I mean it's a select audience here I'd wager most people interested in computing want more ports and don't care about the wires. General public I'm not so sure.",
        "author": "Henrijs85",
        "created_utc": 1742390501,
        "score": 21,
        "parent_id": "t3_1jewm2c",
        "depth": 0
      },
      {
        "id": "mim7ipm",
        "body": "Are you sure you're studying computer science?",
        "author": "dumdub",
        "created_utc": 1742391450,
        "score": 18,
        "parent_id": "t3_1jewm2c",
        "depth": 0
      },
      {
        "id": "mimrhtj",
        "body": "I think it's an interesting question. \n\nIf I'm at my desk I like everything wired - power/hdmi/network.\n\nBut if I'm called to a meeting in another room it's great to be able to undock my laptop and take it with me,  completely cable free.",
        "author": "_oOo_iIi_",
        "created_utc": 1742397738,
        "score": 5,
        "parent_id": "t3_1jewm2c",
        "depth": 0
      },
      {
        "id": "min7xdu",
        "body": "I prefer wires when possible. I find them more reliable. I buy wired keyboards, mice, headphones, etc even if the exact same product is offered as a wireless version. I also prefer to directly power things by plugging them in over battery when possible. \n\nFor me there is almost no downside to a wire, while there is more potential downside for wireless. Wireless makes sense if you’re looking for mobility, so like taking AirPods with you in your pocket. But doesn’t make sense if you want to plug a keyboard in and leave it plugged in forever. Same goes with batteries. I want to sit down at my computer and be able to type and not have to worry about debugging a wireless connection. Even if that wireless connection works 99/100 times. I don’t want the delay for it to connect and I don’t want the 1 time it doesn’t. \n\nTo more directly answer your question. I don’t just deal with things. I seek out devices that best fit how I intend to use them (headphones for running? Wireless. Headphones for working at my desk? Wired). In general I favor wires because  wireless often leads to a worse experience. Not because I don’t “feel” in control, but because it becomes less reliable and slower.",
        "author": "WizzieXan",
        "created_utc": 1742402558,
        "score": 5,
        "parent_id": "t3_1jewm2c",
        "depth": 0
      },
      {
        "id": "mim4vzo",
        "body": "Wires are annoying, part of me wishes for the day all of my power and displays can be wireless. Then again I have 4 monitors for my home office and a ton of USB cables always on my desk. \n\nAnd I’m not a fan of wireless. ",
        "author": "alnyland",
        "created_utc": 1742390534,
        "score": 5,
        "parent_id": "t3_1jewm2c",
        "depth": 0
      },
      {
        "id": "mimt5ys",
        "body": "A wiresless connection is better for most people. It suits the needs without the hassle of a wire. For computer enthusiasts and pros, they/we prefer wires. Faster and surer data/power transfer, and the physical presence of a wire is a visual and physical indicator of what connects to what which is important when you have to manage multiple devices that do multiple different things.",
        "author": "Big-Raspberry383",
        "created_utc": 1742398238,
        "score": 3,
        "parent_id": "t3_1jewm2c",
        "depth": 0
      },
      {
        "id": "mio2u7r",
        "body": "I want wires, I hate having my devices run out of power while using them. I hate having my devices malfunction because it loses the signal.  When I sit down to use my computer I'm not moving around the room, the plug is right there, why do I need wireless?",
        "author": "pixel293",
        "created_utc": 1742411437,
        "score": 3,
        "parent_id": "t3_1jewm2c",
        "depth": 0
      },
      {
        "id": "mio6w03",
        "body": ">Does that make the experience better because we need less to do what we want? Or does it make it worse because we feel less in control of the device we're using because we can't simply plug what we need into the unit for it to work?\n\nThere is no universal \"we\".  The answers depend on who, specifically, you ask, and the situation(s) they're in.  I might feel better, or worse, with a wired connection, for very different reasons than you suggest.\n\nAs you say, each has its pros and cons.  But what's a pro in one situation may be a con in another, and vice versa.  You'll need to pin a great many things down before a valid answer even exists.  Exactly *which* things you'll need to pin down, will vary from person to person.",
        "author": "InjAnnuity_1",
        "created_utc": 1742412616,
        "score": 4,
        "parent_id": "t3_1jewm2c",
        "depth": 0
      },
      {
        "id": "miol0nr",
        "body": "There is a line you cross where the enhanced utility of a device like a phone, headphones, remote control, or a television, benefits more than the enhanced reliability of a wired connection. Wires/PCBs/other types of physical contracts are for inside devices and long distance connections for high value infrastructure like trading equipment.",
        "author": "ObjectBrilliant7592",
        "created_utc": 1742416877,
        "score": 3,
        "parent_id": "t3_1jewm2c",
        "depth": 0
      },
      {
        "id": "mirjht0",
        "body": "I'm not so sure about the framing I'm getting from this post, I don't think wires has anything to do with control over the device. What is your evidence that we desire more and more wireless devices as we use them more? \n\nWired vs. wireless is a balancing act between better convenience, latency, throughput, etc. For me personally I avoid wireless devices unless the wire gets in the way. For example I use a wired keyboard and mouse, because I'd rather deal with a bit more cables on my desk than scrounging for batteries at 3am when my mouse dies, and wireless will always have more latency than wired because the device has to do extra steps to move the signal into and out of the air. But I prefer wireless headphones when I leave the house since the wires are really annoying while moving and when taking in and out of pockets. \n\nMaybe another topic you could talk about is the development of USB-C and cable standardization. I find it amazing how a top end USBC port can be extended with an adapter into like 10 more ports. I am very glad that we are finally moving to a universal charging world, where you won't have to ask your friend what phone charger they need, or root around in the store trying to find the right cable.",
        "author": "Abcdefgdude",
        "created_utc": 1742460021,
        "score": 3,
        "parent_id": "t3_1jewm2c",
        "depth": 0
      },
      {
        "id": "minxh20",
        "body": "Is it fixed in place? I want it wired. Is it movable / mobile? I want it wired.",
        "author": "armahillo",
        "created_utc": 1742409881,
        "score": 3,
        "parent_id": "t3_1jewm2c",
        "depth": 0
      },
      {
        "id": "mio1bsx",
        "body": "The more wires lying around, the more it sort of creates a sympathetic tolerance for spaghetti code =⁠_⁠= Worse if it's in a workplace with lispers! Hahaha.. \n\nHowever, the paranoid me sort of freaks at the thought of all the radiation we must endure long-term with a bazillion wireless protocols racing about us, through us all day! \n\nThe former hints at coding horrors, the later at toasting horrors!",
        "author": "nemesisfixx",
        "created_utc": 1742410995,
        "score": 3,
        "parent_id": "t3_1jewm2c",
        "depth": 0
      },
      {
        "id": "miozfbx",
        "body": "unrelated to your question but since you're writing an essay: affect is the verb, effect is the noun.",
        "author": "radicalsapiens",
        "created_utc": 1742421180,
        "score": 3,
        "parent_id": "t3_1jewm2c",
        "depth": 0
      },
      {
        "id": "mipnk7t",
        "body": "Fewer ports just means I need more adapters/hubs/etc. My $10 wired earbuds are way better for me than expensive wireless earbuds and so for many modern devices I need an extra adapter to connect them.",
        "author": "Shot-Combination-930",
        "created_utc": 1742428895,
        "score": 3,
        "parent_id": "t3_1jewm2c",
        "depth": 0
      },
      {
        "id": "miptuel",
        "body": "One advantage people haven't mentioned - wires allow you to physically configure things. It's much easier to plug a peripheral into a computer than go through a pairing dance. \n\nI wish there were fewer types of wire though. It's annoying having dozens of different cable types. I wish things like power over ethernet or video over USB were more common to reduce the cable count.",
        "author": "Beautiful-Parsley-24",
        "created_utc": 1742431020,
        "score": 3,
        "parent_id": "t3_1jewm2c",
        "depth": 0
      },
      {
        "id": "mivvp16",
        "body": "Very, wireless stuff is too fickle due to congestion, signal strength, etc.  Leading edge technology isn't always standards compliant, while wired stuff is much more likely to be standard compliant.\n\nWired mice, keyboards, screens, networking, power, etc\n\nWireless, mobile devices, headsets, a spare keyboard if needed, mouse when traveling with the laptop.",
        "author": "dariusbiggs",
        "created_utc": 1742513326,
        "score": 3,
        "parent_id": "t3_1jewm2c",
        "depth": 0
      },
      {
        "id": "min6uha",
        "body": "> we can't simply plug what we need into the unit for it to work?\n\n\nSimply? Like how I could \"simply\" connect my Nokia N900 to the back of a CRT TV via 3.5mm to composite video?\n\n\nGuess how often I did that compared to how often I cast stuff now.",
        "author": "high_throughput",
        "created_utc": 1742402241,
        "score": 2,
        "parent_id": "t3_1jewm2c",
        "depth": 0
      },
      {
        "id": "minutwd",
        "body": "It's a very good question. \n\nWireless connections are subject to congestion and latency. That is, other wireless connections can interfere with yours. It would be insane to use wireless in a data center for example, because there's so much data flowing around.\n\nThe same is true of the hot-spots some phones offer, that let us connect our other devices to the internet through LTE or 5G or whatever cell-tower protocol our phone providers offer. If everybody watched videos all day long via 5G, it would slow down. \n\nAnd wireless connections can often be slower than wired ones. Wireless is fast enough these days that end-users don't often notice it. But it is still laggy.\n\nNetwork protocols are carefully designed, with the wisdom gained through decades of experience, to be resilient to unpredictable congestion and latency. Resiliency, though, means they don't collapse. They just slow down.\n\nAs for a sense of control over your gadgets and gizmos: I do like it that I have ethernet running from this computer to my router.",
        "author": "Aggressive_Ad_5454",
        "created_utc": 1742409107,
        "score": 2,
        "parent_id": "t3_1jewm2c",
        "depth": 0
      }
    ],
    "1jeeb97": [
      {
        "id": "mihxkct",
        "body": "If a packet needs to be retransmitted, then the game state it conveys is probably out of date.  Instead of a retransmit, it's better to just send the new state.  Using UDP essentially does this.",
        "author": "MastOfConcuerrrency",
        "created_utc": 1742328724,
        "score": 342,
        "parent_id": "t3_1jeeb97",
        "depth": 0
      },
      {
        "id": "mii9smg",
        "body": "Many really good answers. I just want to illustrate with something else. When you listen a live concert and the piano master miss a note. Do you want him to stop and take the correct note or do you want him to keep the flow? The first one is TCP, the latter is UDP",
        "author": "padreati",
        "created_utc": 1742332200,
        "score": 158,
        "parent_id": "t3_1jeeb97",
        "depth": 0
      },
      {
        "id": "mihy6sk",
        "body": "The real benefit comes from getting to choose what to retransmit.\n\n\nIf you send the player's position 10x per second and one packet drops, then TCP will stop receiving everything from everyone until it's been able to retransmit that position.\n\n\nMeanwhile the game and player don't care where the player was a second ago, they only care where the player is *now*. They would rather continue the game. Only UDP lets you do that.",
        "author": "high_throughput",
        "created_utc": 1742328900,
        "score": 101,
        "parent_id": "t3_1jeeb97",
        "depth": 0
      },
      {
        "id": "mihw0x3",
        "body": "But at that point, if it’s so accurate, with the performance negatively affected by using TCP will almost never matter. Games can stand to be a BIT laggy, but not to the extreme that it would be when using TCP. It would almost certainly be unbearable",
        "author": "cartonofmilk2057",
        "created_utc": 1742328284,
        "score": 22,
        "parent_id": "t3_1jeeb97",
        "depth": 0
      },
      {
        "id": "mihyahc",
        "body": "It depends on the game. If it's something like chess where every move is important and the state is not changing quickly, it makes sense to use TCP to ensure nothing gets dropped.  \n  \nOn the other hand, consider a racing game where the game continually sends the player's car position, speed, remaining fuel, etc. to the game server. If one of these packets gets dropped, there's no point having TCP there to re-send that packet, because by the time it does, the information in that packet has already been outdated; the car has moved. It's more efficient to just send a new packet with the freshest data and design the game to work even though some packets get dropped.\n\nMost games like FPS/racing/etc. are pretty low bandwidth so congestion control isn't as much of an issue. But the trade-off of using UDP is that if such things became necessary, the developer would have to implement them themselves rather than being able to just rely on TCP to do it for them.",
        "author": "WE_THINK_IS_COOL",
        "created_utc": 1742328929,
        "score": 10,
        "parent_id": "t3_1jeeb97",
        "depth": 0
      },
      {
        "id": "mihzgys",
        "body": "There's a variety of reasons but the main one is this:\n\nWith TCP, if a packet is dropped, all subsequent packets are delayed until the dropped packet is redelivered. This causes hundreds of milliseconds up to whole seconds of latency.\n\nWith UDP, if a packet is dropped, it's dropped. The next packet still arrives. This causes missed data but minimal latency.\n\nIn a game (or in audio/video conferencing, or really anything where you need to keep latency to a minimum), you would much rather keep getting new data, even if you have to also now try to figure out what data you've somehow missed. Latency is unacceptable in these situations.\n\nConsider video streaming, for example. If you lose a packet, you might have a corrupted frame. But 16ms later, you've moved on to the next frame. So who cares. It's much better to just drop that one frame than it is to stall the entire playback and wait for that one frame to arrive.\n\nSide note, TCP and UDP are the same speed when there's no lost packets. It's just that when you lose a packet, TCP pauses until it can fix it. This means that testing a game's network stack on a high quality local network (no dropped packets) will completely mask the difference between TCP and UDP.",
        "author": "Hixie",
        "created_utc": 1742329264,
        "score": 8,
        "parent_id": "t3_1jeeb97",
        "depth": 0
      },
      {
        "id": "mil0nr9",
        "body": "TCP:  \nServer: - I wanna send you the player state  \nClient: - I confirm I got your message you wanna send the player state.  \nServer: - I'm sending the player state.  \nClient: - I got the player state.  \nServer: - I confirm you confirmed you've got the player state.\n\nVersus\n\nUDP:  \nServer: - Here's the playerstate, do whatever you want wit..  \nServer: - Here's another playerstate.  \nServer: - And another.\n\nIt's because of speed. It reduces lag because in TCP you keep conversing back and forth about the messages meanwhile UDP dumps you multiple messages. The reason for this is that TCP guarantees you'll get the message. UDP can loose the message. But even if you lose one the client can compensate for it with interpolation. Also the authoritative server later can overwrite the state if something got lost in UDP so no biggie.\n\nEdit: also in UDP the order of the packets is not guaranteed. But the server and the client can both queue the messages is the last N timeframe, order them by time and process them in a batch.",
        "author": "PlasmaFarmer",
        "created_utc": 1742371606,
        "score": 5,
        "parent_id": "t3_1jeeb97",
        "depth": 0
      },
      {
        "id": "mijk467",
        "body": "I'd tell you why games use UDP, but you might not get it",
        "author": "Cucuputih",
        "created_utc": 1742346884,
        "score": 4,
        "parent_id": "t3_1jeeb97",
        "depth": 0
      },
      {
        "id": "mimq93d",
        "body": "Here's my take:\n\nIt's not about garbled data. Data integrity is guaranteed by both TCP and UDP. \n\nIt's not about lost packets. Unless you're in a very unreliable network, they're not that common.\n\nIt's not that much about out of order packets either.\n\nIt's because TCP and UDP are two tools for different purposes.\n\nTCP is meant to help you transfer a whole stream of data as\nfrom one point to another as fast as possible (maximize throughput). If you want to send a 1 GB file from one point of the internet to another, TCP is a very good tool.\n\nUDP is meant to help you transfer small messages from one point to another as quickly as possible (minimize latency). Most real time games benefit more from the \"messaging\" approach. \n\nMany moons ago I wrote this on stackexchange. I have some more details in there. \n\nhttps://gamedev.stackexchange.com/questions/103387/do-i-need-tcp-socket#103388",
        "author": "pandapajama",
        "created_utc": 1742397366,
        "score": 4,
        "parent_id": "t3_1jeeb97",
        "depth": 0
      },
      {
        "id": "mii12as",
        "body": "Some games use both, for different purposes of course",
        "author": "zaphod4th",
        "created_utc": 1742329714,
        "score": 3,
        "parent_id": "t3_1jeeb97",
        "depth": 0
      },
      {
        "id": "miios5v",
        "body": "Here’s a simple way to think about it. If youre sending packets that convey “current state” and knowing prior state is irrelevant, then unreliable UDP is great. For example, indicating my current game world position can go from server to client 5x/second and missing one per second may create barely visible jitter but you won’t lag behind.",
        "author": "EachDaySameAsLast",
        "created_utc": 1742336689,
        "score": 3,
        "parent_id": "t3_1jeeb97",
        "depth": 0
      },
      {
        "id": "mijmc8p",
        "body": "tcp for data integrity.  like dont do anything unless youre certain its the right thing.  udp for time sensitive applications.  like if you drop one frame move on with your life.",
        "author": "OVSQ",
        "created_utc": 1742347662,
        "score": 3,
        "parent_id": "t3_1jeeb97",
        "depth": 0
      },
      {
        "id": "mipleas",
        "body": "TCP solves a problem that games do not have (requiring all data to eventually arrive) and brings on costs that they do not want (head of line blocking and packet latency).\n\nYou can build reliability into UDP (QUIC and HTTP3 are excellent case studies here) but you can't build latency spikes out of TCP.",
        "author": "sessamekesh",
        "created_utc": 1742428179,
        "score": 2,
        "parent_id": "t3_1jeeb97",
        "depth": 0
      }
    ],
    "1jenl3g": [
      {
        "id": "mimqnzz",
        "body": "efficiency of the clock cycles are important as well, not just the speed of the cycles.",
        "author": "WiresComp",
        "created_utc": 1742397491,
        "score": 9,
        "parent_id": "t3_1jenl3g",
        "depth": 0
      },
      {
        "id": "min7oc4",
        "body": ">  By getting as much of the hardware onto a single chip as possible, the round-trip distance plummets by an order of magnitude or two allowing for at least 50-200 Ghz clock speeds.\n\nRound-trip distance isn’t the limiting factor for clock speed; it’s heat dissipation. It used to be that smaller transistors used less power (Dennard Scaling) but ~2005 we hit the limit. This is why clock speeds have stayed around 3-4Ghz for the last couple decades.\n\nWe may never have 200Ghz CPUs, at least not built out of silicon.",
        "author": "currentscurrents",
        "created_utc": 1742402485,
        "score": 7,
        "parent_id": "t3_1jenl3g",
        "depth": 0
      },
      {
        "id": "min0swl",
        "body": "Your estimate of the energy required and heat that must be dissipated is a little too simple I think. Smaller transistors can be more efficient, but with less surface area you’re going to have a proportionally harder time removing heat. At the limit of efficiency you have to contend with the thermodynamic reality that you cannot compute without making heat. There are still big gains to be had; GPUs prove this, but GPUs don’t run at very high clock speeds.\n\nAnd yes actually, there are companies making crazy big dies with GPUs and memory right on them for AI experiments.",
        "author": "joelangeway",
        "created_utc": 1742400479,
        "score": 6,
        "parent_id": "t3_1jenl3g",
        "depth": 0
      },
      {
        "id": "milvp9h",
        "body": "Interesting.\nSounds too good to work like this. \nI'm curious about the realities of things",
        "author": "nns2009",
        "created_utc": 1742387109,
        "score": 4,
        "parent_id": "t3_1jenl3g",
        "depth": 0
      },
      {
        "id": "mipgnlc",
        "body": "There is one pretty stupid thing with the 32 bit architecture and that is how much ram it can address.\n\nOne byte per address and a 32 bit address gives you 4Gb of addressable ram. While the Pentium 4 can cheat and use up to 64 gb of physical ram, each process (think of it like a single program like word or a game for simplification reasons) is limited to 4GB. Meaning no matter how “good” your fantasy cpu is it could never run a 32-bit version of Fortnite when it exceeds 4gb of ram usage because it runs out of memory addresses.\n\nThere are ways around that and some Tasks can be split in several processes but apart from some supercomputer simulations few programs are build for that. You would need to solve these issues with software like rewrites of existing programs/games you want to use.\n\n64 bit processors can theoretically address 16 exabytes of data (around 16 billion GB) but physical limits and your os will stop you sooner. Depends on the os but you are usually limited to few TB of RAM. The main point is that this issue does not exist for 64 bit systems.\n\nThat sounds really counterintuitive but think of these (unrealistic examples): a 33 bit system could address 8 gb, a 34 bit systems could address 16 gb… until 64 bit with 16 exabytes where each bit doubles the number of addresses(it can be either one or zero)",
        "author": "Old_Sky5170",
        "created_utc": 1742426640,
        "score": 3,
        "parent_id": "t3_1jenl3g",
        "depth": 0
      },
      {
        "id": "mip0irz",
        "body": "The \"`x`nm\" process doesn't actually refer to any physical feature on the die, you can't use it to derive areas etc.",
        "author": "Putnam3145",
        "created_utc": 1742421517,
        "score": 2,
        "parent_id": "t3_1jenl3g",
        "depth": 0
      }
    ],
    "1jef1en": [
      {
        "id": "mii8w4s",
        "body": "There's a few reasons for this:\n\n1. Fixed-length data is faster to process --- read 4 bytes for an IPv4 or 16 bytes for IPv6, and you've got your address.  You can even do this with SIMD-type instructions or on an ASIC, since you don't have any kind of conditional step in the code to extract the IP address. \n2. IP addresses are hierarchical --- we can use subnets to describe locality/ranges that belong to certain systems. How would a variable-length IP support subnet masks?\n3. The claim that \"addresses that take less bytes would be faster and simpler to transmit\" isn't necessarily accurate --- there's a lot of switches, routers, etc., that exist in between your source and destination machines, and each of them would need to parse/extract the new IP.\n4. Difficulties in conveying the varying length --- if you send the variable length as a size + the data, then you don't actually have an unlimited number of addresses, since the \"size\" byte (or multiple bytes!) could overflow.  If you package the variable with some kind of terminator (like you would with a string), then scanning the address requires sequential processing of each byte until you get to that terminator, which makes parallel processing of packets a *lot* more complicated (look into how JSON parsers are written with SIMD to get a glimpse of this).\n\n>I'm developing my own internet system in Minecraft, and this has been deemed preferable in that context.\n\nLikely, the \"primitive\" things you deal with in your internet system are higher-level than the building blocks of the real-life internet.  e.g. If you can specify your address as a string or an arbitrary-length integer, you're leaps and bounds higher-level than needing to specify packet headers through sequences of bytes.",
        "author": "apnorton",
        "created_utc": 1742331938,
        "score": 52,
        "parent_id": "t3_1jef1en",
        "depth": 0
      },
      {
        "id": "mii3ew0",
        "body": "Those nerds back in the day had to be smart and save memory.\n\nWe're kinda past that point today.\n\nFor IPv6, it's more like you have so many possible addresses, so it makes no sense to build some variable size jank on top of that.",
        "author": "Expensive_Rip8887",
        "created_utc": 1742330378,
        "score": 32,
        "parent_id": "t3_1jef1en",
        "depth": 0
      },
      {
        "id": "mii90f2",
        "body": "It's not just about saving memory or bandwidth.  It's also about the {speed, cost, complexity, reliability} of the switching fabric, i.e. what you can do directly in the silicon on the router.\n\nFixed length addresses are a lot easier to design fast hardware level algorithms for.",
        "author": "pconrad0",
        "created_utc": 1742331973,
        "score": 4,
        "parent_id": "t3_1jef1en",
        "depth": 0
      }
    ],
    "1jcp5jx": [
      {
        "id": "mi403ui",
        "body": "If your alphabet is {0,1}, then due to the self-loop every DFA state reachable from the initial state will contain q0. The book is listing unnecessary/unreachable states. The transformation on paper consists of the power set of the set of states, but in practice you only include those that are reachable from the initial state.",
        "author": "GrammelHupfNockler",
        "created_utc": 1742142990,
        "score": 6,
        "parent_id": "t3_1jcp5jx",
        "depth": 0
      },
      {
        "id": "mi6k4tg",
        "body": ">  I can't see any single transition that leads to both of those states? \n\nIf the NFA is in q0, and sees a 0, then it could be in q0 OR q1.  Subset-construction makes \"could be in q0 OR q1\" a single \"mega\"state in the DFA, so ({q0},0) → {q0,q1} is a transition in the DFA.\n\n> q2 has not outgoing transitions so I can't see any reason for it to be a DFA state?\n\nWell, reaching q2 is the only way to accept, so it's important there be some set containing q2 if you want your DFA to ever accept.  (Though in reality, subset construction doesn't care/realize about that; it'll just make whatever new states it likes even if they end up being \"useless\".)",
        "author": "not-just-yeti",
        "created_utc": 1742171444,
        "score": 4,
        "parent_id": "t3_1jcp5jx",
        "depth": 0
      }
    ],
    "1jcq1w7": [
      {
        "id": "mi5orj0",
        "body": "Are you sure this is actually a check digit? \n\nMost common check digits are quite simple, and your statistical methods should have been able to do much better than random. \nCan you test them against ISBN numbers or something else with a known check digit to be sure you implemented them correctly?",
        "author": "currentscurrents",
        "created_utc": 1742161053,
        "score": 10,
        "parent_id": "t3_1jcq1w7",
        "depth": 0
      },
      {
        "id": "mi524xn",
        "body": "Two ideas:\n1. There may be a basic substitution cipher applied after mathematical operations (or much worse, before, or both)\n2. It might be something like a [Cyclic redundancy check](https://en.wikipedia.org/wiki/Cyclic_redundancy_check)",
        "author": "Shot-Combination-930",
        "created_utc": 1742154229,
        "score": 6,
        "parent_id": "t3_1jcq1w7",
        "depth": 0
      },
      {
        "id": "mi7kr9j",
        "body": "You said you don't have access to the source code, but do you have access to a program that generates or verifies these? You could disassemble it.",
        "author": "trailing_zero_count",
        "created_utc": 1742185966,
        "score": 5,
        "parent_id": "t3_1jcq1w7",
        "depth": 0
      },
      {
        "id": "mi7yng6",
        "body": "Your neural network approach could have worked better if you used 10 output neurons (each outputting the probability for one digit) instead of a single output neuron.\n\nBasically, you did not give the network information that you have discrete, bounded target values instead of unbounded, continuous ones.\n\nUse softmax activation for the last layer + cross entropy loss.",
        "author": "icecubeinanicecube",
        "created_utc": 1742193813,
        "score": 3,
        "parent_id": "t3_1jcq1w7",
        "depth": 0
      }
    ],
    "1jcfwvy": [
      {
        "id": "mi21dyt",
        "body": "This is a nice small book for intro to QI & QC, before jumping into Nielsen & Chuang\n\nhttps://www.cambridge.org/core/books/short-introduction-to-quantum-information-and-quantum-computation/98A011C7874D3DF2C69B43B7ABF8EDD1",
        "author": "DeGamiesaiKaiSy",
        "created_utc": 1742111951,
        "score": 2,
        "parent_id": "t3_1jcfwvy",
        "depth": 0
      }
    ],
    "1jc4klh": [
      {
        "id": "mhzqlol",
        "body": ">Television equipment today transmits sixteen reasonably good images a second, and it involves only two essential differences from the process described above. For one, the record is made by a moving beam of electrons rather than a moving pointer, for the reason that an electron beam can sweep across the picture very rapidly indeed. The other difference involves merely the use of a screen which glows momentarily when the electrons hit, rather than a chemically treated paper or film which is permanently altered.\n\n...\n\n>**Cyclops Camera**\n\n>Worn on forehead, it would photograph anything you see and want to record. Film would be developed at once by dry photography.\n\nOld predictions of the future are always funny. They imagined the GoPro, but they imagined it would be a film camera rather than a 'television' camera.",
        "author": "currentscurrents",
        "created_utc": 1742076702,
        "score": 5,
        "parent_id": "t3_1jc4klh",
        "depth": 0
      }
    ],
    "1jblzw6": [
      {
        "id": "mhv8qni",
        "body": "When you get tired of writing all your programs in machine code and think to yourself \"What if I wrote a program to convert text descriptions of these procedures into hex codes?\" You've invented an assembler.\n\nNow your assembler is working great, but you also notice that there are certain sequences of assembly code that you use all the time. Why should you have to keep typing these out all the time? You shouldn't! So you modify your assembler to substitute a number of instructions when you type in one keyword. Congratulations! You've invented a rudimentary high level programming language. The abstractions continue from here until you end up with data science interns trying to load a 32GB hash table into memory instead of using a database and wondering why the infrastructure team hates working with them.",
        "author": "SirTwitchALot",
        "created_utc": 1742009760,
        "score": 355,
        "parent_id": "t3_1jblzw6",
        "depth": 0
      },
      {
        "id": "mhv6g3g",
        "body": "Usually you create a programming language by writing its compiler or interpreter using an existing programming language. Here's the simplified process:\n\n1. **Define the language:** Design syntax (how it looks) and semantics (what it means).\n2. **Write a compiler/interpreter:** Use an existing language like C, C++, Python, or Rust to build tools that translate your language into executable instructions.\n3. **Bootstrap your language:** Once your language is mature, you can rewrite the compiler in your own language, known as \"self-hosting.\"\n\n**But what about the very first language?**\n\n  \nEarly computers didn't have programming languages—they were programmed directly using machine instructions (binary or assembly). The first higher-level languages (like Fortran in the 1950s) were created by manually coding compilers in low-level assembly or machine code, effectively bootstrapping all subsequent programming languages.",
        "author": "Dismal-Detective-737",
        "created_utc": 1742008791,
        "score": 72,
        "parent_id": "t3_1jblzw6",
        "depth": 0
      },
      {
        "id": "mhv6xie",
        "body": "You design the language first, on paper or whatever.\n\nThen you write a compiler for it, if you don't have another language available, you write it in machine code.\n\nThe first programming language would have been designed on paper, likely, and a compiler written in machine code.",
        "author": "ToThePillory",
        "created_utc": 1742008990,
        "score": 30,
        "parent_id": "t3_1jblzw6",
        "depth": 0
      },
      {
        "id": "mhvokeg",
        "body": "[https://craftinginterpreters.com/](https://craftinginterpreters.com/)",
        "author": "baseombra",
        "created_utc": 1742017535,
        "score": 14,
        "parent_id": "t3_1jblzw6",
        "depth": 0
      },
      {
        "id": "mhv9xbt",
        "body": "> How was the first programming language created?\n\nFor the earliest computers, you rewired them to change the program. ENIAC, in its final form, had rows of switches to input programs. *Much* later, the Altair 8800, the first commercially-successful personal computer, had switches on the front to input instructions one at a time.\n\nIn those cases, you'd hand-convert assembly-language representations of code into machine code, and input individual instructions into the computer (using whatever physical interface the computer provides; switches, wires, plugboards).\n\nAs far as interpreting the data that you're inputting as instructions, that's the nature of a CPU; it's physically constructed to fetch, decode, and execute instructions encoded in a way specific to that type of CPU.",
        "author": "khedoros",
        "created_utc": 1742010324,
        "score": 10,
        "parent_id": "t3_1jblzw6",
        "depth": 0
      },
      {
        "id": "mhvgje3",
        "body": "When implementing a language, yes you will almost certainly used an existing language. But I think it’s also important to make a distinction between between a programming language as a mathematical construct and its implementation \n\nFirst and foremost, a language is a piece of mathematical formalism. It is pure syntax. A language, such as Python is not just an executable on your machine. Python is a language, and this language has formal terms, very similar to mathematical logic. Similarly, Python terms are expected to obey certain equalities constraining their behavior. \n\nFor instance, “print(arr[0])” and “arr[0] = 1” are each just valid Python expressions, and we would expect that “print(1)” and “arr[0] = 1 ; print(arr[0])” to represent (roughly) equivalent programs. (I’m waving my hands a bit because of side effects like mutable state and printing)\n\nDefining a language as syntax in this way doesn’t really tell you that much, it merely gives you the vocabulary to write expressions. To make something useful, we have to give these symbols meaning! To achieve this, we give a programming language formal semantics\n\nThe most common avenue in this vein, especially when choosing to implement a language, is to give it operational semantics. I recommend search a bit and giving this topic a closer reading, but the tldr is that operational semantics give a mathematically precise way to evaluate a program one step at a time. \n\nUp until now, everything I’ve said is the programming language defined solely mathematically “on paper”. To actually write a program that implements this language, you would then encode the semantics that you define in some other language. For instance, you could use C to implement Python.",
        "author": "winniethezoo",
        "created_utc": 1742013356,
        "score": 5,
        "parent_id": "t3_1jblzw6",
        "depth": 0
      },
      {
        "id": "mhvhv62",
        "body": "Logic gates, and compiler construction, one of the first programming languages was fortran, programming languages influenced new ones. Theoretical computation is the study of making new languages, it requires logic gates and truth tables, languages share similarities with each other but have different syntax and structures",
        "author": "burncushlikewood",
        "created_utc": 1742014012,
        "score": 3,
        "parent_id": "t3_1jblzw6",
        "depth": 0
      },
      {
        "id": "mhvmkrh",
        "body": "if you're comfortable with java and C, you can try out the book \"Crafting Interpreters\". I loved this book as an introduction to this topic.",
        "author": "Kindly_Commercial476",
        "created_utc": 1742016443,
        "score": 2,
        "parent_id": "t3_1jblzw6",
        "depth": 0
      },
      {
        "id": "mhwfo3g",
        "body": "Just to add, I've seen crafting interpreters recommendations which I heavily agree with. But also if you want to get a deep understanding of what your programming language eventually compiles down to on a gate level I followed the free course from nand to Tetris and it helped with so many CS modules for me",
        "author": "shootersf",
        "created_utc": 1742034727,
        "score": 2,
        "parent_id": "t3_1jblzw6",
        "depth": 0
      },
      {
        "id": "mhwgjry",
        "body": "I was about to recommend reading about flex and bison. But this article is quite interesting and recommend not to use them anymore [link](https://tomassetti.me/why-you-should-not-use-flex-yacc-and-bison/)\n\nGosh, I feel very old now, thank you.",
        "author": "ChangoMandango",
        "created_utc": 1742035249,
        "score": 2,
        "parent_id": "t3_1jblzw6",
        "depth": 0
      },
      {
        "id": "mhwm0od",
        "body": "I've done a few languages for translators and interpreters. \n\nIt's good to familiarize yourself with the fundamentals, how the semantic analysis, tokenization, abstract syntax trees, etc., work is good. But whether attempting to roll your own implementation of any of those is anything but an exercise in writing spaghetti, I'm not sure.\n\nWhen you know about those things, you can use a parser generator to define your language in terms of lexical and parser rules, then you generate the AST and implement whatever you want your parser to do.\n\nIf you don't want to use a parser generator: Great, you want to solve a problem other smart people have already solved. Deal with your own spaghetti, is all I'll say.",
        "author": "Expensive_Rip8887",
        "created_utc": 1742038371,
        "score": 2,
        "parent_id": "t3_1jblzw6",
        "depth": 0
      },
      {
        "id": "mhxgoiu",
        "body": "The computerphile youtube channel posted a video about that, you should take a look.  \n[https://www.youtube.com/watch?v=Q2UDHY5as90](https://www.youtube.com/watch?v=Q2UDHY5as90)",
        "author": "Wonderful-Guard-1348",
        "created_utc": 1742050677,
        "score": 2,
        "parent_id": "t3_1jblzw6",
        "depth": 0
      }
    ],
    "1jbv5rl": [
      {
        "id": "mhx6ar8",
        "body": "Tasks like a lot of sequential math don't parallelize well and don't necessarily need to access memory, and so are mostly limited by single-core performance. Processes that deal with a lot of I/O, like rendering images and video, need to access a lot of memory, but may or may not parallelize well. The optimal multi-threaded task is one that needs to run a lot of computation in chunks that don't depend on one another and rarely need to access memory so they aren't competing for RAM bandwidth. Which should be prioritized depends on the role of the system: a home PC, a server, and a super-computer are going to see different workloads and often have slightly different hardware to match.",
        "author": "nuclear_splines",
        "created_utc": 1742047123,
        "score": 2,
        "parent_id": "t3_1jbv5rl",
        "depth": 0
      }
    ],
    "1jb0upr": [
      {
        "id": "mhqhinb",
        "body": "First, open to the table of contents.\n\nETA: I’m going to guess it’s based on outdated directX and/or openGL libraries for windows. What’s the print date on this text?",
        "author": "telesonico",
        "created_utc": 1741954625,
        "score": 42,
        "parent_id": "t3_1jb0upr",
        "depth": 0
      },
      {
        "id": "mhqhlu6",
        "body": "Open it up to see, it's useful is subjective but it's likely outdated but could be interesting",
        "author": "paroxsitic",
        "created_utc": 1741954662,
        "score": 11,
        "parent_id": "t3_1jb0upr",
        "depth": 0
      },
      {
        "id": "mhsiz92",
        "body": "I would not spend time with this textbook outside of novelty or curiosity.\n\nIt does depend on what your specific interests and goals are. If you want to *just learn something*, then sure, virtually any book can offer that. If you are interested in graphics programming and want to become an effective graphics programmer, then I would suggest a more modern book or resource.",
        "author": "Beardiest",
        "created_utc": 1741977488,
        "score": 3,
        "parent_id": "t3_1jb0upr",
        "depth": 0
      }
    ],
    "1jb230n": [
      {
        "id": "mhqrvl8",
        "body": "We have an on premise GPT, that has been trained with our in house business documentation, relevant law, etc. and is disconnected from the internet.\n\n\nI am allowed to use that with no regards to, what I’m using in my prompts. \n\n\nI also have GitHub Copilot in IntelliJ and VS Code. When using that, there are rules about what I can use in prompts. No trade “secrets”, no GDPR sensitive data, etc.\n\nAll employees have an MS 365 Copilot access, to be used with the same considerations \n\nIn general we’re very much encouraged to learn how to use GenAI as a tool (to improve efficiency of cause).",
        "author": "pertdk",
        "created_utc": 1741958472,
        "score": 9,
        "parent_id": "t3_1jb230n",
        "depth": 0
      }
    ],
    "1jaoyu1": [
      {
        "id": "mhnjjxp",
        "body": "I found this going through the [talk page](https://en.wikipedia.org/wiki/Talk:Magic%20cookie) of the relevant Wikipedia article:\n\n\n> Once upon a time, I asked Dennis Ritchie about the origin of the term magic cookie as used in the man page for ftell and fseek in the C library.  He said that, so far as he knew, the usage in that man page was a new coinage.  That man page is not present in V5 UNIX but it is present in the manuals for V7 UNIX and 4.2BSD.  I have quoted the relevant sentence from that manual on the Wikipedia page; the wording makes it clear that the meaning is the same as the contemporary meaning for magic cookie (in the broader sense than HTML cookie).  Any speculation about derivation from cookie monsters or LSD cookies seems, at this point, irrelevant compared to tracking down the first use of the term in its modern sense. Douglas W. Jones (talk) 21:15, 24 February 2017 (UTC)\n\n\nIt sounds like to get your answer you’d have to find whoever wrote this man page. ",
        "author": "josephjnk",
        "created_utc": 1741907013,
        "score": 29,
        "parent_id": "t3_1jaoyu1",
        "depth": 0
      },
      {
        "id": "mhni18i",
        "body": "The sad truth is that nobody knows",
        "author": "Zarathustrategy",
        "created_utc": 1741906538,
        "score": 12,
        "parent_id": "t3_1jaoyu1",
        "depth": 0
      },
      {
        "id": "mhocrbn",
        "body": "That is one of the great mysteries of our small civilization.",
        "author": "Effective_Youth777",
        "created_utc": 1741916564,
        "score": 7,
        "parent_id": "t3_1jaoyu1",
        "depth": 0
      },
      {
        "id": "mhpzcud",
        "body": "Before the internet arrived, we called magic cookie to whatever random value you were using as a watermark. For instance, if you needed to define an ID for your custom binary file format, you started the file using the hex value 0xCACAFACE and in the code that constant (a #define) was a magic cookie because you didn't care about the value itself you only needed it to be always the same and having it unleashed the magic behind it. But take as valid the other answers that did some actual investigation.",
        "author": "riotinareasouthwest",
        "created_utc": 1741945573,
        "score": 5,
        "parent_id": "t3_1jaoyu1",
        "depth": 0
      }
    ],
    "1jaozn4": [
      {
        "id": "mhnja6w",
        "body": "Are you asking what real-world things graph theory is used for? In that case, some easy answers: compilers, networking (routing), machine learning, and maps (e.g., google maps).",
        "author": "cachehit_",
        "created_utc": 1741906929,
        "score": 29,
        "parent_id": "t3_1jaozn4",
        "depth": 0
      },
      {
        "id": "mhnnw6b",
        "body": "If you swap out the term \"graph theory\" with \"networks,\" you might see a lot more practical applications. \n\nMany data structures store data in ways that are easily descibed as *graph* structures. Wherever you have a structure that is hierarchical, nested, or connected, you can represent it as a graph. Social networks are graphs. The basics of graphs involve checking connections (are you friends?), directedness (I follow Sue, but does Sue follow me?), and weightedness (how many messages do these two nodes/people exchange).\n\nI'm learning about graph algorithms now and am amazed at how much these ideas generalize to various programming topics.",
        "author": "BrupieD",
        "created_utc": 1741908383,
        "score": 16,
        "parent_id": "t3_1jaozn4",
        "depth": 0
      },
      {
        "id": "mhog9no",
        "body": "I think it’s important to realize that graphs are very, very general mathematical structures. Other people mentioning applications where graphs are usually applied (networks, etc.) but those are well known because graph algorithms apply well in those domains.\n\nBut graphs are super general. It is a set of unique—or non-unique— elements with relationships between none, some, or all of them.\n\nTake permutations of 3 digits (000, 123, 574, etc.) If “adjacent” elements means one digit changes (e.g 000 is adjacent to 001, 010, etc.) and you then draw it out…you get a pretty cool graph! It forms kind of a honeycomb. Assuming modulus, it wraps around too. This doesn’t mean that people usually think of graphs first when discussing permutations, but enumerating permutations could easily be seen as a graph traversal problem if you describe it in this way. \n\nI guess what I’m saying is, when people talk about “real-world” uses of graph theory they tend to lean on domains where graph theory is *visually* obvious (a social network) or where graph theory was famously used to solve a hard problem (fingerprint identification). But don’t let that fool you. Graphs are everywhere. Anything can be described as graph. As long as there is a set of elements and some way of describing a relationship between those elements.\n\nEDIT: fixed some wording",
        "author": "a_cloud_moving_by",
        "created_utc": 1741917760,
        "score": 8,
        "parent_id": "t3_1jaozn4",
        "depth": 0
      },
      {
        "id": "mho1uod",
        "body": "If you can’t directly model your problem in terms of paths, matchings, flows, trees, independent sets, dicuts, etc, then you can still probably define your problem as a linear program where the skeleton of the constraint polytope forms a graph and following edges to an optimal node is the simplex method. \n\nEven if you have an NP-Complete problem that isn’t naturally a graph question then there are countless polytime reductions to any other NPC graph problem. Presumably the same works for reductions between NP-Hard problems generally. \n\nWhether this is a useful view point really depends on the problem.",
        "author": "beeskness420",
        "created_utc": 1741912883,
        "score": 4,
        "parent_id": "t3_1jaozn4",
        "depth": 0
      },
      {
        "id": "mhnqard",
        "body": "Check Newman's Networks book.",
        "author": "neuralengineer",
        "created_utc": 1741909146,
        "score": 4,
        "parent_id": "t3_1jaozn4",
        "depth": 0
      },
      {
        "id": "mho3wui",
        "body": "Graphs are used all over the place! Recommendation algorithms, ecology, ontologies, traces of human collaboration (for example, you can view git commit histories as bipartite graphs of contributors and files they've modified, or you can view chess tournaments as directed graphs of players defeating other players), belief networks, constraint satisfaction in governance, mobility data (for everything from urban planning to public health to archaeology), and much more! Network science is an interdisciplinary field that interacts with a wide array of other academic disciplines.",
        "author": "nuclear_splines",
        "created_utc": 1741913554,
        "score": 3,
        "parent_id": "t3_1jaozn4",
        "depth": 0
      },
      {
        "id": "mhon3za",
        "body": "In undergrad I did research on studying cascading failures in power grid networks (which were just weighted directed graphs).",
        "author": "Character_Cap5095",
        "created_utc": 1741920158,
        "score": 3,
        "parent_id": "t3_1jaozn4",
        "depth": 0
      },
      {
        "id": "mhofoyz",
        "body": "Traveling Salesman is NP-complete. Therefore, almost any computational problem should be able to be transformed into a graph theory problem...",
        "author": "Historical_Cook_1664",
        "created_utc": 1741917561,
        "score": 2,
        "parent_id": "t3_1jaozn4",
        "depth": 0
      },
      {
        "id": "mhs06bc",
        "body": "Social network analytics and computational social science.",
        "author": "No-Treat6871",
        "created_utc": 1741971775,
        "score": 2,
        "parent_id": "t3_1jaozn4",
        "depth": 0
      }
    ],
    "1jafwbw": [
      {
        "id": "mhl8t4n",
        "body": "This AMA is mod-approved so you don't need to report it.",
        "author": "Magdaki",
        "created_utc": 1741883351,
        "score": 6,
        "parent_id": "t3_1jafwbw",
        "depth": 0
      },
      {
        "id": "mhl7a8z",
        "body": "View in your timezone:  \n[today 12pm PT][0]  \n\n[0]: https://timee.io/20250313T1900?tl=AMA%20with%20Stanford%20CS%20professor%20and%20co-founder%20of%20Code%20in%20Place%20today%20%40%2012pm%20PT",
        "author": "timee_bot",
        "created_utc": 1741882918,
        "score": 2,
        "parent_id": "t3_1jafwbw",
        "depth": 0
      }
    ],
    "1j9kfyz": [
      {
        "id": "mhdw435",
        "body": "I've recently been hired as a professor so I will be doing less direct research soon; however, I can tell you about my pre-faculty life.\n\nIt depends on the phase of the research. The TL;DR is a lot of reading and writing. When you first get into research, you'll need to develop some ideas. These will usually come from your supervisor; however, it does not take long before you have more ideas then you know what to do with. I have ideas that could cover several years of research, and I've probably forgotten plenty.\n\nOnce you have a basic idea (or select one from your backlog), then you develop a research proposal. This means reading the literature and identifying how your idea fits into the literature. It has to fit into a gap. So you might need to refine the idea to make it fit. For example, I had an idea about 8 years ago, and I was going to start working on it when I discovered somebody did it in 2021. So now, I need to refine that based on what they've done. The research proposal should outline everything you plan to do do, how you will do it, etc.\n\nThen you execute the proposal. This is where you write the code, and run it. But really, this often doesn't take that much time. At least not at first. But you might need to refine things if it isn't working very well. Also, how much time it takes depends on the complexity. For example, one of the things I'm working on is a modified genetic algorithm. This has been taking a lot of time because it is very complex. But the research on automatic grading of exams was pretty quick.\n\nThen you write one or more papers. This takes quite some time. Writing a publishable paper is not as easy as people think. At least if you want it published in a high-quality journal/conference. It is not that hard to get published in lower quality journals/conferences (and trivial in predatory ones, your payment needs only clear), but they don't really help your career much. On your CV, you will need to put the impact factor or acceptance rate of where you've published, and if they are not good, then this suggests your research isn't good, which means you are less employable. \n\nFor this reason, I strongly recommend against using AI tools to \"help\" with research. I've seen plenty, and the research quality is almost always low (and that's not taking into consideration the rise of crackpot research that has been facilitated by AI tools). Same with AI writing. The level of quality is fine for an undergraduate level assignment (although most schools consider this academic misconduct), but for publication I would recommend against it. Research is about learning and thinking, and so you really cannot outsource this if you want to be successful. There is a case to be for AI tools to help when there are language barriers.\n\nIf you have any follow up questions, feel free to ask.",
        "author": "Magdaki",
        "created_utc": 1741787907,
        "score": 34,
        "parent_id": "t3_1j9kfyz",
        "depth": 0
      },
      {
        "id": "mhgf2xf",
        "body": "Day to day is preparing lectures and doing menial admin tasks while planning all the research you will do when you find the time, which of course never happens.",
        "author": "Fresh_Meeting4571",
        "created_utc": 1741814560,
        "score": 7,
        "parent_id": "t3_1j9kfyz",
        "depth": 0
      },
      {
        "id": "mhgmg6z",
        "body": "I am currently a PhD student doing theoretical Comp Sci research. Practically my research is more similar to Math than it is to software engineering (I haven't written a line of code in over a year). However I am the exception, and I personally know many researchers developing great tools. I also know there is a lot of research being done in industry as well, though you may need a higher education in order to break into that market. \n\nDay to day, when researching I am reading papers, working on proofs or writing up said proofs. Other things I do involve going to seminars/ guest speakers which are tangentially related to my work, grading/TAing for classes, meeting with my advisor, ect...",
        "author": "Character_Cap5095",
        "created_utc": 1741816702,
        "score": 6,
        "parent_id": "t3_1j9kfyz",
        "depth": 0
      },
      {
        "id": "mhthjyb",
        "body": "Current PhD student doing RL and robotics. Day to day I’m mostly reading papers and trying to implement different algorithms I read about. Once I have a direction for a paper, I’m running experiments and refining/thinking about whatever approach we are developing based on the results.",
        "author": "Just_a_nonbeliever",
        "created_utc": 1741987642,
        "score": 2,
        "parent_id": "t3_1j9kfyz",
        "depth": 0
      }
    ],
    "1j8q0xv": [
      {
        "id": "mh72ulc",
        "body": "Typically via an interrupt. On Linux for example a system call is performed via interrupt `0x80` with a register set to the syscall number and the other registers set to the syscall’s arguments. Once that occurs the CPU jumps to the interrupt handler (which is kernel code) and the kernel services the syscall before handing control back over to the process. \n\nTypically the kernel is always loaded in the virtual address space so the CPU can always jump into kernel code, a common design is known as a “higher half kernel” where the lower half of the virtual address space is useable by the process and the upper half is reserved solely for the kernel and can’t be accessed by a userspace process. \n\nx86_64 nowadays has a special `syscall` induction which is used over the older interrupt approach, but the general concept is the same.",
        "author": "ThunderChaser",
        "created_utc": 1741698318,
        "score": 51,
        "parent_id": "t3_1j8q0xv",
        "depth": 0
      },
      {
        "id": "mh78j10",
        "body": "There is a special register in the cpu that holds the memory location of the kernel code that handles system interrupts. This register will be filled once the kernel is loaded into memory on boot. There are also other registers that are filled before the interrupt to store the requested interrupt type and context. A system interrupt is just a basic cpu instruction that will make the execution flow jump to the kernel code that handles the interrupt.",
        "author": "kleiner_schussel",
        "created_utc": 1741700294,
        "score": 5,
        "parent_id": "t3_1j8q0xv",
        "depth": 0
      },
      {
        "id": "mh74ga3",
        "body": "Normally interrupts.",
        "author": "tcpukl",
        "created_utc": 1741698895,
        "score": 2,
        "parent_id": "t3_1j8q0xv",
        "depth": 0
      },
      {
        "id": "mh7c13t",
        "body": "Via kernel traps. When a process in user mode attempts to perform a privileged instruction (for example, requesting a page that is not physically present in ram) the memory controller will emit a trap which the hardware will suspend the execution context of the user process to the data structure used by the kernel for tracking processes. The kernel then decides what to do with the process (update the memory mapping or terminate the process)",
        "author": "N0Zzel",
        "created_utc": 1741701430,
        "score": 2,
        "parent_id": "t3_1j8q0xv",
        "depth": 0
      },
      {
        "id": "mh9a3bc",
        "body": "Here, this video by the godsent YT channel \"Core Dumped\" explains that really well: https://youtu.be/H4SDPLiUnv4",
        "author": "MasterGeekMX",
        "created_utc": 1741721604,
        "score": 2,
        "parent_id": "t3_1j8q0xv",
        "depth": 0
      }
    ],
    "1j8b06a": [
      {
        "id": "mh3ocfk",
        "body": "You can build an IDE in any language. And you can build it using the previous IDE. At some point the new one is good enough to start using to code itself. \n\nBut how about the first one?\n\nDone with a standalone text editor. As is much of coding today. Notepad++, BBEdit, VS Code, vim, etc…\n\nHow about those? Back in the day?\n\nPunch cards.",
        "author": "DrFloyd5",
        "created_utc": 1741645054,
        "score": 155,
        "parent_id": "t3_1j8b06a",
        "depth": 0
      },
      {
        "id": "mh3p2dw",
        "body": "It depends on the IDE. Eclipse, for example, is itself written in Java, as is IntelliJ.\n\nThe thing that compiles the IDE is the compiler. All the IDE does is configures the build for you; it just feeds the compiler the right commands to make it compile your code correctly. (Sometimes the IDE doesn't even do that and relies on another system (like Maven/Gradle for Java) to mess with the compiler. This is actually preferable as you don't lock project contributors to a specific IDE.)\n\nWhat is the compiler written in? For some languages, like Python and Java, it's a lower-level language, like C or C++. For C/C++, the compiler is also written in C/C++, and so you use the previous version of the compiler to compile new versions. This goes all the way back to the first compilers, which were written in assembly.",
        "author": "ChickenSpaceProgram",
        "created_utc": 1741645274,
        "score": 39,
        "parent_id": "t3_1j8b06a",
        "depth": 0
      },
      {
        "id": "mh46si3",
        "body": "> what language is the IDE created in\n\nAny language you want.\n\n> And what compiles the IDE software?\n\nA compiler.\n\nI have a feelin you're confusing several things, so lets be clear. A compiler is a program that transforms structured code (a programming language) into binary code.\n\nAn IDE is a program that packages together multiple tools that are useful to people when writing code into a single program. So at its core, an IDE is basically a text editor with lots of bells and whistles. So, like, you can press the button in your IDE that will run the compiler on your current project and that saves you from having to open up a terminal window and running the compiler directly.\n\nIt *is* an interesting question about what language compilers are written in. Typically you start out writing the compiler in a different language. So the compiler for the language Rust was written in OCaml. It took in Rust code and then outputted binary. Then, someone wrote a compiler in Rust, compiled it with the OCaml compiler, and now you have a compiler for Rust written in Rust. The process is called bootstrapping, but it has nothing to do with IDEs.",
        "author": "c3534l",
        "created_utc": 1741650870,
        "score": 22,
        "parent_id": "t3_1j8b06a",
        "depth": 0
      },
      {
        "id": "mh3pv5q",
        "body": "An IDE is just a program. It's (usually) a very fancy text editor that (probably) also happens to have the ability to also treat the text in it as code. You can write an IDE in any programming language you like, much in the same way you could write a book on paper of any color you wanted. Importantly, you do not need to write the IDE program in the same language that it is intended to be used for.",
        "author": "TfGuy44",
        "created_utc": 1741645516,
        "score": 12,
        "parent_id": "t3_1j8b06a",
        "depth": 0
      },
      {
        "id": "mh3ql90",
        "body": "IDEs are very complex beasts. Their job is, partially, to integrate with other programs. I feel it is more useful to talk about the underlying programs. \n\nLet’s say you want to create a Java program. First you type it in. Into a text editor. Then you run the Java compiler that converts the human readable java source code into so-called byte code—instructions for a machine—the Java virtual machine. Then you run the Java virtual machine telling it to execute the byte code from the previous step.",
        "author": "hibbelig",
        "created_utc": 1741645738,
        "score": 3,
        "parent_id": "t3_1j8b06a",
        "depth": 0
      },
      {
        "id": "mh406tm",
        "body": "By “Standing on the shoulders of giants”. In theory you could write an IDE in machine code using a hex editor. In practice version 0.1 of the compiler/linker is written in an existing language.  Then for many languages the compiler is rewritten in the new language and then the IDE developed in the new language, a practice called “dog fooding”",
        "author": "Fizzelen",
        "created_utc": 1741648723,
        "score": 3,
        "parent_id": "t3_1j8b06a",
        "depth": 0
      },
      {
        "id": "mh3wq3x",
        "body": "There is no language for writing IDEs, as you can use whatever language you want (as long as you can make GUI programs with it). And you compile it with the exact same compiler and tools used for that language. An IDE is not that different from other GUI programs, so don't think of them as something special.\n\nIDEs integrate several tools to help you develop. Some may have everything needed inside, while others may rely on third-party programs to do stuff like compiling code or checking errors on the code.",
        "author": "MasterGeekMX",
        "created_utc": 1741647628,
        "score": 2,
        "parent_id": "t3_1j8b06a",
        "depth": 0
      },
      {
        "id": "mh4vdtc",
        "body": "I'm not sure what you're confused about, but I have a few hunches. \n\nAn IDE is basically a complicated text editor. You could create source code in Notepad on Windows if you really wanted to. \n\nBut an IDE is particularly designed to provide feedback about your code, syntax highlight, incorporate multiple source files, and generally help you develop an entire project. \n\nWhen you compile your program, a good compiler will not just either work or fail, but give you good error messages to help you know *why* your code won't compile. These same tools can be integrated into the IDE itself. \n\nSo basically, just as Word can give you spelling and grammar warnings, an IDE can give you warnings about your project. \n\nIf you think about it like, you write a class, the class has member variables and member methods. The IDE can, in real time, evaluate those variables and methods. And it can determine when you've instantiated an object of that class, so it knows what variables and methods are available. It's basically just using the same sort of tools a compiler uses. \n\nAn IDE can pretty much be written in any language. Just as a compiler can pretty much be written in any language. You just need to have some way of configuring the syntax for each language you want it to recognize. \n\nEvery language will conform to a particular grammar, so you just need to configure the IDE with the grammars of each language to be recognized.",
        "author": "Paxtian",
        "created_utc": 1741658807,
        "score": 2,
        "parent_id": "t3_1j8b06a",
        "depth": 0
      }
    ],
    "1j8ayg6": [
      {
        "id": "mh3pz72",
        "body": "Older systems would send a message to the newly revealed window to ask it to redraw itself.\n\nModern systems just keep a buffer per window, and composite them with the GPU.",
        "author": "monocasa",
        "created_utc": 1741645551,
        "score": 87,
        "parent_id": "t3_1j8ayg6",
        "depth": 0
      },
      {
        "id": "mh3olm1",
        "body": "From a computer science point of view, a key concept here is the [clipping rectangle](https://sites.cc.gatech.edu/grads/h/Hao-wei.Hsieh/Haowei.Hsieh/mm.html).\n\nHowever, I suppose that any computer you're actually likely to use these days probably performs clipping (and more) in hardware.",
        "author": "nderflow",
        "created_utc": 1741645132,
        "score": 14,
        "parent_id": "t3_1j8ayg6",
        "depth": 0
      },
      {
        "id": "mh4qiwz",
        "body": "Basically this is the job of the “compositor” which computes and renders the active area of the screen and swaps buffers to do so. A compositor many times will articulate the positioning of the windows in a tree based structure. This is also how the DOM in many browsers is articulated as a tree based structure (like ComposedShadowTreeWalker in Webkit). Within the tree structure areas which are changed by the user are considered to have “frame damage” and are marked accordingly so that the compositor knows which buffers to swap. That’s a pretty simplistic take on it though and recommend learning the history of Xerox-PARC and the full history of the GUI if you are interested.",
        "author": "thatdevilyouknow",
        "created_utc": 1741657230,
        "score": 9,
        "parent_id": "t3_1j8ayg6",
        "depth": 0
      },
      {
        "id": "mh5xt6p",
        "body": "First of all, there is a line between computer science, which is all about the theory of how things work, and then computer engineering, which is about how to make stuff with computers. What you ask it more about the latter, as pure computer science is more about calculating how many steps it takes to run some algorithm, for example.\n\nAnyways, as many things in computing, things are done in layers, called abstraction layers. Instead of doing everything from start to finish, you build stuff in levels. You start with the most basic things, and with them build up something that does a little bit more. Then you \"forget\" about how that level works, and you care about how to use it. Then you make another layer of more advanced stuff based on the things done in the lower layer, and you again \"forget\" how it works and focus on how to use it to make more advanced stuff.\n\nLet's say a real case scenario with Linux, as things over there are open source, so anyone can see how things are coded.\n\nWe start with a display protocol, which is a set of standard ways in which you communicate with the screen. Wayland is the new and trendy display protocol, which works in general terms by treating the display you have as a \"canvas\", as you can put anything you want pixel by pixel. This is done by talking to the GPU vía it's drivers so it presents the \"framebuffer\" (the memory that stores the image the GPU will display to the screen) as something you can edit.\n\nHere is an article explaining a bit more what is Wayland: https://www.maketecheasier.com/what-is-wayland/\n\nThen, with said protocol detailed, we can start developing a program called a compositor. That is the program that does most of what you ask: with the help of the Wayland protocol, it keeps on it's memory the windows you have open, where they are, what is the image content of it, etc.\n\nHere is an article about how to write step-by-step a basic Wayland GUI: https://gaultier.github.io/blog/wayland_from_scratch.html\n\nGUI applications are usually coded with libraries that give you ready-to-use graphical elements, instead of coding them yourself. In Linux, the most common ones are GTK and Qt. These libraries have code inside to talk to the Wayland compositor so the app can tell what elements need to be drawn inside the given window, and the compositor takes the work of talking to the GPU to render that.\n\nThe program you make then only needs to care about doing what it needs to do, as you leave the rest to both the graphical toolkit and the compositor. You as a programmer simply declare in your code that you want a window with a given title, icon, and size, and inside such window there are buttons, text labels, tabs, and anything you want.\n\nFinally, this talk is about how System76, a company that makes Linux computers, is making it's own desktop environment (GUI for Linux), which talks about many things you ask: https://youtu.be/FUif2GxwgBc",
        "author": "MasterGeekMX",
        "created_utc": 1741676268,
        "score": 7,
        "parent_id": "t3_1j8ayg6",
        "depth": 0
      },
      {
        "id": "mh5oecu",
        "body": "What you are looking for is called 'window manager' in Linux term. You could start learning from the small code-base one like dwm\n\n[https://en.wikipedia.org/wiki/Dwm](https://en.wikipedia.org/wiki/Dwm)",
        "author": "recursion_is_love",
        "created_utc": 1741670785,
        "score": 4,
        "parent_id": "t3_1j8ayg6",
        "depth": 0
      }
    ],
    "1j8kmdp": [
      {
        "id": "mh686r6",
        "body": ">  Given an unrooted tree with n vertices can you choose a root such that the height of the tree is h where h is any natural number > 0 and <= n? Is there a way to prove it's only possible for some h?\n\nThere's a pretty simple proof that the height will always be greater than or equal to half of the [diameter](https://en.wikipedia.org/wiki/Diameter_\\(graph_theory\\)) of the graph, independent of the choice of root.",
        "author": "undercoveryankee",
        "created_utc": 1741682990,
        "score": 6,
        "parent_id": "t3_1j8kmdp",
        "depth": 0
      }
    ],
    "1j8c09n": [
      {
        "id": "mh4k7sv",
        "body": ">Displeasement with using higher order functions\n\nYou're in for a rough ride with Lambda Calculus, then. It's functions all the way down.\n\nI personally learned about it from Pierce's *Types and Programming Languages*. It's very good and pretty concrete, if that's what you like.",
        "author": "OpsikionThemed",
        "created_utc": 1741655200,
        "score": 11,
        "parent_id": "t3_1j8c09n",
        "depth": 0
      },
      {
        "id": "mh4524t",
        "body": "Are you trying to study purely lambda calculus, or functional programming?",
        "author": "coolestnam",
        "created_utc": 1741650306,
        "score": 3,
        "parent_id": "t3_1j8c09n",
        "depth": 0
      },
      {
        "id": "mh53ve2",
        "body": "Just pick a book or two and go. They will tell you what their notation means. I recommend progrM = proof for an introduction to the subject",
        "author": "n0t-helpful",
        "created_utc": 1741661737,
        "score": 3,
        "parent_id": "t3_1j8c09n",
        "depth": 0
      },
      {
        "id": "mh564vt",
        "body": "Possibly (?) the most comprehensive resource, but not the greatest starting point, is *The Lambda Calculus, Its Syntax and Semantics*.\n\n  \nMayer Goldberg, a man near and dear to me, has released an introduction to the lambda calculus. I have no idea if it's any good, but here you go: [https://www.academia.edu/90020066/An\\_Introduction\\_to\\_the\\_Lambda\\_Calculus](https://www.academia.edu/90020066/An_Introduction_to_the_Lambda_Calculus)\n\n\n\nI would suggest watching some videos to get you started notation-wise. I'm surprised by your confusion, it's pretty minimal - variables, abstractions, applications, and that's it.\n\n  \nIf you have a computer science programming background, maybe start by learning the programming language Scheme? It'll be a good place to build your intuitions and test hypotheses. E.g. the following demonstrates behavior of Church numerals by running in Scheme - \n\n    > (define c3 (lambda (s) (lambda (z) (s (s (s z))))))\n    > (define c2 (lambda (s) (lambda (z) (s (s z)))))\n    > (((c3 c2) (lambda (x) (+ x 1))) 0)\n    8",
        "author": "JewishKilt",
        "created_utc": 1741662585,
        "score": 3,
        "parent_id": "t3_1j8c09n",
        "depth": 0
      },
      {
        "id": "mh69w4t",
        "body": "Well to be honest, being able to switch between notations is one of the skills one has to learn to succeed in both mathematics and (theoretical) computer science. My tip would be to pick one resource (i.e. one notation) and stay with it until you learn the basic concepts and then start branching out to other resources.",
        "author": "Krowken",
        "created_utc": 1741684096,
        "score": 2,
        "parent_id": "t3_1j8c09n",
        "depth": 0
      },
      {
        "id": "mh9hh5j",
        "body": "If you want different but actually cool notation I would advise Eric Hehner's [A Practical Theory of Programming](https://www.cs.utoronto.ca/~hehner/aPToP/) (he only uses angled brackets, so the scope of all lambda abstractions is very well delimited) or Raymond Boute's [Functional Mathematics (Funmath)](https://web.archive.org/web/20111002014924/http://www.funmath.be/Coursenotes.pdf) (also [here](https://web.archive.org/web/20220612071838/http://www.funmath.be/S-A0.pdf)). Exotic, but pretty cool :)",
        "author": "revannld",
        "created_utc": 1741723672,
        "score": 2,
        "parent_id": "t3_1j8c09n",
        "depth": 0
      }
    ],
    "1j7zsvc": [
      {
        "id": "mh2ncr0",
        "body": "I think it's a cool project! Sure it's small, but you could go deep into things like optimizing the resulting expression or even as far as writing a tiny \"real\" compiler that produces machine code for just Boolean expressions. And then maybe you could even extend it very slowly!",
        "author": "FlyingQuokka",
        "created_utc": 1741634295,
        "score": 3,
        "parent_id": "t3_1j7zsvc",
        "depth": 0
      }
    ],
    "1j7dcam": [
      {
        "id": "mgw511x",
        "body": "https://youtube.com/playlist?list=PLxNPSjHT5qvscDTMaIAY9boOOXAJAS7y4&si=2U18rGiW08pvkKmT",
        "author": "NajdorfGrunfeld",
        "created_utc": 1741545216,
        "score": 6,
        "parent_id": "t3_1j7dcam",
        "depth": 0
      },
      {
        "id": "mgxxa7e",
        "body": "GPU architecture varies greatly between Nvidia, Intel, AMD, ARM, etc.\n\nAnd learning any one GPU architecture is only useful to a VERY small number of programmers.\n\nCPU architecture also varies greatly between companies and processor lines and learning the details of any one CPU is only useful to a VERY small number of programmers.\n\nRather than learning any particular GPU architecture it would probably be much more useful to learn the GPU-agnostic GPU interface languages that most graphics programmers ACTUALLY use like \"Vulcan\" and \"OpenGL\".  But you would need to be a good programmer already to really understand how to use those. \n\nBut if you REALLY want to learn about one particular GPU architecture then I would suggest learning about Nvidias \"CUDA\" GPU architecture because it is also used for AI now as well.  But again  you would need to be a good programmer already to really understand how to use CUDA directly. \n\nYou can find tutorials for Vulcan, OpenGL, and CUDA by doing some searches like \"OpenGL Tutorial\" or \"Nvidia CUDA Tutorial\", etc.",
        "author": "CanadianBuddha",
        "created_utc": 1741565784,
        "score": 3,
        "parent_id": "t3_1j7dcam",
        "depth": 0
      }
    ],
    "1j6xkmi": [
      {
        "id": "mgsjebs",
        "body": "Computer engineering is computation focused electrical engineering. Computer science is computation focused mathematics.",
        "author": "GradientCollapse",
        "created_utc": 1741489435,
        "score": 143,
        "parent_id": "t3_1j6xkmi",
        "depth": 0
      },
      {
        "id": "mgsi7se",
        "body": "In terms of coursework:\n\n* Computer Engineering deals with chip development and/or embedded applications, as well as general programming concepts.\n* Computer Science deals more with theory and algorithms, as well as general topics in programming.\n\nIn terms of employment: For \"simple\" stuff like API development/general webdev, etc., the degrees are *generally* interchangeable, but if you're interested in chip development/heavy-duty embedded work, having the coursework from a CpE degree will be a differentiator and important.  If you're interested in something super algorithmic, dealing with language design/theory, the coursework from a CS degree will be a differentiator.",
        "author": "apnorton",
        "created_utc": 1741488980,
        "score": 65,
        "parent_id": "t3_1j6xkmi",
        "depth": 0
      },
      {
        "id": "mgsji2u",
        "body": "CE has a much greater emphasis on hardware. CS has a much greater emphasis on software. There's a lot of overlap, though, so it can be confusing. Think of it this way, a CE grad will be better geared toward designing circuit boards and electronics while a CS grad will be better geared toward software development.",
        "author": "DoubleT_TechGuy",
        "created_utc": 1741489474,
        "score": 21,
        "parent_id": "t3_1j6xkmi",
        "depth": 0
      },
      {
        "id": "mgsilbr",
        "body": "Depends on the school, but generally, a CE degree will have both software and some circuitry/ computer hardware, whereas a CS degree focuses more on software alone.",
        "author": "Paxtian",
        "created_utc": 1741489125,
        "score": 10,
        "parent_id": "t3_1j6xkmi",
        "depth": 0
      },
      {
        "id": "mgtq4xf",
        "body": "CE is kind of like double majoring in CS and Electrical Engineering.",
        "author": "Affectionate_Pizza60",
        "created_utc": 1741510138,
        "score": 8,
        "parent_id": "t3_1j6xkmi",
        "depth": 0
      },
      {
        "id": "mgso9u7",
        "body": "Like any other field where you have a science and an engineering variant (like chemistry), science is about discovering stuff, and pushing the boundary of what is known a bit more, while engineering is about taking what already exists and then use it in novel ways to solve problems.\n\nFollowing your question, CS is about discovering new algorithms, trying out novel methods for doing computing, developing further the theory, etc. In the other hand, CE is more about \"how computers can solve this problem\"?, and then doing all the work to get to said solution.",
        "author": "MasterGeekMX",
        "created_utc": 1741491290,
        "score": 4,
        "parent_id": "t3_1j6xkmi",
        "depth": 0
      },
      {
        "id": "mgsgnk2",
        "body": "How I view it, they're two opposite ends of a line, and there's a lot inbetween that blurs the lines or is more leaning on one end.",
        "author": "Rude-Pangolin8823",
        "created_utc": 1741488384,
        "score": 3,
        "parent_id": "t3_1j6xkmi",
        "depth": 0
      },
      {
        "id": "mgt19d0",
        "body": "\nComputer science (CS) focuses more on theories and fundamentals like programming/Coding and algorithms. It is about understanding how computer data process\nWhich computer engineering (CE) dives into both software and hardware, making sure everything works together",
        "author": "Pen_Strike",
        "created_utc": 1741496735,
        "score": 2,
        "parent_id": "t3_1j6xkmi",
        "depth": 0
      }
    ],
    "1j63vsa": [
      {
        "id": "mglmhij",
        "body": "An IPv4 TTL is 8 bits. So it can't be larger than 255.",
        "author": "gkbrk",
        "created_utc": 1741391605,
        "score": 153,
        "parent_id": "t3_1j63vsa",
        "depth": 0
      },
      {
        "id": "mglngfw",
        "body": "Your packet would need a terminal destination, this assumes that the internet would be incapable of routing your packet to this destination, which would need a cycle somewhere as the internet is surprisingly narrow in a graphical sense. \n\nRouting algorithms and neighbour discovery etc. is quite sophisticated and carefully managed so few such cycles probably exist. \n\nAs mentioned in another comment TTL only has 8 bytes so max hops you could have would be 255 anyway.",
        "author": "zestiMantra",
        "created_utc": 1741391939,
        "score": 83,
        "parent_id": "t3_1j63vsa",
        "depth": 0
      },
      {
        "id": "mgmswu1",
        "body": "You already got an answer, not possible,\nBut two fun related things. There is a way of storing data on ICMP packets. (Pings). \n\nhttps://github.com/yarrick/pingfs\n\nObviously experimental. \n\nAnd the classic “we can’t send emails further than 500 miles” \n\nhttps://web.mit.edu/jemorris/humor/500-miles\n\nSo the internet protocols do work in mysterious ways.",
        "author": "magical_midget",
        "created_utc": 1741407296,
        "score": 28,
        "parent_id": "t3_1j63vsa",
        "depth": 0
      },
      {
        "id": "mglun1n",
        "body": "No, this is impossible with the Internet protocol. It is possible to have an infinite loop with many versions of the Ethernet protocol though, because Ethernet doesn't have TTL or hop counting.",
        "author": "wolfkeeper",
        "created_utc": 1741394421,
        "score": 9,
        "parent_id": "t3_1j63vsa",
        "depth": 0
      }
    ],
    "1j5mi7h": [
      {
        "id": "mgi4qch",
        "body": "Yes, if you have a compiler or interpreter in JavaScript for that language then you can use it in your browser.\n\nHowever, you cannot natively change the language of a script tag, but you can have some JavaScript wrapper that parses the DOM to detect that *language* attribute you describe.\n\nIn fact, here is an example that does just that. It adds a button to the DOM which calls an onclick handler written in Python.\n\n[Example of Python in the browser](https://app.codeboot.org/5.3.1/?init=.fcHl0aG9uLWJ1dHRvbi5weQ==~XQAAgACfAAAAAAAAAAA4GwhIz1ACAiWPD8Sf9E0DNXcSTeDeu_cPBZ7F4TJX4FT8TTefL_P4xpPTOo4oHQxpQFPvkEGRz6slmB3GJ31liS03vlVgQtKuhk05WNBjfBNs3hNvXI0wl4zAdoRewqfjyhLCnLQfFqo7CGB3CIxhdF1o_Flpt22gp__fEAAA.~lang=py-novice.~showLineNumbers=true.e)",
        "author": "ANiceGuyOnInternet",
        "created_utc": 1741352537,
        "score": 41,
        "parent_id": "t3_1j5mi7h",
        "depth": 0
      },
      {
        "id": "mgicngg",
        "body": "Webassembly is meant to be the way to use arbitrary programming languages for the web. Of course you can, and people have, been modifying their browsers to run things like Java or Shockwave or whatever for a long time.",
        "author": "c3534l",
        "created_utc": 1741355459,
        "score": 18,
        "parent_id": "t3_1j5mi7h",
        "depth": 0
      },
      {
        "id": "mgi9cpf",
        "body": "Firefox has a built in Javascript interpreter. I don't see any reason in principle why you couldn't make a fork of Firefox t hat also has a built in interpreter (or runs an external interpreter) for your custom language.\n\nTo get the results in HTML you'd probably need to make Firefox provide some part of the DOM API in your language - e.g. give your language a way to do the equivalent of the Javascript \\`document.getElementById(someId).innerText = 'new text';\\` and have your Firefox fork make sure a document object exists in scope or is available somehow to scripts in your language.",
        "author": "BarneyLaurance",
        "created_utc": 1741354284,
        "score": 10,
        "parent_id": "t3_1j5mi7h",
        "depth": 0
      },
      {
        "id": "mgikgsf",
        "body": "No problem.\n\nThere are at least three ways to do this at three different levels of abstraction  \nTop level - cross-transpilers from your language to js. They exist for many popular languages.  \nBrowser level - webasm - compilers from your language to webassembly code.  \nVirtual machine level - running a computer emulator in a browser.  \nThe last option allows you to use almost all the tools and languages ​​available in the emulated OS.",
        "author": "YahenP",
        "created_utc": 1741358115,
        "score": 7,
        "parent_id": "t3_1j5mi7h",
        "depth": 0
      },
      {
        "id": "mgm9ykq",
        "body": "Write a JavaScript interpreter for your language.",
        "author": "Aggressive_Ad_5454",
        "created_utc": 1741399875,
        "score": 2,
        "parent_id": "t3_1j5mi7h",
        "depth": 0
      }
    ],
    "1j4uih0": [
      {
        "id": "mgbibat",
        "body": "I recently took a deep dive into the Linux kernel to understand how it handles processes, scheduling, memory, and more. While I had some OS knowledge from school, it always felt too abstract - so I wanted to see how things actually work. This post covers what I learned, from system calls to interrupts, and how kernel development differs from userspace.",
        "author": "lucavallin",
        "created_utc": 1741264691,
        "score": 30,
        "parent_id": "t3_1j4uih0",
        "depth": 0
      },
      {
        "id": "mgbjmhi",
        "body": "Will definitely give it a read. Good job.",
        "author": "Black_Bird00500",
        "created_utc": 1741265240,
        "score": 3,
        "parent_id": "t3_1j4uih0",
        "depth": 0
      },
      {
        "id": "mgc34tv",
        "body": "Great read. I recently took a course on operating systems and it felt great to understand such a big chunck of the article. Great write up!",
        "author": "RollerScroller8",
        "created_utc": 1741272141,
        "score": 3,
        "parent_id": "t3_1j4uih0",
        "depth": 0
      },
      {
        "id": "mgdai3n",
        "body": "Cool read,  no fluff, no unneeded acronyms and buzzwords. To the point.\n\nThank you.",
        "author": "MrTroll420",
        "created_utc": 1741284604,
        "score": 2,
        "parent_id": "t3_1j4uih0",
        "depth": 0
      },
      {
        "id": "mggm0dy",
        "body": "Wow. I didn't understand anything but still enjoyed reading it in its entirety. Thank you for the contribution.",
        "author": "Fluffy-Cell-2603",
        "created_utc": 1741323412,
        "score": 2,
        "parent_id": "t3_1j4uih0",
        "depth": 0
      }
    ],
    "1j52ur8": [
      {
        "id": "mgdl19h",
        "body": "Talk to your professors! Look at their websites, see who's doing research that sounds interesting to you, and email them to ask if they're looking for an undergrad research assistant in their lab. That's the start! When they look at your CV they will probably say that you're too early and should take algorithms before joining any research projects, but you can at least start looking. Once you're a little more experienced, also look at Research Experiences for Undergraduates (REUs), which are summer research internships. If they still exist by then; REUs are mostly NSF-funded, and many have unfortunately paused or shut down after Trump admin cuts to research funding.",
        "author": "nuclear_splines",
        "created_utc": 1741287566,
        "score": 21,
        "parent_id": "t3_1j52ur8",
        "depth": 0
      },
      {
        "id": "mgdnd2n",
        "body": "For more theory heavy CS, I’d want to see proof based math: Analysis R or C, group theory, number theory, linear algebra, etc as well as strong computer science fundamentals. You are working toward that! Good job. \n\nDo more math, talk to profs, and take a OS class, (maybe hardware too) and you’ll be the bell of the ball for any comp sci prof/REU in most TCS sub fields.\n\nDEFINITELY START LOOKING FOR RESEARCH NOW",
        "author": "l0wk33",
        "created_utc": 1741288222,
        "score": 10,
        "parent_id": "t3_1j52ur8",
        "depth": 0
      }
    ],
    "1j41jzf": [
      {
        "id": "mg4wvrg",
        "body": "Sebastian Lague on YouTube might have the perfect video for you: [Exploring How Computers Work](https://youtu.be/QZwneRb-zqA?si=uOrhCPqqmel0UKh8)\n\nI hope it instills the same joy of discovery in you as it did for me.",
        "author": "ANiceGuyOnInternet",
        "created_utc": 1741177849,
        "score": 272,
        "parent_id": "t3_1j41jzf",
        "depth": 0
      },
      {
        "id": "mg4unrz",
        "body": "It's built layers upon layers.\n\nAt the lowest point, it's current running through wires and gates; on top of it is ones and zeros going. Then there are many other layers built on top of this. At some point they get meaning associated with them and build up.\n\nIn your case, you're using python. Python has an internal representation for what 3+5 means (it's a binary expression with two expressions in side it (3 and 5) and the + operation). It then knows how to convert each of those expression to numeric values (in this case it's easy) and then runs the operation on them. The definitions come from the python interpreter - you're using cpython here. Some other programmers have spent time to make sure this interpreter can understand your code and convert it to what the environment (combination of OS (windows/linux/mac/android ...) and hardware ) can understand.",
        "author": "MCSajjadH",
        "created_utc": 1741176860,
        "score": 124,
        "parent_id": "t3_1j41jzf",
        "depth": 0
      },
      {
        "id": "mg4u9mt",
        "body": "Computers add binary numbers using logic gates, specifically half adders and full adders inside the CPU.\nFirst we need the binary numbers 3(0011) and 5 (0101)\n\n\t1.\tAdd rightmost digits:\n\t•\t1 + 1 = 10 → 0 stays, carry 1.\n\t2.\tMove to the middle column:\n\t•\t1 + 0 + (carry 1) = 10 → 0 stays, carry 1.\n\t3.\tMove to the leftmost column:\n\t•\t0 + 1 + (carry 1) = 10 → 0 stays, carry 1.\n\t4.\tExtra carry:\n\t•\tSince there’s a carry left, we add a new column → 1000 (which is 8 in decimal).\n\nAll that can be done using nand(so if 1 and 1 it outputs 0, if 0 and 1 it outputs 1) logic gates(transistors)",
        "author": "moerf23",
        "created_utc": 1741176681,
        "score": 43,
        "parent_id": "t3_1j41jzf",
        "depth": 0
      },
      {
        "id": "mg4ufh7",
        "body": "Transistors are used to make logic gates. Logic gates are used to make circuits like a full adder. Google those terms or ask chat. ",
        "author": "AI_is_the_rake",
        "created_utc": 1741176755,
        "score": 23,
        "parent_id": "t3_1j41jzf",
        "depth": 0
      },
      {
        "id": "mg4zom7",
        "body": "Do this course: https://www.nand2tetris.org",
        "author": "editor_of_the_beast",
        "created_utc": 1741179028,
        "score": 9,
        "parent_id": "t3_1j41jzf",
        "depth": 0
      },
      {
        "id": "mg53yae",
        "body": "in a sense, yes they are preprogrammed\n\nbut it has many layers\n\n\nhardware:\nmother board, etc, etc\n\nsoftware:\nbios\nos\napplication\n\n\n\n\n\nI'm no expert but afaik those are some\n\nthats from low level to high level",
        "author": "TraditionalCounty395",
        "created_utc": 1741180716,
        "score": 6,
        "parent_id": "t3_1j41jzf",
        "depth": 0
      },
      {
        "id": "mg9os9p",
        "body": "Lots of programmers before you sacrificed countless hours to make everybody else’s jobs easier.",
        "author": "ApricotPit13",
        "created_utc": 1741231174,
        "score": 5,
        "parent_id": "t3_1j41jzf",
        "depth": 0
      },
      {
        "id": "mg5derg",
        "body": "Nand2tetris hands down. Go through that course. It will answer all your questions.",
        "author": "ka0sFtw-",
        "created_utc": 1741184078,
        "score": 6,
        "parent_id": "t3_1j41jzf",
        "depth": 0
      },
      {
        "id": "mg5v6w2",
        "body": "Layers upon layers of code\n\nIt starts with physical hardware. When you press a key on your keyboard, it sends a signal to your motherboard, which has firmware installed on it that gets interpreted by your OS, and sends up the chain to wherever it needs to go\n\nSome of it is very human friendly (your python code), and some of it not so much (assembly and machine code)\n\nIt all crumbles down and simplifies to ones and zeroes\n\nIf you're really interested, I'd suggest taking an online class on it, but if your goal is to write high level code like Python then the YT videos people are posting here will do a great job of giving you a \"good enough to be dangerous\" overview of how computers work",
        "author": "GoodGorilla4471",
        "created_utc": 1741189590,
        "score": 5,
        "parent_id": "t3_1j41jzf",
        "depth": 0
      },
      {
        "id": "mg4vm06",
        "body": "Let's take your \"alarm' as an example, the computer surely doesn't know what 'alarm' is but the person who built that app told it to do a specific task when we select alarm. How? Using languages like python. How python works? The interpreter translates python to binary.  \n  \nThat binary then works through a complex set of logic gates and does the said task. And logic gates are just an elaborate system of '=' '-' '/' etc.",
        "author": "Aberforthdumble24",
        "created_utc": 1741177290,
        "score": 4,
        "parent_id": "t3_1j41jzf",
        "depth": 0
      },
      {
        "id": "mg5gy9w",
        "body": "Your computer represents stuff as binary. There are plenty of resources online on how, but e.g. you may say that 00101010 is the number 42. Notice here there are 8  digits, or more accurately 8 \"bits\", forming an octet; this is a very common pattern. Modern computers will also typically work with bigger chunks; this is why you hear a computer is \"64-bits\" or \"32-bits\" (although most of them are 64 now). Concretely, you can think that in the processor, there will be 32 tiny wires, each either on or off (i.e. 0 or 1); that represents a value. This scheme is also used to represent instructions telling the processor what to do, e.g. 00001111 is the \"add\" code. When the processor receives that instruction, it will know that the next two numbers it receives must be added together.\n\nThis is of course massively oversimplified; processors will also have tiny memory cells, called registers, and instructions will typically interact with those. And then there are layers of CPU complexity on top of that that have been added with the years. In some programming languages (like C), you have a program called the compiler which translates what you wrote in the actual instructions for the CPU. In Python, you have yet another layer of abstraction : there is a program called the interpreter which runs your code on a \"virtual machine\", like if you simulated a computer with simplified rules on top of your actual computer.\n\nAll of this was not built in a day. On early computers, people wrote the actual instructions for the CPU; then they used that to create compilers which would allow to code in languages like C, and then they built operating systems to abstract some stuff like managing external memory or hard drives, and they created higher-level languages to simplify programming some stuff (typically in a less-performant way, but that mattered less as computers became more powerful), and there we are today.",
        "author": "thuiop1",
        "created_utc": 1741185254,
        "score": 3,
        "parent_id": "t3_1j41jzf",
        "depth": 0
      },
      {
        "id": "mg5s283",
        "body": "I studied what could be translated to something like computer science and telecommunications in high school. which is something akin to a softer computer engineering course (it is very much like computer engineering (in italy we have those things).\n\nI studied how a computer works by studying the simpler (emulated) structure and architecture 8086 CPU and built simple assembly programs using dosbox and [the debug.com tool](https://en.wikipedia.org/wiki/Debug_(command)) which allowed for a very simple though tedious way to write what would be a quite close to the metal x86 assembly (forget jump labels, you better start counting the bytes properly and have a syscall cheat sheet at hand)\n\nit is tedious but fun, you may want to do the same and then go on to study more advanced topics about system design, you will also find out many things, from how scheduling for multitasking works or even how floating point woks. \n\nalso clock related stuff is probably a mix of system calls and interrupts. but you will figure it out.\n\nif you find such things so interesting you may buy a microcontroller like an arduino or a raspberry pi zero and just program bare metal.",
        "author": "gabrielesilinic",
        "created_utc": 1741188676,
        "score": 3,
        "parent_id": "t3_1j41jzf",
        "depth": 0
      },
      {
        "id": "mg5v6j6",
        "body": "Another resource on how computers work that I loved is from CrashCourse, [their 41 video playlist on Computer Science](https://youtube.com/playlist?list=PL8dPuuaLjXtNlUrzyH5r6jN9ulIgZBpdo&si=ZsZDToOqNNgYTP6d). Starts with the history, and then gets into how computers work and beyond.",
        "author": "PlanetaryMotion",
        "created_utc": 1741189588,
        "score": 3,
        "parent_id": "t3_1j41jzf",
        "depth": 0
      },
      {
        "id": "mg5vqcr",
        "body": ">How computer knows that 3+5 is 8\n\nWell for this one, it's actually a piece of hardware. \n\nComputers work using binary logic gates (i.e. you put in two signals, it produces a result). With those, we can build an adder that can add together two, one-digit binary numbers, and return both the result of addition, and any carry over from addition. \n\nYou string together a bunch of adders, and you can add whatever numbers you want. These are actual a pieces of hardware; small black chips manufactured by various companies. \n\n>or when i say ring alarm\". How do computer know what alarm mean??\n\nIt depends on what you mean by \"ring alarm\", but your computer does have an internal clock, and can store the current time somewhere to check later. At its most basic level, your processor can make a beeping sound. Alternatively, you have hardware available to play audio files for a ringtone. That gets a bit more complicated tho. \n\nBut fundamentally it's all just signals you send to your processor to activate various pieces of hardware.",
        "author": "DTux5249",
        "created_utc": 1741189746,
        "score": 3,
        "parent_id": "t3_1j41jzf",
        "depth": 0
      },
      {
        "id": "mg62npo",
        "body": "There are numerous layers of software between the user (you) and the computer at this point in time.  \n  \nBut the CPU \"knows\" how to perform addition of *binary numbers* and can do so if given the correct instruction and the numbers in the right form.  \n  \n3 (decimal) = 0011 (binary)  \n5 (decimal) = 0101 (binary  \n  \n3 + 5 = 8  \n0011 + 0101 = 1000  \n  \nBinary Addition  \n0 + 0 = 0  \n0 + 1 = 1  \n1 + 0 = 1  \n1 + 1 = 1, carry 1",
        "author": "istarian",
        "created_utc": 1741191744,
        "score": 3,
        "parent_id": "t3_1j41jzf",
        "depth": 0
      },
      {
        "id": "mg62vbz",
        "body": "Much like onions (and ogres), computers work on layers. Each one deals with making something work, and then we \"forget\" about that and simply treat it as something that just works _automagically_. This is called abstraction layers.\n\nAt the very core, you have transistors. They are electrical components that act as switches that can open or close circuits according to another electrical signal you give it. You can combine transistors to make devices that only allow current to flow it a series of inputs are at the right combination.\n\nIf we manage to associate said conditions to different things, such as the representation of a number in binary, we can make circuits that detect if you give it the right number. We can also make circuits that respond to signals that correspond to two numbers that add up to certain figure, or if one ins bigger than the other, etc. A circuit that can do math and logic comparisons over two numbers encoded in binary is callled an Arithmetic-Logic Unit (ALU).\n\nWe can also make circuits that hold information; that is, we give it a signal, and the circuit copies it. But then we turn off said signal, but the circuit holds it. If we make a grid out of those circuits, and make circuitry to access an specific cell on the grid, alongside signals to indicate if we just want to read stored data or overwrite it, we have made ourselves some memory, like RAM.\n\nThen we can make a bigger circuit that integrates the ALU and Memory, and uses them to make operations, such as adding two numbers stored in two memory locations, or comparing if said numbers are equal or not. What operation should be done is encoded as yet another series of zeroes and ones, each one assigned to a different operation. Those orders could be stored on the same memory where we are storing our data (which is called Von Neumann architecture), or be located in a separate memory dedicated to those instructions (called Hardvard architecture).\n\nThat ALU + RAM + control unit is a CPU. And those instructions is the famous machine code. But programming liike that isn't a very easy task, so programming languages were developed. They are a bit more human-readable, making coding easier. They use a program called compiler or interpreter (depending on the language), which translates those lines of code into the actual isntructions your CPU can handle.\n\nBut managing everything manually in the CPU is also tedious, so we need a platform that helps us. That is the operating system. It is a program after all, but this time acting as orchestra director. It takes care of comunicating to the hardware like screen or keyboard, and also provides ways to have more than one program running at a time. All you need to do as a programmer is do your work, and when you need to do something with the rest of the system, you simply ask for help to the OS in the form of a system call.\n\nYou can also use the help of code made by other people, which are called libraries. You as a programmer simply download them and use it, and the code inside takes all the care about doing the task.\n\nEarly OSes worked only in terminals, but since the mid 80's, graphical user interfaces were introduced, which allows you to have windows, taskbars, and graphical apps. They use a whole world of libraries, and sets of programs, which is called a framework.\n\nIf you want to undertsand the lower layers, I really recommend the videos from the YT channel Core Dumped.\n\nThis playlist explains how transistors make a CPU: https://www.youtube.com/playlist?list=PL9vTTBa7QaQOoMfpP3ztvgyQkPWDPfJez\n\nAnd this one how OSes work: https://www.youtube.com/playlist?list=PL9vTTBa7QaQPdvEuMTqS9McY-ieaweU8M",
        "author": "MasterGeekMX",
        "created_utc": 1741191804,
        "score": 3,
        "parent_id": "t3_1j41jzf",
        "depth": 0
      },
      {
        "id": "mg713pz",
        "body": "I highly recommend the book \"Code: The Hidden Language of Computer Hardware and Software\" by Charles Petzold. Took me from pretty much where you are in my understanding of computers - by that I mean I was asking the same questions, which were a great foundation for learning more. The book starts from the very ground level of a computer processor and works upward to software but I never felt like it got hard to follow as complicated as that is",
        "author": "bigtimeloser_",
        "created_utc": 1741201350,
        "score": 3,
        "parent_id": "t3_1j41jzf",
        "depth": 0
      },
      {
        "id": "mgaxw5n",
        "body": "Wonderful question, I foresee the start of a beautiful journey. \n\nSomething that helped me personally understand things a lot better (from a technical low-level perspective) was the course nand2tetris. \n\nIn addition to all the suggested videos I highly recommend this free course if you’re interested in learning about computer systems and how they are built/architected. \n\nYou sound a lot like me when I was just a little younger, so I wish you the best of luck!",
        "author": "MiracleDrugCabbage",
        "created_utc": 1741253711,
        "score": 3,
        "parent_id": "t3_1j41jzf",
        "depth": 0
      },
      {
        "id": "mgby6u7",
        "body": "The computer has no idea that 3+5 = 8. Or what an alarm is, let alone how to ring it.\n\nA digital computer is just a collection of circuits, physics, rules, and kludges, all flying in extremely close formation.\n\nIt's like asking how does the lightbulb *know* to light up when you flip its switch to the ON position.\n\nIt all starts with patterns of data travelling from points Ax to points Bx. After that, those circuits, physics, rules, and kludges take over the the CPU just does… things. We give some of those things metaphorical names, like memory, bus, arithmetic, keyboard, desktop, or window. With computers, it's metaphores all the way down to the level of the electron.",
        "author": "EmbeddedSoftEng",
        "created_utc": 1741270537,
        "score": 3,
        "parent_id": "t3_1j41jzf",
        "depth": 0
      },
      {
        "id": "mg5bsbz",
        "body": "I’m not an expert, but, the CPU has a neat thing called the control unit. It reads the incoming instruction along with the current CPU cycle and triggers control lines that move things about, do math in the ALU and store values. It’s all logic - you have to think for your answer.",
        "author": "t_0xic",
        "created_utc": 1741183520,
        "score": 2,
        "parent_id": "t3_1j41jzf",
        "depth": 0
      }
    ],
    "1j3z4jy": [
      {
        "id": "mg4d1l7",
        "body": "Try to build one from the other and vice versa.\nIt is easy to simulate a single tape machine with a multi tape one (only use the first tape).\n\n But it is also possible to simulate a multi tape machine with a single tape. For the simple case of two tapes simulated onto one, assign all even indexed cells to the first tape, and odd cells to the second. Sure, the machine will do more back and forth, but they will achieve the same thing. You can generalize this idea with several tapes.\n\n(As a bonus, you can show that simulating a multi tape machine with a single tape one increase complexity polynomially. It means that a problem solved in polynomial time with a multi tape machine is also solved in polynomial time with a single tape. It is convenient when doing fundamental proofs)",
        "author": "spacewolfXfr",
        "created_utc": 1741166947,
        "score": 50,
        "parent_id": "t3_1j3z4jy",
        "depth": 0
      },
      {
        "id": "mg4eapd",
        "body": "Why is multi tape looping harder than single tape",
        "author": "almostthebest",
        "created_utc": 1741167729,
        "score": 9,
        "parent_id": "t3_1j3z4jy",
        "depth": 0
      },
      {
        "id": "mg5a6x3",
        "body": "You are missing multiple things.\n\n1. There is such a thing as running forever without looping. Assuming running forever = looping will bite you at some point.\n2. \"all tapes would have to loop\" is plain wrong.\n\nA machine can run forever without the tape looping and a machine can loop on one tape while not looping on another. But the thing is if a machine loops this can be detected i.e. it reaches the same tape configuration + state twice. Its the possibility of the machine going forever without looping that makes the halting problem undecidable.",
        "author": "sumpfriese",
        "created_utc": 1741182966,
        "score": 5,
        "parent_id": "t3_1j3z4jy",
        "depth": 0
      },
      {
        "id": "mg54vs5",
        "body": "It's perfectly acceptable for a multi-tape TM to ignore every tape except the one that the input is on. Then it is effectively a single-tape TM. If you see that a single-tape TM can easily loop forever, then a multi-tape TM that just ignores the other tapes can do exactly the same thing and loop forever.",
        "author": "SignificantFidgets",
        "created_utc": 1741181065,
        "score": 3,
        "parent_id": "t3_1j3z4jy",
        "depth": 0
      },
      {
        "id": "mg6d8go",
        "body": "The other answers here are right. But I think one can make a Cantor diagonalization argument to go further and show that even if there are *infinitely* many of these tapes (as usual, each of unbounded length), then this machine too would be equivalent to a single TM. I'm guessing there's already some such theorem (?)",
        "author": "gnahraf",
        "created_utc": 1741194739,
        "score": 4,
        "parent_id": "t3_1j3z4jy",
        "depth": 0
      }
    ],
    "1j3upnk": [
      {
        "id": "mg4ltji",
        "body": "I would assume A\\* and/or Dijkstra, and [this paper](https://www.researchgate.net/publication/333117435_Google_Maps) claims that is indeed the case.",
        "author": "Yoghurt42",
        "created_utc": 1741172301,
        "score": 12,
        "parent_id": "t3_1j3upnk",
        "depth": 0
      },
      {
        "id": "mg6zrw7",
        "body": "Uber published a paper about their route estimation algorithm: [arxiv paper](https://arxiv.org/pdf/2206.02127), [blogpost] (https://www.uber.com/blog/deepeta-how-uber-predicts-arrival-times/)\n\nTL;DR they use a combination of Dijkstra's algorithm and a deep learning model.",
        "author": "currentscurrents",
        "created_utc": 1741200985,
        "score": 9,
        "parent_id": "t3_1j3upnk",
        "depth": 0
      }
    ],
    "1j3emp9": [
      {
        "id": "mg4nq67",
        "body": "Petzold is the man! I've always liked his stuff",
        "author": "apthamine",
        "created_utc": 1741173377,
        "score": 3,
        "parent_id": "t3_1j3emp9",
        "depth": 0
      }
    ],
    "1j36u7q": [
      {
        "id": "mfxsojo",
        "body": "Because HCI, as interesting as it can be, is one of the branches of CS that is quite far from the core elements of the discipline. I’ve seen more people coming from a social science background getting into HCI than computer scientists. ",
        "author": "sghmltm",
        "created_utc": 1741083871,
        "score": 186,
        "parent_id": "t3_1j36u7q",
        "depth": 0
      },
      {
        "id": "mfyse8h",
        "body": "There is a general cultural under-appreciation for the human element in CS. Tech startups often neglect to do proper user research before diving into developing an app, and developers tend to be more interested in implementation than determining what it is they should be creating in the first place and what impact it will have on the people using it.\n\nAs an educator I think this stems partly from the ways we market CS to youth. It still has this reputation of being this very impersonal, individualist, meritocratic discipline where all that matters is your intelligence and skill and you don’t have to care or think about anyone else, which is great for some people but drives away the kind of people who enjoy thinking about the bigger picture and human psychology.",
        "author": "Quantum-Bot",
        "created_utc": 1741099058,
        "score": 45,
        "parent_id": "t3_1j36u7q",
        "depth": 0
      },
      {
        "id": "mfxnk86",
        "body": "What do you think most people's motivation to study CS is?",
        "author": "Shot-Combination-930",
        "created_utc": 1741080755,
        "score": 38,
        "parent_id": "t3_1j36u7q",
        "depth": 0
      },
      {
        "id": "mfyc202",
        "body": "IMO it's one of the most underrated subdisciplines (a huge part of Apple's success, for instance, is due to improvements in HCI, like making capacitive multitouch mainstream with the first iPhone, intuitive gestures with the iPhone X, or the scroll wheel on the iPod), but it's pretty removed from most programming and other subfields of CS. As others have pointed out, it lies somewhere in the realm between CS and psychology/cog sci.",
        "author": "ObjectBrilliant7592",
        "created_utc": 1741093308,
        "score": 31,
        "parent_id": "t3_1j36u7q",
        "depth": 0
      },
      {
        "id": "mfxzz4l",
        "body": "Computer science grew out of mathematics. When I studied CompSci in the 90s, my school made a big deal of the fact that its CS was its own thing and no longer just a sub-area of math. Most of traditional CS is either fully mathematics, or slightly skewed mathematics.\n\nIn grad school, I took an HCI course. My professor got a masters in psychology before his phd in CS. He very much stressed that psychology was the fundamental area that HCI builds upon.\n\nPerhaps, along with all of the math, CS undergrads should have psychology as a mandatory course (or as a heavily suggested elective.) HCI is important and useful, but I think it has been neglected simply because, unlike the rest of CS, it's not math at its core.",
        "author": "Old-Pianist-599",
        "created_utc": 1741087960,
        "score": 18,
        "parent_id": "t3_1j36u7q",
        "depth": 0
      },
      {
        "id": "mfy80do",
        "body": "What I noticed after starting studies and getting a job is that I prefer that the software I make is used by other computer scientists and technical people. I honestly don't like making stuff for the layman, because then I have to make it pretty and think about the human aspect (UX) more than what I like to think about and solve- the technical issues. This is something that I noticed among my peers as well, as from experience- nerds don't understand the layman and a big portion are incapable of producing something that the average person or even the targeted business person will be able to happily use. Emphasis on happily. But that's just me and my environment's observation.",
        "author": "androidAlarm",
        "created_utc": 1741091676,
        "score": 7,
        "parent_id": "t3_1j36u7q",
        "depth": 0
      },
      {
        "id": "mfxuugj",
        "body": "I think voice assistants and NLP will probably spur a new wave of growth/interest.",
        "author": "DSPGerm",
        "created_utc": 1741085153,
        "score": 4,
        "parent_id": "t3_1j36u7q",
        "depth": 0
      },
      {
        "id": "mfzmpn4",
        "body": "Although I have previously enumerated HCI - sometimes using the term of interaction design that I occasionally use synonymously - as a part of CS, I also think HCI has a lot that distinguishes itself from the rest of CS. As the most trivial examples, consider the following: Most of CS (exception: classical AI) does not use theories of cognition. Much of HCI is not concerned with the mathematical formalisms that underlie computation that are so fundamental to CS. I've come across the argument that CS is more appropriately termed 'computation science', because - as the adage goes - it is only as much about digital computers as astronomy is about telescopes.\n\nOn HCI, I'd say HCI is a cross between computer science and human factors engineering, with a fair bit of aesthetics added to the mix (especially if you consider something like game design). But being a 'cross' between disciplines doesn't necessarily mean that it has no independent existence of its own. In a similar vein, you could say that chemistry is a bridge between physics and biology, or cognitive science is the intersection of psychology, philosophy, linguistics, neuroscience, AI, and anthropology.",
        "author": "WilliamEdwardson",
        "created_utc": 1741107741,
        "score": 4,
        "parent_id": "t3_1j36u7q",
        "depth": 0
      },
      {
        "id": "mfygxwh",
        "body": "Can’t speak for anyone else, but personally I studied CS because I liked math, analytical and logical thinking and programming. HCI is pretty far from that judging from my limited experience with it and even though I had one or two classes in my undergrad I did not find much enjoyment in it because it ventures too far into psychology, sociology and philosophy for my liking",
        "author": "chaoz_dude",
        "created_utc": 1741095142,
        "score": 4,
        "parent_id": "t3_1j36u7q",
        "depth": 0
      },
      {
        "id": "mfyd68z",
        "body": "At my university it was very popular, and we had great professors in HCI who all came from a computer science background.  The things I learned in those HCI courses have helped me stand out compared to my coworkers for my whole career honestly",
        "author": "throwaway_dddddd",
        "created_utc": 1741093741,
        "score": 3,
        "parent_id": "t3_1j36u7q",
        "depth": 0
      },
      {
        "id": "mfy368u",
        "body": "Because it aint really CS: its Psychology (especially cognitive psych). Not that there is anything wrong with that, but most places put HCI in the wrong school.",
        "author": "Snoo_87704",
        "created_utc": 1741089530,
        "score": 2,
        "parent_id": "t3_1j36u7q",
        "depth": 0
      },
      {
        "id": "mfybgjb",
        "body": "It was my degree that I took a long time ago. Modular CS + Psychology course. \n\nIn the end I realised that CS was more my thing and every interaction I've had in my career with UX people has only really reinforced that.",
        "author": "isomies",
        "created_utc": 1741093074,
        "score": 2,
        "parent_id": "t3_1j36u7q",
        "depth": 0
      },
      {
        "id": "mfz6ag0",
        "body": "At my university, HCI is the most popular CS major specialization, so I wouldn’t call it unpopular necessarily",
        "author": "JSerf02",
        "created_utc": 1741103225,
        "score": 2,
        "parent_id": "t3_1j36u7q",
        "depth": 0
      },
      {
        "id": "mg01w9n",
        "body": "You’ll find it’s appreciated more in post graduate studies with master programs purely dedicated to it. it’s obviously underrated as it has a huge influence on computing and the industry in general. safe to say that Apple is Apple because of their dedication to HCI research.",
        "author": "Vanilla_mice",
        "created_utc": 1741111941,
        "score": 2,
        "parent_id": "t3_1j36u7q",
        "depth": 0
      },
      {
        "id": "mg32i5t",
        "body": "Shhh, don’t tell them about us and how much fun we’re having. Keep it a secret, yeah? Thanks.",
        "author": "fatso784",
        "created_utc": 1741144523,
        "score": 2,
        "parent_id": "t3_1j36u7q",
        "depth": 0
      },
      {
        "id": "mfxma89",
        "body": "The course sucks. In course form its just webdev even though concept wise its xr...\n\nCs departments havent adjusted at all.",
        "author": "Esper_18",
        "created_utc": 1741079956,
        "score": 2,
        "parent_id": "t3_1j36u7q",
        "depth": 0
      }
    ],
    "1j2j5t3": [
      {
        "id": "mfs5pk0",
        "body": "One example where unlabeled data is extremely useful is in identifying clusters. You can feed a model unlabeled data and find clusters of similar data points. This helps determine which cluster a new data point belongs to when it arrives. This approach is especially useful when trying to classify data points based on similarities and dissimilarities.\n\nThis is just one basic example. There are several other important uses.",
        "author": "skysocial",
        "created_utc": 1741011167,
        "score": 12,
        "parent_id": "t3_1j2j5t3",
        "depth": 0
      },
      {
        "id": "mfs4j7o",
        "body": "Supervised leaning is where you use labelled data. In unsupervised learning, you can use unlabelled data. Unsupervised learning is a large field, but you can get a good overview of it from Wikipedia. [Unsupervised learning - Wikipedia](https://en.wikipedia.org/wiki/Unsupervised_learning)",
        "author": "Magdaki",
        "created_utc": 1741010734,
        "score": 9,
        "parent_id": "t3_1j2j5t3",
        "depth": 0
      },
      {
        "id": "mfshllt",
        "body": "Self-supervised learning can help you do many things - matching, searching, filtering out data.",
        "author": "MrTroll420",
        "created_utc": 1741015257,
        "score": 3,
        "parent_id": "t3_1j2j5t3",
        "depth": 0
      },
      {
        "id": "mfs7wpl",
        "body": "Check also weekly supervised ML. I did my bachelor's thesis about that and I found it interesting",
        "author": "Sagarret",
        "created_utc": 1741011957,
        "score": 2,
        "parent_id": "t3_1j2j5t3",
        "depth": 0
      },
      {
        "id": "mfsvg4a",
        "body": "You use the data as its own label. \n\nYou predict one part of the data from another part of the data (e.g., the next word from previous words), and in doing so you learn the structure and patterns present within it.",
        "author": "currentscurrents",
        "created_utc": 1741019397,
        "score": 2,
        "parent_id": "t3_1j2j5t3",
        "depth": 0
      }
    ],
    "1j25ua3": [
      {
        "id": "mfp8bqm",
        "body": "There are two general types of hypervisors. \n\nType 1 hypervisors are hypervisors that directly control the resources of the system. Think of the hypervisor AS the OS in this case. This is like your VMware ESXi’s of the world.\n\nType 2 hypervisors are hypervisors that enable virtualization on top of an existing OS. For that to happen, drivers must be created for those virtualization applications to talk to the kernel and get the resources and other things they need to run, as opposed to a type 1 hypervisors where the drivers are essentially built in because, well, it IS the OS so to speak.\n\nother people feel free to add more specifics or correct me on anything i missed",
        "author": "Ok-Development4479",
        "created_utc": 1740962316,
        "score": 22,
        "parent_id": "t3_1j25ua3",
        "depth": 0
      },
      {
        "id": "mfpa5sm",
        "body": "It enables you to isolate applications entirely.\n\nIn the extreme case, AWS EC2 is running hypervisors to managed multiple EC2 instances from different customers running on the same machine; it is imperative everything is isolated. So you have a hyper visor which runs multiples Virtual Machines.\n\nEven if you own your own hardware, it is best practice to not just run all services in one OS; but rather each application / microservice / whatever runs in its own environment. This has security benefits as well as ease-of-modifying the system benefits (sorta of like not writing one big function but splitting it into multiple smaller, easier to test / observe functions)",
        "author": "Any-Illustrator-9808",
        "created_utc": 1740962939,
        "score": 7,
        "parent_id": "t3_1j25ua3",
        "depth": 0
      }
    ],
    "1j1kuyq": [
      {
        "id": "mfkib0b",
        "body": "In theoretical terms, knowing BB(27) would allow you to solve the Goldbach conjecture.\n\nIn practical terms, attempting to find BB(27) and then attempting to use that to solve the goldbach conjecture would be a fools errand. BB(27) is such an astronomically large number that the very stars will die, and the largest black holes in the cosmos will wither away and evaporate, and white dwarves will convert themselves to iron, and the heat death of the universe will be absolute and complete, and there will still be a nigh-countless number of steps left to execute.\n\nThere are more steps to execute than particles in the observable universe.\n\nThere are more *digits* in the number of steps to execute than there are particles in the cosmos.",
        "author": "pseudomonica",
        "created_utc": 1740899166,
        "score": 29,
        "parent_id": "t3_1j1kuyq",
        "depth": 0
      },
      {
        "id": "mfkhisb",
        "body": "> the _only_ way to calculate BB(27) by determining whether or not the 27-state Goldbach Conjecture machine halts or not (italics added for emphasis)\n\nThis is the problem with your logic. Maybe we can find a more clever way to do it. (I doubt it though.)\n\nPractically speaking, the busy beaver functions are useless for solving anything exactly because of the issue you point out. It's not just the Goldbach Conjecture too. Every problem in mathematics that you can encode in a small enough Turing Machine will have to be solved to compute the busy beaver numbers. And there's already a known collatz-like function in BB(6) called Antihydra which is currently unsolvable. As Paul Erdos once said, \"Mathematics is not yet ready for such problems.\"\n\nIn the real world, even if we had a magic oracle that just told us the 27th busy beaver number, it's not like we could actually run a machine for that long either.",
        "author": "nubcake9000",
        "created_utc": 1740898719,
        "score": 5,
        "parent_id": "t3_1j1kuyq",
        "depth": 0
      },
      {
        "id": "mfmbsdt",
        "body": "I am curious if it works both ways? Like if we solve goldbach's conjecture could we compute BB(27)?",
        "author": "matthkamis",
        "created_utc": 1740930374,
        "score": 2,
        "parent_id": "t3_1j1kuyq",
        "depth": 0
      }
    ],
    "1izivni": [
      {
        "id": "mf38xqq",
        "body": "Implementing your algorithms will always force you to deal with all the \"simplifying assumptions\" that you made in the theory. Much like physicists ignoring air resistance and friction: in an actual experiment they will apply.\n\nCommon assumptions: \n\n* ignoring data locality/assuming arbitrary memory access will fail the second you use a modern cpu/ram/ssd architecture.\n* constant-time for hash access will bite you in the ass when you notice many built-in hashmaps internally use a tree structure\n* assuming constant-time for arbitrary large number arithmetics will fail the second you exceed 64 bits.\n* one of the more interesting ones: conflicting assumptions about the underlying data structure. E.G. There are graph operations that are fast when you represent a graph as two-dimentional adjacency matrix (swtiching all incoming edges between two nodes) and operations that are fast when your represent a graph as a list of edges and a list of nodes (e.g. removing a node that has no edges). I have seen a paper assuming two operations are fast citing two papers but missing that both of these assumed different internal data representations that were incompatible.\n* there are more wild assumptions like the theoretical ram machine working with arrays of arbitrary size without need for initializing them or other operations that are provably non-constant time being assumed as constant.\n\nAll of these are things that a good theory paper/thesis should account for, but I have even seen a lot of published work that makes some of these assumptions without even mentioning them.\n\nI have been where you are, statistically confirming theory results in python. It wasnt that bad and I learned a lot and in my case practice results where off by a log factor which was in itself a very interesting discovery.\n\nMy advice is:\n\nDo not cheat and try to solve deviation from theory. Instead publish your findings on any parts where the theory does not match practice, it will be a much more valuable result than just confirming something!",
        "author": "sumpfriese",
        "created_utc": 1740672692,
        "score": 122,
        "parent_id": "t3_1izivni",
        "depth": 0
      },
      {
        "id": "mf38ldy",
        "body": "To an extent? It's more language specific edge cases that make things awkward, but they're generally not that bad if you've written some computer-leaning pseudocode.",
        "author": "DTux5249",
        "created_utc": 1740672593,
        "score": 16,
        "parent_id": "t3_1izivni",
        "depth": 0
      },
      {
        "id": "mf39x0h",
        "body": "Depends on what you mean. Some state-of-the-art algorithms in terms of runtime complexity were published in papers that were hundreds of pages long. I would imagine some of those are more of theoretical than practical interest.\n\nBut it is usually the case that a theoretically described algorithm takes a lot of work to implement. I am thinking of Gilbert-Johnson-Kerthi since I did that most recently. It's a collision detection algorithm with a computational geometry bent. Took me over a thousand lines and a few weeks to get it right, plus more for debugging.\n\nReal algorithms are real work. Seeing what's involved and deciding whether you like it or not is the purpose of your senior thesis.",
        "author": "PersonalityIll9476",
        "created_utc": 1740672972,
        "score": 12,
        "parent_id": "t3_1izivni",
        "depth": 0
      },
      {
        "id": "mf53ss1",
        "body": "Breaking ties is a choice. Compare it to rounding x.5 to the nearest whole number. Many ways to decide it. You just need to choose one. Sometimes there's a good reason to choose one, and sometimes not. But thinking about the consequences of propagating the error you're introducing just by rounding is a good start.\n\nSo in your case, what are the consequences of always choosing choice A vs choice B? What if it's the opposite? What if it's alternate? What if it's random? What if it's based on a literal A/B experiment using humans to choose?\n\nIf you have time and think that showing the effort will create value for the time, you can simulate some or all of the methods and see which performs the best in the end.\n\nOr just bag it and call random(). But then what if random() returns 0.5 ......",
        "author": "userhwon",
        "created_utc": 1740691603,
        "score": 3,
        "parent_id": "t3_1izivni",
        "depth": 0
      },
      {
        "id": "mf5tu3t",
        "body": "Might not be that relevant to the discussion, but sometimes when implementing a new algorithm from a paper I find that the author did not put enough detail into the algorithm description or the pseudo code is not very close to a typical programming language.",
        "author": "Liam_Mercier",
        "created_utc": 1740699593,
        "score": 3,
        "parent_id": "t3_1izivni",
        "depth": 0
      },
      {
        "id": "mfcnen2",
        "body": "If you go far enough into certain corners of TCS, there are algorithms that are utterly unimplementable in any realistic way. It's common in some places to see phrases like \"and then use semi-definite programming\", which usually means there's not a chance in hell it'll ever run on anything bigger than n=10 and even then only on specially chosen cases. The Lovasz theta function is one example of this, and that's a famous enough property that a lot of people have put effort into it.",
        "author": "thesnootbooper9000",
        "created_utc": 1740789224,
        "score": 3,
        "parent_id": "t3_1izivni",
        "depth": 0
      },
      {
        "id": "mf3bdtz",
        "body": "Certainly possible. There are things that are easy to describe in natural language or mathematics that can be hard to code. Heck, my PhD thesis has plenty of those, which I'm getting the joy of re-experiencing since I'm recreating it in Python.",
        "author": "Magdaki",
        "created_utc": 1740673392,
        "score": 2,
        "parent_id": "t3_1izivni",
        "depth": 0
      },
      {
        "id": "mf7t53g",
        "body": "Several of the undergraduate dissertations I am supervising often involve implementing complicated algorithms based on pseudocode from papers. In most cases this works out fine, but there are implementation details to be considered or choices to be made. Something that comes up often is numerical issues that have to do with rounding errors. In one case this “broke” an algorithm, as these errors prevent it from running in practice, while in theory it is perfectly fine.",
        "author": "Fresh_Meeting4571",
        "created_utc": 1740727786,
        "score": 2,
        "parent_id": "t3_1izivni",
        "depth": 0
      }
    ],
    "1izle43": [
      {
        "id": "mf3rybj",
        "body": "Me who learned this shit from Minecraft communities: (Don't do that)\n\nBut yeah a good start would be to design stuff in logic simulation tools. Nandgame is free and simple, but it probably isn't fully beginner friendly.",
        "author": "Rude-Pangolin8823",
        "created_utc": 1740678056,
        "score": 3,
        "parent_id": "t3_1izle43",
        "depth": 0
      },
      {
        "id": "mf3uzuv",
        "body": "A book that I recommend is \"CMOS VLSI Design - A Circuits and Systems Perspective\" by Weste and Harris.\n\nIt's well written, full of good drawings and photos, and is a pleasure to read (it even has 'historical perspective' sections, so you can understand why things are the way they are).",
        "author": "BigPurpleBlob",
        "created_utc": 1740678908,
        "score": 3,
        "parent_id": "t3_1izle43",
        "depth": 0
      }
    ],
    "1iyxdwx": [
      {
        "id": "mey9gvk",
        "body": "In general, you can't.\n\nYou can in certain situations, but Turing showed that in general it's impossible to know whether the machine will stop or not.\n\nFor example, if at some point in the computation it's, on average, going right or left onto virgin tape and reading and leaving the same pattern on the tape then it's clearly stuck in a loop. But other more complicated patterns you can't know you just have to run it.",
        "author": "wolfkeeper",
        "created_utc": 1740602749,
        "score": 94,
        "parent_id": "t3_1iyxdwx",
        "depth": 0
      },
      {
        "id": "mey8efm",
        "body": "That’s the neat part. You don’t! If I understand it correctly, you’ve stated the halting problem. There is no solution to it as of yet.",
        "author": "lolnaender",
        "created_utc": 1740602459,
        "score": 46,
        "parent_id": "t3_1iyxdwx",
        "depth": 0
      },
      {
        "id": "meyf5m2",
        "body": "There is no sure fire way to test this for all cases without running the code/tape first. At that point, you wouldn’t be able to tell the difference between the two cases, as there might not be enough time left in the universe to actually find the end, if it exists. That’s my understanding anyway",
        "author": "lv_oz2",
        "created_utc": 1740604297,
        "score": 12,
        "parent_id": "t3_1iyxdwx",
        "depth": 0
      },
      {
        "id": "mezfzd3",
        "body": "Looping means that it will eventually get back to the same state again. Termination means the complete state of the machine is always changing.\n\nIf you could remember every state it's ever been in, you could detect a cycle.\n\nAnother approach is to run the machine twice, at different speeds. E.g. compare their states every time an instruction is executed on one, and every two instructions on the other. If the slower state matches the faster one, it means the faster one has entered a loop.\n\nThis is Floyd's tortoise and hare.\n\nhttps://en.m.wikipedia.org/wiki/Cycle_detection\n\n(edit: \n\nthis can only tell you if it is looping, it can't tell you if it's going to terminate otherwise - because you have theoretically infinite tape, you may be running a program that never has a cycle but is still a non-terminating program. I.e. a non-looping program can still be a non-terminating program.\n\nIf your machine is like a real computer that has a finite but large number of states - then you will eventually find a cycle)",
        "author": "unsignedlonglongman",
        "created_utc": 1740615321,
        "score": 4,
        "parent_id": "t3_1iyxdwx",
        "depth": 0
      }
    ],
    "1iyka7m": [
      {
        "id": "mf18nm4",
        "body": "what really happened is, it doesn't create a function that just evaluates f'. it creates a function F that computes (f,f') at the same time. but nothing is run yet. the actual running happens when you plug in a specific number x0. we plug in F(x0+eps) to actually runtime evaluate f(x0) and f'(x0) - and with F built based on autodiff, this evaluation turns out to be of the same complexity as evaluating f(x0) itself (up to a constant), because we expand every single computation step in f on real numbers to a corresponding step in F on dual numbers.\n\nnote this computation can even involve conventionally non-differentiable functions like \"if\" (e.g. when f is a step-wise function). we're allowed to do it because we're evaluating on a concrete point x0. it may take a different branch when evaluating F(x1), but again, it would take the same branch as f(x1) would take and therefore spend the same amount of time as f(x1) would do, up to a constant. but this could be dramatically different from f(x0)'s time and that's ok.",
        "author": "ktrprpr",
        "created_utc": 1740640672,
        "score": 3,
        "parent_id": "t3_1iyka7m",
        "depth": 0
      }
    ],
    "1ixmn3m": [
      {
        "id": "meng5ry",
        "body": "Will let you know when I finish. I started in the 90s.",
        "author": "Goingone",
        "created_utc": 1740458647,
        "score": 104,
        "parent_id": "t3_1ixmn3m",
        "depth": 0
      },
      {
        "id": "menic5s",
        "body": "They’re amazing texts, though they’re definitely references. Great to have as a flex though in a book collection :D \n\nExcellent for the broad material they cover. Donald Knuth is a legend.",
        "author": "telesonico",
        "created_utc": 1740459602,
        "score": 29,
        "parent_id": "t3_1ixmn3m",
        "depth": 0
      },
      {
        "id": "meowpwh",
        "body": "Think of it this way: Knuth discusses _types of algorithms_. \n\nOne type of algorithm is the set the low-level functions you might find in glibc: random number generator, sorting function, etc.\n\nAnother type is composed of the kinds you might use for building a structure that is easy to both insert new data into, and efficient to search. This is what is meant by data _structures_.\n\nAnother type (think the multi-part volume 4) is composed of the class of algorithms that deal with breaking down certain problems that seem to so quickly scale to levels that are not quickly solved.\n\nAll of this has a common thread of problems that are easily to implement _incorrectly_ so he shows you how to think about them correctly, and are at a deeply foundational level - again for the library designer.\n\nHe doesn’t talk about “bumper sticker principles of software design” like KISS and DRY.\n\nHe doesn’t talk about “design paradigms” which are useful when designing a class of methods.\n\nHe doesn’t talk about how to write a software system that can be maintained even when it becomes millions of lines of code. \n\nHe doesn’t talk about even mid-level concepts like database structure.\n\nHe doesn’t talk about parallelism etc.\n\nHe talks about kinds of algorithms at the lowest level and shows us how to approach them in a mathematically rigorous way.\n\nFor the things he talks about, he writes in a way that is both funny and intriguing. His exercises are world class. The value of the books is best found in doing the exercises. Not doing them is like reading a book on cooking without stepping into a kitchen and preparing some food.\n\nPeople purchasing his books looking for large scale software architectures and principles, or who complain these aren’t covered are simply not understanding what they do cover.",
        "author": "EachDaySameAsLast",
        "created_utc": 1740487054,
        "score": 29,
        "parent_id": "t3_1ixmn3m",
        "depth": 0
      },
      {
        "id": "meopf1a",
        "body": "Great books indeed.\n\nBut hard reads.\n\nI doubt they're read as much as they're being praised.",
        "author": "DeGamiesaiKaiSy",
        "created_utc": 1740483678,
        "score": 11,
        "parent_id": "t3_1ixmn3m",
        "depth": 0
      },
      {
        "id": "meo1e3e",
        "body": "Ah, yes: this question.\n\nI hear Bill Gates may still be holding that job for whoever can complete all of the exercises in these books.",
        "author": "Ok-Interaction-8891",
        "created_utc": 1740469437,
        "score": 10,
        "parent_id": "t3_1ixmn3m",
        "depth": 0
      },
      {
        "id": "meogofc",
        "body": "Knuth showed me the difference between being a script kiddie and actually having talent in the field.  A true example of genius.",
        "author": "TheGreatRao",
        "created_utc": 1740478772,
        "score": 9,
        "parent_id": "t3_1ixmn3m",
        "depth": 0
      },
      {
        "id": "mepj4ea",
        "body": "I studied a bit of his Concrete math book, thought it was pretty enjoyable.",
        "author": "No_North_2192",
        "created_utc": 1740495024,
        "score": 7,
        "parent_id": "t3_1ixmn3m",
        "depth": 0
      },
      {
        "id": "mezsq8f",
        "body": "They're all amazing.  VERY slow read.  And very hard read.  But low level real programming and not pop bullshit.\n\nAlso riddled with hidden jokes that you wouldn't catch onto.  \n\n\\* Index entry for \"self referential code\" is the same page\n\n\\* At the end of each chapter, he has questions for students.  They're ranked 1-5, where 5 you can get a PhD , 4 would be a tough CS test question, and 1 in trivial.  He ranked fermat's last theorem a 4 - which wasn't yet solved when he wrote it...\n\nIf you find a mistake, he used to write you a $1 check.\n\nGlad he's still alive.  He's going to still release a couple more I think?",
        "author": "DorkyMcDorky",
        "created_utc": 1740619455,
        "score": 3,
        "parent_id": "t3_1ixmn3m",
        "depth": 0
      },
      {
        "id": "meq9rg6",
        "body": "They're fun, but milage may vary for today's \"CS\" crowd.",
        "author": "No_Jelly_6990",
        "created_utc": 1740502886,
        "score": 2,
        "parent_id": "t3_1ixmn3m",
        "depth": 0
      },
      {
        "id": "mew36w6",
        "body": "His philosophies apply somehow even more to modern programming, I've found across my 30+ years",
        "author": "Silly_Guidance_8871",
        "created_utc": 1740580599,
        "score": 2,
        "parent_id": "t3_1ixmn3m",
        "depth": 0
      }
    ],
    "1ix77yw": [
      {
        "id": "mejrumc",
        "body": "Get an Arduino, a raspberry pi or similar and build simple toys or sensors for measuring something or doing something.\n\nI think you can program them with scratch or similar too, I am not sure.",
        "author": "Sagarret",
        "created_utc": 1740417703,
        "score": 56,
        "parent_id": "t3_1ix77yw",
        "depth": 0
      },
      {
        "id": "mejv15w",
        "body": "It may be time to level up to a professional programming language.  \nI'd suggest Python, reading the manual should take about a week or so.  \nThen she'll have access to thousands of libraries to do whatever she wants.  \nAnd Python is awesome to learn code indentation, classes, inheritance, asynchronous programming...",
        "author": "Kmarad__",
        "created_utc": 1740418589,
        "score": 24,
        "parent_id": "t3_1ix77yw",
        "depth": 0
      },
      {
        "id": "mejs8ss",
        "body": "Try the website codewars.com. They give small random coding challenges that basically come down to \"we give you this data, do something with it and show us the result\"",
        "author": "iTsaMe1up",
        "created_utc": 1740417814,
        "score": 7,
        "parent_id": "t3_1ix77yw",
        "depth": 0
      },
      {
        "id": "mejvnwr",
        "body": "I had fun with LEGO Mindstorms when I was about that age. If you have the money for it, maybe consider its successor, [Spike](https://education.lego.com/en-us/products/lego-education-spike-essential-set/45345/).",
        "author": "MagicalPizza21",
        "created_utc": 1740418767,
        "score": 7,
        "parent_id": "t3_1ix77yw",
        "depth": 0
      },
      {
        "id": "mel4jxd",
        "body": "Highly recommend getting her an Arduino or Raspberry Pi kit. After I had built my first website at 10yrs old, my dad bought me a microcontroller kit(similar to Arduino), and it awoke a totally new passion for me. It’s programming still, but you get to make lights light up, screens display things, and make motors spin with your code! A full kit is anywhere from $40-$150, but it will keep her busy for years. \n\n\nGood luck, and I LOVE that you’re feeding this passion of hers. My dad did the same for me, and now I’m a self-taught software engineer making more than I could’ve ever dreamed of. No college 😏",
        "author": "UnnecessarySalt",
        "created_utc": 1740431374,
        "score": 4,
        "parent_id": "t3_1ix77yw",
        "depth": 0
      },
      {
        "id": "mek4979",
        "body": "I got into computer programming when I was 10 because I wanted to make games, and I think games are often an attractor for kids, which is why a lot of content focuses on that.\n\nMaybe as her what might be of interest? As above, for me it was games, but for her it might be something else. For example, if she likes puzzles, then maybe a program to solve puzzles like Sudoku. Or maybe she could make a program to operate as a personal assistant for scheduling her time. Or if she has other interests, then something related to that. Say gardening, she could create a database of what is currently growing and track the growth. In short, let her interests be the guide as this will keep it compelling.",
        "author": "Magdaki",
        "created_utc": 1740421149,
        "score": 2,
        "parent_id": "t3_1ix77yw",
        "depth": 0
      },
      {
        "id": "mek4g6q",
        "body": "Games are a pretty good goal for learning problem solving though.\n\nHow about Pico-8 ?",
        "author": "scoby_cat",
        "created_utc": 1740421204,
        "score": 2,
        "parent_id": "t3_1ix77yw",
        "depth": 0
      },
      {
        "id": "mekxw3u",
        "body": "Factorio",
        "author": "whitehorrse",
        "created_utc": 1740429519,
        "score": 2,
        "parent_id": "t3_1ix77yw",
        "depth": 0
      },
      {
        "id": "mem7i2g",
        "body": "teach her python\n\nif u want i can send u some good resources/advice",
        "author": "Immediate-Country650",
        "created_utc": 1740443028,
        "score": 2,
        "parent_id": "t3_1ix77yw",
        "depth": 0
      },
      {
        "id": "memg07u",
        "body": "Get him Linux mint cinnamon",
        "author": "LinuxPowered",
        "created_utc": 1740445787,
        "score": 2,
        "parent_id": "t3_1ix77yw",
        "depth": 0
      }
    ],
    "1ixb3bn": [
      {
        "id": "mekv29h",
        "body": "In a Deterministic Finite Automaton you have access to two variables: the current state, and the current symbol. This puts some pretty severe limits on what kinds of patterns you're able to represent.\n\nIn a PDA we introduce the concept of a stack, so that you can respond to not only the current symbol and state, but a history of prior symbols or states as recorded in the pushdown stack. However, this history is quite limited: you can only access the top element in the stack, and removing it to access the element underneath is destructive - there's no way to read elements deeper in the stack without throwing away some information.\n\nA Turing Machine extends the PDA's idea of 'memory' by making memory a tape, rather than a stack, so that you can move left or right along the tape to read and write values without throwing away data to get there.\n\nIn a plain Turing Machine the same tape of unbounded length is used for input and memory - but you can simulate a Turing Machine with an arbitrary number of tapes using a Turing Machine with a single tape, so you can easily abstract the concept to \"imagine we have one tape for inputs and one tape for memory, or even multiple tapes for different kinds of memory.\"",
        "author": "nuclear_splines",
        "created_utc": 1740428726,
        "score": 30,
        "parent_id": "t3_1ixb3bn",
        "depth": 0
      },
      {
        "id": "mel5bj9",
        "body": "Aren't TMs basically equivalent to having 2 PDA where you can pop off the top element of one PDA and put it on the other?",
        "author": "Affectionate_Pizza60",
        "created_utc": 1740431589,
        "score": 4,
        "parent_id": "t3_1ixb3bn",
        "depth": 0
      }
    ],
    "1iwgu6o": [
      {
        "id": "mee6ru8",
        "body": "Don't stop, build a ternary CPU (or whatever you like) in a circuit simulator, there are many free options for circuit simulation software.",
        "author": "could_be_mistaken",
        "created_utc": 1740339806,
        "score": 105,
        "parent_id": "t3_1iwgu6o",
        "depth": 0
      },
      {
        "id": "meeenqq",
        "body": "This is a really cool achievement, hopefully you manage to build or emulate it someday if you're interested in this! However, I'd like to just comment on the idea that this approach would make phones, servers etc. more efficient, because I'm not sure it would—there's very good reason computers have taken the path they have. One of the biggest is the fact that the more voltage states you need, the more difficult it is to practically build the number of gates you'd need (you need *greatly* improved precision to tell the difference between multiple voltage levels as compared to simply \"some\" and \"none\") as well as the more power you need to draw. Additionally, we have an entire world economy build around the efficient, streamlined production of transistors at immense scales—the benefits of any alternative would need to be off-the-scale *immense* (think quantum computing) to result in a practical performance improvement: sure I could buy a ternary processor, or I could buy orders of magnitude more processing power in the form the amount of binary ones. I don't mention this to dissuade you in any way, but just to give some reason as to why it might be difficult to encourage others to help you build this—simulation or emulation would probably be the best place to start, and could help in pitching further work if you're still interested 🙂",
        "author": "Mcby",
        "created_utc": 1740342112,
        "score": 46,
        "parent_id": "t3_1iwgu6o",
        "depth": 0
      },
      {
        "id": "meezwag",
        "body": "Circuit Simulators, as many mention, should let you put together and demonstrate your designs. Look into FPGAs, using  Verilog and the like, practical (binary) processors can be designed and run. Especially older/used ones, can be had for very little money (relatively speaking). \n\nForgive my limited (and rusty) electronics knowledge, but do you have a design for whatever the ternary equivalent of a flip-flip is -- a circuit to store and retrieve a trit?  Also, I'd be curious what sort of logic falls out of being in ternary, that is beyond generalizing binary logic operators. Elegant circuits using ternary-specific operators, particularly, if they out shine binary equivalents, would be pretty interesting.",
        "author": "dnabre",
        "created_utc": 1740348479,
        "score": 11,
        "parent_id": "t3_1iwgu6o",
        "depth": 0
      },
      {
        "id": "medxtry",
        "body": "Can you explain a little more about how you use the transistors to get 3 states?",
        "author": "RobotJonesDad",
        "created_utc": 1740337208,
        "score": 8,
        "parent_id": "t3_1iwgu6o",
        "depth": 0
      },
      {
        "id": "mee46f9",
        "body": "Why a ternary, just for the fun of it? Im not an ECE guy, but i've heard that its just way more expensive for minimal benefit.\n\nI think I only know about flash memory using more than 2 states as a practical application.",
        "author": "TheBlasterMaster",
        "created_utc": 1740339053,
        "score": 5,
        "parent_id": "t3_1iwgu6o",
        "depth": 0
      },
      {
        "id": "meih4qf",
        "body": "Couldn't you design a simple breadboard computer?",
        "author": "Rude-Pangolin8823",
        "created_utc": 1740403088,
        "score": 2,
        "parent_id": "t3_1iwgu6o",
        "depth": 0
      }
    ],
    "1iwg945": [
      {
        "id": "medoomw",
        "body": "No. A computer, fundamentally, is just a bunch of logic gates. We can recreate those in Minecraft quite easily, usually using redstone torches. This is where the problem lies though; to recreate a single gate in Minecraft requires millions of real world gates. Because of how many steps are in between Minecraft and the physical gates, there is a massive loss of efficiency. Hence, the only way it would be possible to create a better virtual computer than what it is being ran on is to violate the law of energy conservation.\n\nAlso, there absolutely are hard limits on space in Minecraft. You would run out of hard drive space much sooner than you could recreate a modern CPU.",
        "author": "dylantrain2014",
        "created_utc": 1740334617,
        "score": 218,
        "parent_id": "t3_1iwg945",
        "depth": 0
      },
      {
        "id": "medpr1i",
        "body": "nope. you'll never get a computer running inside a computer that's more powerful that the outer computer.\n\nso the resources are storage and time. it will always take at least as much storage in the outer computer as storage you have in the inner computer. \n\nand it will always take at least one \"tick\" or processing unit on the outer computer to process.\n\nthis is the same for virtual machines of all kinds. if the inner computer has access to storage, the outer computer must have that storage to give to the inner one. if the inner computer is performing a calculation, that calculation is actually happening on the outer computer. \n\nthe inner computer can't perform more processing than the outer computer can, and can't access storage the inner computer can't. \n\nother than storage and time (well, and peripherals, kind of), all computers are equivalent.",
        "author": "Rcomian",
        "created_utc": 1740334921,
        "score": 37,
        "parent_id": "t3_1iwg945",
        "depth": 0
      },
      {
        "id": "mednbly",
        "body": "Well, the main issue is going to be clock speed. Since Minecraft runs at 20 ticks per second, that is going to be the fastest your theoretical clock could run. If that limitation were removed and you had theoretically infinite computing power to run the game, a Minecraft computer could be theoretically infinitely large.",
        "author": "Tdude179",
        "created_utc": 1740334227,
        "score": 22,
        "parent_id": "t3_1iwg945",
        "depth": 0
      },
      {
        "id": "meduadv",
        "body": "Hey, I'm one of the people that builds computers in Minecraft! No, computers in Minecraft will NEVER be more powerful than the device they run on, this breaks multiple laws of thermodynamics and even newton's laws, its not physically possible to simulate a system stronger than the system its running on.\n\nYou can't make it more complex either, since the data required on your real life computer to define one block of memory inside of the game would be larger. You could make it more complex (a more complex instruction set and architecture) with less memory, but it will never run faster or be able to compute more.\n\nThe most powerful mod for speeding up redstone and logic in the game, MCHPRS or Minecraft High Performance Redstone Server, can run a Minecraft computer at about 20KHz at its highest speed. That, as hyper optimized as it is, is about 200000 slower than the device it runs on.\n\nOn vanilla, using some hard exploits, you can reach up to like 1KHz, so about 20x slower, but with even more compromises.",
        "author": "Rude-Pangolin8823",
        "created_utc": 1740336197,
        "score": 26,
        "parent_id": "t3_1iwg945",
        "depth": 0
      },
      {
        "id": "medo1sr",
        "body": "The computer built inside would first be bottlenecked by the game itself, then the computer",
        "author": "TasserOneOne",
        "created_utc": 1740334435,
        "score": 2,
        "parent_id": "t3_1iwg945",
        "depth": 0
      },
      {
        "id": "medti1k",
        "body": "Wouldn’t be the most efficient emulation, to say the least… so no",
        "author": "Saiyusta",
        "created_utc": 1740335978,
        "score": 3,
        "parent_id": "t3_1iwg945",
        "depth": 0
      },
      {
        "id": "mee70lr",
        "body": "Everybody has covered the actual answer, which is \"no\", for a variety of practical reasons. But if you want to dig into this idea some more, here are some things to think about.\n\nIn Computer Science, we have the concept of the [Turing Machine](https://en.wikipedia.org/wiki/Turing_machine), which is theoretical kind of very simple computer. Anything you can \"compute\" can be computed on a Turing machine. It won't be fast, though. For a given level of technology, a Turing machine will require many more steps to complete a computation than a practical digital computer would. \n\nWe call a system \"Turing complete\" if it can simulate a Turing machine, and is therefore capable of doing any general computation. \n\nRedstone is Turing complete, and so you can simulate anything in Redstone that any modern computer can do. But Redstone is very slow, and it takes a lot of memory to store information. Similar to the Turing machine, it's going to be much slower and take more memory than implementing whatever logic you want to express in a form more \"native\" to the computer itself running on.",
        "author": "i_invented_the_ipod",
        "created_utc": 1740339877,
        "score": 2,
        "parent_id": "t3_1iwg945",
        "depth": 0
      },
      {
        "id": "meejbje",
        "body": "It depends on what you mean by faster. You could theoretically build a CPU in Minecraft with a massive ROB and huge L1, and simulate that on a cheap laptop. However, for simulation, there's often little correlation between the speed of the simulated design and the speed of the simulation itself.",
        "author": "Twobagsoflactose",
        "created_utc": 1740343509,
        "score": 2,
        "parent_id": "t3_1iwg945",
        "depth": 0
      },
      {
        "id": "meg4k22",
        "body": "\\>could a computer in Minecraft be more powerful than the very one it is built through?\n\nIt could have more capability in terms of instruction-set complexity, but not more performance because as it is simulated by millions of objects running on a piece of hardware with perhaps thousands of execution cores, it couldn't ever execute one \"instruction\" in on physical instruction cycle.\n\nThe minecraft computer is going to be less capable than an ordinary emulator program, which wouldn't have to deal with using many objects to actualize what is essentially one object, or with the spatio-temporal aspects of the operation.",
        "author": "userhwon",
        "created_utc": 1740361958,
        "score": 2,
        "parent_id": "t3_1iwg945",
        "depth": 0
      },
      {
        "id": "meghoh1",
        "body": "No, as that is physically impossible. Simulating a single component/operation/step on a computer implies more resources to simulate it, as you need to support it's simulation. Making the simulated computer faster would mean pulling performance ouf of thin air somehow.\n\nIt's like asking how to make a room bigger on the inside, and we are not the Doctor Who time machine over here.",
        "author": "MasterGeekMX",
        "created_utc": 1740366726,
        "score": 2,
        "parent_id": "t3_1iwg945",
        "depth": 0
      },
      {
        "id": "meh7hwx",
        "body": "this is like asking if you can build a bigger universe than ours out of legos.",
        "author": "No_Future6959",
        "created_utc": 1740378080,
        "score": 2,
        "parent_id": "t3_1iwg945",
        "depth": 0
      }
    ],
    "1iwf8qi": [
      {
        "id": "medeco2",
        "body": "The output here would be a binary yes or no for accept or do not accept. Think of it as a regular expression",
        "author": "jeffcgroves",
        "created_utc": 1740331636,
        "score": 33,
        "parent_id": "t3_1iwf8qi",
        "depth": 0
      },
      {
        "id": "medfar1",
        "body": "A deterministic finite automata is a pattern-recognition tool. You can think of it as \"under conditions x, y, and z, I want the computer to do a thing.\" You're correct that computers aren't very useful without the \"do a thing\" part, but right now you're focusing on how to recognize \"conditions x, y, and z.\"  Specifically you're starting with a very simplified view of a computer, understanding what kinds of states it can and can't represent, and moving towards more and more sophisticated computational models that approach what we use in the real-world, and how we think about computation and what it is possible to formally reason about and what it is not.",
        "author": "nuclear_splines",
        "created_utc": 1740331910,
        "score": 18,
        "parent_id": "t3_1iwf8qi",
        "depth": 0
      },
      {
        "id": "medectx",
        "body": "Many problems that computers handle, are decision problems, which can be formulated as \"is this string part of this language\"",
        "author": "niko7965",
        "created_utc": 1740331637,
        "score": 7,
        "parent_id": "t3_1iwf8qi",
        "depth": 0
      },
      {
        "id": "medgc2m",
        "body": "Decision problems are pretty convenient to reason about, partly because the output is simple but also because the theory developed for decision problems is easily extended to other types of problems through Turing reductions. Most problems can be solved using the solution to a related decision problem.",
        "author": "jonthesp00n",
        "created_utc": 1740332212,
        "score": 5,
        "parent_id": "t3_1iwf8qi",
        "depth": 0
      },
      {
        "id": "medt8ww",
        "body": "A lot of other answers are about FSMs/regexps in particular, but you're asking a much broader question.\n\nTheory of Computation realized that problems like \"find a shortest path in this graph\", or \"what is the most number of these constraints can that can be met simultaneously\" can ACTUALLY be posed as yes/no problems.  Namely, \"Here is a graph and one particular path; is it the *shortest* path?\" and \"Here are constraints and some particular number — is that number the *largest* number of satisfiable constraints?\".\n\nThe reasoning is, if you can answer those latter yes/no questions, it can be considered as good as knowing how to solve the original problem (e.g. do a binary search on the number, or 'just' look at *all* possible paths and ask if each is the shortest).\n\nSo regarding all computations as being given an input and saying Yes/No makes our framework much simpler & uniform, but still corresponds to what various models (DFAs, Context-Free Grammars, Turing Machines) are (and aren't) able to compute.\n\nSo now, think of a program's input as a bit-string (the input file, possibly representing a graph & 1 particular path, or representing a set-of-constraints & a number k).  If you have a machine that can say \"yes\" or \"no\" exactly when the input string does/doesn't represents a shortest-path [or largest #constraints], then we say you have \"solved\" that problem using that machine.",
        "author": "not-just-yeti",
        "created_utc": 1740335908,
        "score": 3,
        "parent_id": "t3_1iwf8qi",
        "depth": 0
      },
      {
        "id": "medfumb",
        "body": "\"Invalid email address \nYour email must contain @ and .\"\n\n(That's what regexes are mostly used for)",
        "author": "mobileJay77",
        "created_utc": 1740332070,
        "score": 3,
        "parent_id": "t3_1iwf8qi",
        "depth": 0
      },
      {
        "id": "mehd74i",
        "body": "Lots of things are basically a DFA.\n\nWhen parking meters didn’t have electronics to count money in them, they were basically DFAs. Same with old vending machines. The sequence of coins inserted is the “string” and the “alphabet” is the set of all coin types. Each “state” may refer to a discrete internal configuration. You could argue that a combination lock is also be a physical DFA that only accepts one input. In some sense, these objects are actually performing a type of computation on sequences of coins whose result is accepting your payment and giving you what you paid for.\n\n“Accepting” the string really is something akin to being able to send a signal that the input string was in the language. In a parking meter, that may be engaging a little latch that allows the parking meter to show that you paid for parking by raising a little flag. In a vending machine it may be releasing an interlock that prevents product from being dispensed.\n\nSo for the basic task of counting small amounts of money, a DFA is all that is required. \n\nRemember that it’s a computational model, meaning it’s just an abstraction of a much larger concept.",
        "author": "TSRelativity",
        "created_utc": 1740381221,
        "score": 3,
        "parent_id": "t3_1iwf8qi",
        "depth": 0
      },
      {
        "id": "medl8hb",
        "body": "> but don't computers spit out something meaningful?\n\nHow are matches the pattern, and doesn't match the pattern not meaningful?",
        "author": "authorinthesunset",
        "created_utc": 1740333632,
        "score": 2,
        "parent_id": "t3_1iwf8qi",
        "depth": 0
      }
    ],
    "1ivoj05": [
      {
        "id": "me79glc",
        "body": "I mean this will completely depend what country you're in but I don't think the stereotype is \"quirky\" so much as \"has poor social skills and probably personal hygiene\". Accurate or not, that's the big one.",
        "author": "Mcby",
        "created_utc": 1740247230,
        "score": 47,
        "parent_id": "t3_1ivoj05",
        "depth": 0
      },
      {
        "id": "me7tx8h",
        "body": "Autism",
        "author": "tabbyluigi101",
        "created_utc": 1740253096,
        "score": 14,
        "parent_id": "t3_1ivoj05",
        "depth": 0
      },
      {
        "id": "me7w9i2",
        "body": "I think you’re reading into it too much. They just say oh cool because they maybe don’t have anything else to say to relate. I say that when someone is a business major or something.\n\nI live in the US and I’ve never noticed anyone look at me weird for being an engineer.",
        "author": "FantasticEmu",
        "created_utc": 1740253780,
        "score": 7,
        "parent_id": "t3_1ivoj05",
        "depth": 0
      },
      {
        "id": "mea27oo",
        "body": "I'm sorry to say, but you are kind of propagating a myth on your own. There is no such stereotype. I have never in my life had anyone look at me funny or look away because of my interest in computers.\n\n\"I'm a CS student\"\n\n\"Oh cool\"\n\nWhat exactly do you expect here? \"Oh cool, what do you think about this new feature in the latest Nvidia chip?\"\n\nCS is such a wide field, how would you spark any conversation with this introduction?\n\n\"I'm in my last year of CS. I got a major interest in digital graphics. I'm thinking of joining either a game studio or a movie studio, I'm still undecided. What about you? What branch are you? What sparks your days?\"\n\nOkay I'm pushing it, but social skills are something you can develop. When someone attempts to start a conversation with you, don't just drop the ball. Catch it and throw it back.",
        "author": "TomDuhamel",
        "created_utc": 1740279400,
        "score": 8,
        "parent_id": "t3_1ivoj05",
        "depth": 0
      },
      {
        "id": "me9qwh9",
        "body": "As a mediocre programmer who can yap, I am just ecstatic that many CS grads have horrible social skills.",
        "author": "WickedIndrid",
        "created_utc": 1740275284,
        "score": 5,
        "parent_id": "t3_1ivoj05",
        "depth": 0
      },
      {
        "id": "me7c2js",
        "body": "Yeah, I think it has to do with the type of personality that is comfortable spending large blocks of contiguous hours alone with a machine trying to instruct it to perfectly perform a task.  \n\nMost people can't spend 15 minutes in silence, or a few contiguous waking hours alone, without being uncomfortable...  so people who are proficient computer programmers are just built differently.\n\n...and most people don't choose computer science without some positive prior programming experience.",
        "author": "lockcmpxchg8b",
        "created_utc": 1740247972,
        "score": 5,
        "parent_id": "t3_1ivoj05",
        "depth": 0
      },
      {
        "id": "me8cdvq",
        "body": "I've said it before on here\n\nBut many people became good at computers because they used them as a way to detach from their surroundings.",
        "author": "TiredPanda69",
        "created_utc": 1740258663,
        "score": 4,
        "parent_id": "t3_1ivoj05",
        "depth": 0
      }
    ],
    "1iv1mz3": [
      {
        "id": "me2eo9n",
        "body": "I'd say start by defining what your goal is from reading a textbook. Are you reading it to become more well versed in CS theory? To get better at building architectures? To build something specific? Each of those warrants a different approach.   \n   \nIn my experience, unless you're actively using the knowledge over and over, your ability to recall the info, along with your understanding, starts to fade away over time. If you want to retain the information, using spaced repetition apps like Anki can help a lot with that. Also, do the exercises, arguably that is the most beneficial thing in the book to help you learn. \n\nWant to add that if your goal is to build stuff, then the best way to do it is to go ahead and start building stuff. You'll learn a lot more hands on knowledge that way. You'd be surprised on how far you can go with simple architectures, and having experience with that makes you so much more efficient as a programmer.   \n  \nHope this helps!",
        "author": "aeronauticator",
        "created_utc": 1740175504,
        "score": 130,
        "parent_id": "t3_1iv1mz3",
        "depth": 0
      },
      {
        "id": "me25dh8",
        "body": "i don't.",
        "author": "Abubakker_Siddique",
        "created_utc": 1740172853,
        "score": 82,
        "parent_id": "t3_1iv1mz3",
        "depth": 0
      },
      {
        "id": "me2d23g",
        "body": "Avoid anything by Uncle Bob. The man can’t even follow his own shitty rules when producing sample code for the books those shitty rules are written in.",
        "author": "rhysmorgan",
        "created_utc": 1740175033,
        "score": 52,
        "parent_id": "t3_1iv1mz3",
        "depth": 0
      },
      {
        "id": "me2fjaj",
        "body": "I tend to read it word by word, turning the page when the words run out.",
        "author": "Xeripha",
        "created_utc": 1740175757,
        "score": 39,
        "parent_id": "t3_1iv1mz3",
        "depth": 0
      },
      {
        "id": "me2cy0f",
        "body": "Kleppman's book is a hard one. It requires that you already have enough experience.\n\nUncle Bob's book isn't that hard. But there should be better about good architecture out there. I've read only his \"clean code\" book, bought it, and this is more than 6 years ago.",
        "author": "DeGamiesaiKaiSy",
        "created_utc": 1740175000,
        "score": 21,
        "parent_id": "t3_1iv1mz3",
        "depth": 0
      },
      {
        "id": "me24b69",
        "body": "I read this and it’s pretty good but very vague. I’d say this is probably less useful to junior programmers and more useful to seniors and other individuals responsible for designing the flow of applications.",
        "author": "MagicBeanstalks",
        "created_utc": 1740172551,
        "score": 8,
        "parent_id": "t3_1iv1mz3",
        "depth": 0
      },
      {
        "id": "me2uvbu",
        "body": "you bought? bro return them and get your money back. Anna's Archive has all textbooks you will ever need.\n\nAlso the way I read the text book is print out the section and sit in an empty desk with pen/pencil, highlighter, and paper. I read the section page by page. writing the vocabulary and important info based on the objective on the side of the page or on the separate paper.  ( I dont sit with my computer or phone to distracting).\n\nHere a link to the free version [https://annas-archive.org/search?q=Clean+Architecture+robert+c.+martin+series](https://annas-archive.org/search?q=Clean+Architecture+robert+c.+martin+series)\n\n[https://annas-archive.org/search?index=&page=1&q=Designing+Data-Intensive+Applications+by+Martin+Kleppmann&display=&sort=](https://annas-archive.org/search?index=&page=1&q=Designing+Data-Intensive+Applications+by+Martin+Kleppmann&display=&sort=)\n\n(HOPE I GET A REWARD FOR THIS. LOVE HELPING MY FELLOW FUTURE ENGINEERS)  :D",
        "author": "SLY0001",
        "created_utc": 1740180497,
        "score": 8,
        "parent_id": "t3_1iv1mz3",
        "depth": 0
      },
      {
        "id": "me2yj10",
        "body": "Robert Martin sucks. I went half way through two of his books because I saw them being recommended quite often. Nah... Save your time",
        "author": "sunk-capital",
        "created_utc": 1740181709,
        "score": 6,
        "parent_id": "t3_1iv1mz3",
        "depth": 0
      },
      {
        "id": "me36i5z",
        "body": "I've read this book, and while many criticise it, I rather enjoyed it. I do disagree with some points.      \n\n\nHard rules like x number of lines per function do not match my own experience at all. I've spent a lot of time in a codebase that was overly fragmented where the individual functions didn't really make any sense by themselves, and it was hell. I'm also generally against strict adherance to extreme programming or TDD. I do write tests, but only if I feel they will significantly help me, and I judge each one on a case by case basis.\n\n\n\nOn the other hand, the heavy focus on what is the core of your program, as opposed to what is an externality, like the exact database software you are using seems sound to me, and made me think about it a little differently. For me it wasn't really the content here that helped, but that it was writen down. When you are in web development for a long time, you just assume that you have a database, some api's and a few frontends. It's automatic, which is not very informed. I only understood this concept after reading a different book about graphics design, and it clearly explained why some things look bad, and that just having the ability to articulate why was incredibly useful.  \n  \n  \nI wouldn't blindly trust or distrust the author based on what the internet thinks of him. Simply read what he has to say. I read it pretty much from start to finish, briefly pausing at times to check I understood the intent of certain sections. I haven't really needed to use this particular book as a reference as it was mostly covered at university, just worded differently.  \n  \n  \nMy current project at work involves querying salesforce in typescript and rust, ultimately feeding the data to the Vue front end. I have a strict rule that Salesforce types will not be used directly in the front end. Instead, the front end depends on services that implement a relevant interface. There are pros and cons to this approach. One pro is if the shape of the salesforce data changes (it is outside of our control in this project), it can be handled in just a few adaptor methods, and gracefully if the data is wrong. On the other hand, we now have to maintain an extra layer of types and adapter methods.       \n\n\nYou could argue for either approach, but I think that books like this, combined with experience building things, helps you to make an informed choice. It's also worth remembering that whatever architecture choices you make, there is always a developer on the other side of the table who disagrees with you. If you can talk to that person, respect and understand their point of view even when it differs significantly from your own, then you are doing well.",
        "author": "foxcode",
        "created_utc": 1740184359,
        "score": 6,
        "parent_id": "t3_1iv1mz3",
        "depth": 0
      },
      {
        "id": "me2a22w",
        "body": "This book is really good, but you’ll get it way better after working on bigger projects. When you’re new or working on small stuff, some things might seem complicated or unnecessary.  Like, “why so much stuff?”  But then you work on a project where things get messy, everything depends on everything else, and changing one thing breaks other stuff.  Then you’re like, “Oh! That’s why he said that!”  The book makes more sense when you see the problems it talks about. So, read it now, but it will probably click later when you have a messy project.  Think of it like planting a seed, it grows later when you need it.",
        "author": "ActualPositive7419",
        "created_utc": 1740174176,
        "score": 3,
        "parent_id": "t3_1iv1mz3",
        "depth": 0
      },
      {
        "id": "me2l6te",
        "body": "It's a decent read, helpful for newbies trying to find a bearing.  It doesn't solve your problems but it shows some questions and newcomer to the industry might not have thought about.\n\nJust do not treat it like a gospel (some weird people do that), learn what you think you can from it and move on to other reads that take your fancy.\n\nI read clean code, clean architecture and clean coder and the last one is the one that I preferred out of the three",
        "author": "Ythio",
        "created_utc": 1740177450,
        "score": 4,
        "parent_id": "t3_1iv1mz3",
        "depth": 0
      },
      {
        "id": "me2mma8",
        "body": "No, I just learned a rough DDD but other than that there is little to no point being strict over design patterns, especially via a book. Ideally it's best to make the proper design pattern for your use case.",
        "author": "gabrielesilinic",
        "created_utc": 1740177883,
        "score": 3,
        "parent_id": "t3_1iv1mz3",
        "depth": 0
      },
      {
        "id": "me2plpt",
        "body": "No lol",
        "author": "thisnotnicholas",
        "created_utc": 1740178800,
        "score": 2,
        "parent_id": "t3_1iv1mz3",
        "depth": 0
      },
      {
        "id": "me39e30",
        "body": "I’m mostly learning by implementing; lately got into reading similar books. I’m reading designing data intensive applications as well, among a couple others. I read them cover to cover, switch between books when something gets intense, or I need to process things.\n\nWhen reading, I’m also thinking of ways I can improve existing systems I’m working on - maybe taking quick notes or reference points to go over in the morning.\n\nI’m also lightly high when reading.",
        "author": "iWishForMoreTea",
        "created_utc": 1740188171,
        "score": 2,
        "parent_id": "t3_1iv1mz3",
        "depth": 0
      },
      {
        "id": "me4rpq8",
        "body": "I'm calling this style documentation learning if there is no intermediary like person. You are getting the knowledge from a higher and a better source. In videos, we get the knowledge but in the teller's perspective. Also he/she can't transfer the knowledge in a detailed way like in the books. Videos are good for catching someone else's understanding and documentations good for deep diving.\nI have no sharp style while reading. I travel wherever I want and try to catch what I want there. And if there is no specific purpose like searching something inside I recommend shuffling the book still. If I just read like reading a story book I generally start to lose my interest.",
        "author": "nonMaterialAlchemist",
        "created_utc": 1740211924,
        "score": 2,
        "parent_id": "t3_1iv1mz3",
        "depth": 0
      },
      {
        "id": "me5u6rd",
        "body": "Throw it in the trash.   \n  \nI'm only half kidding, but 80% of the worst engineers I have ever worked with took these books to be their bible. \n\nThey no longer worried about data structures/algorithms, iterating on products, and instead only began to worry about their code quality, trying to predict and over architect projects which ruined the DX and slowed down the entire project with their undocumented brilliances that became other team members technical debt.\n\nThese patterns are great, but remember to apply them later on, or sparingly at the start. You can't predict exactly what your application will look like, and depending on your framework or language, your architecture may look differently.\n\nThe actual advice -- go look at open source repos that are popular using the tools you are using. These will be much more up to date, you can grab influence from 3-5 repos, steal things you like from each one, and make something great and recognizable. This works all the way from frontend applications to tools like PSQL or Audacity.",
        "author": "throwaway1230-43n",
        "created_utc": 1740231526,
        "score": 2,
        "parent_id": "t3_1iv1mz3",
        "depth": 0
      },
      {
        "id": "me9k9mx",
        "body": "Pull out notepad, pen, sticky notes (or use calibre or acrobat, plus a text editor)\n\nSkim the book, read section headings\n\nFollow the dopamine, if it’s interesting or seems important or valuable it gets a stick note.\n\nOnce you’ve skimmed cover to cover read the last chapter all the way through. This is usually an overview of key topics the author thinks you should take away. I write them down in my notebook as common terms of reference. These will be high level topics so I’ll use these later to make a map and build a graph of relations.\n\nThen read the introduction, first couple of sections / chapters until I get to something that reads like, and now we’ll cover xyz, if I know xyz and it doesn’t have a bookmark I skip that section.\n\nRead the next section, so on and so forth.\n\nAfter one session of reading (3hr), I compile my jot notes down into topics and reference their page numbers.\n\nIn subsequent sections, I review my notes so I know what to look for, take more jot notes, culminate notes, amend sections of notes. \n\nAfter a couple of sections I’ll align my knowledge and see if I’m on track with getting to what the last chapter highlighted. If anything is shaky, I review it. \n\nIf something I read is super important or interesting or has diagrams or is something I’ve literally done before, I write a page of notes on with my experience of it and add the terms to my ctor.\n\nRise repeat until the end, revisiting sections I skimmed or skipped if I need a refresher.\n\nThen now days if I’m really trying to check my knowledge of the book, I’ll do something like use pandoc to convert it to plaintext / markdown. Then I’ll link in my notes (retyping my jot notes helps).\n\nThen I’ll load it into my rag pipeline or upload it to NotebookLM. I’ll go through my notes. My goal here is  to rephrase what the book is saying and ask questions I’m  anticipating the answers to. This is like a pseudo tutor / learning comprehension tool. Plus if I want more context from just the book, or if I want to cross reference I can upload other material to the corpus. Then I talk through the concepts from the book and how they relate to my own thoughts, it kind of becomes like office hours with a professor, including citations generated for me.\n\nThen for architecture books I pose what if questions and prompt for what if questions back to see if I understand it. At a certain point I feel like I’ve grasped the content and had all my questions answered. I coalesce my notes and references back down to markdown, usually in my obsidian knowledge base. Then I have my own crib sheet of topics I thought were important for the material covered, complete with what ifs and case studies from my prompts.",
        "author": "DogeDrivenDesign",
        "created_utc": 1740272942,
        "score": 2,
        "parent_id": "t3_1iv1mz3",
        "depth": 0
      },
      {
        "id": "mekyyvw",
        "body": "I usually read them in bites. I try to read 10-30 pages before going to sleep.  \nThis way I can actually calm down before actually sleeping and steadily work through a book or two per month.  \nIf there's a topic that's interesting or that I want to know more about,  I usually open a tab on my phone and read a blog post or two.\n\nYou're not going to retain everything, but having heard of the concepts and where to look them up is very valuable in my opinion. The textbook knowledge alone doesn't really help THAT much, until you actually get to apply it somewhere anyway.",
        "author": "OakArtz",
        "created_utc": 1740429817,
        "score": 2,
        "parent_id": "t3_1iv1mz3",
        "depth": 0
      }
    ],
    "1ivnmml": [
      {
        "id": "me754y3",
        "body": "So it’s not random, there is some logic. I can see why you’re confused. The key is to think about the NOR gate on the left FIRST.\n\nI want you to simulate this circuit in your mind, and imagine what’s happening at the very start of this circuit. Imagine a point where there’s NO CURRENT FLOWING ANYWHERE in this circuit, then look at the NOR gate on the left. Completely ignore the one on the right for a moment.\n\nIf both inputs to the NOR gate on the left are 0, then its output becomes 1. THEN we look at the NOR gate on the right. It now has a 1 as input, so it outputs a 0. This 0 goes back into the gate on the left.\n\nIt’s confusing because it would also make complete sense to think of the output of the NOR gate on the right first. In that instance, it would have no circuit going into it initially then output a 1. Key is to “read” The circuit from left to right.",
        "author": "nineinterpretations",
        "created_utc": 1740246009,
        "score": 2,
        "parent_id": "t3_1ivnmml",
        "depth": 0
      },
      {
        "id": "me76z2j",
        "body": "Either you skipped a chapter, or the book is missing it (or is right after and you haven't read it yet), but here you go :\n\nThe key concept you have to change for this is time. Before this, you probably only had truth table for your circuit. But now, you have to add time. Assume that everythings starts at 0/off. Then, by clicking on the top button, the red part will switch from 1 to 0, and the feedback from 0 to 1. Now, we still have to propagate the second change. So the top NOR is getting 1 and 1, it's staying at 0, and the prooagation is done.\n\nThat's the way to think about circuit that have \"reverse going\" wires",
        "author": "DiraD",
        "created_utc": 1740246528,
        "score": 2,
        "parent_id": "t3_1ivnmml",
        "depth": 0
      },
      {
        "id": "mekv0dz",
        "body": "The feedback loop creates, with the two NOR gates, a memory for 1 bit. Depending on what has previously happened, the memory can be at 0 or at 1.\n\nWhen the circuit is turned on, there's a hidden circuit to make sure memory bits such as this come up in the correct state (for example, all memory bits reset to ).",
        "author": "BigPurpleBlob",
        "created_utc": 1740428712,
        "score": 2,
        "parent_id": "t3_1ivnmml",
        "depth": 0
      }
    ],
    "1iup05f": [
      {
        "id": "mdz9ini",
        "body": "The question is (probably) fine for this subreddit; however, the question is vague/broad. It might help if you were to narrow it down to something more specific.\n\nBroadly, optimization improves performance in some way. Improving response time, lower memory costs, etc.",
        "author": "Magdaki",
        "created_utc": 1740141903,
        "score": 14,
        "parent_id": "t3_1iup05f",
        "depth": 0
      }
    ],
    "1iu50p4": [
      {
        "id": "mducxic",
        "body": "It seems unlikely. That's the job of the compiler. So there's little reason for programmers to code in assembly as opposed to having them code in higher-level languages and just improving the compiler.",
        "author": "Magdaki",
        "created_utc": 1740075212,
        "score": 126,
        "parent_id": "t3_1iu50p4",
        "depth": 0
      },
      {
        "id": "mdug4ai",
        "body": "Betting on there being *less* abstraction in the future seems like a bet that will always lose",
        "author": "captain_ahabb",
        "created_utc": 1740076072,
        "score": 73,
        "parent_id": "t3_1iu50p4",
        "depth": 0
      },
      {
        "id": "mdugmhe",
        "body": "Not really, compilers can do that more efficiently than real programmers.",
        "author": "Rude-Pangolin8823",
        "created_utc": 1740076209,
        "score": 28,
        "parent_id": "t3_1iu50p4",
        "depth": 0
      },
      {
        "id": "mduoivf",
        "body": "No.\n\nInstruction sequence optimization for modern CPUs is not really amenable to hand-optimization.\n\nAlso, a really good JIT runtime can regenerate code based on observed run-time behavior (ex. branch prediction).",
        "author": "GeoffSobering",
        "created_utc": 1740078355,
        "score": 24,
        "parent_id": "t3_1iu50p4",
        "depth": 0
      },
      {
        "id": "mdur8t7",
        "body": "There's no way to \"reverse engineer\" an assembly language, because *assembly language mnemonics* map directly to the opcodes of the programmer-visible instruction set.\n  \nCoding well in assembly requires understanding what is going on inside the circuitry. As the internal complexity of CPUs grows, it becomes a lot harder to fully understand what is happening (or could happen).",
        "author": "istarian",
        "created_utc": 1740079104,
        "score": 12,
        "parent_id": "t3_1iu50p4",
        "depth": 0
      },
      {
        "id": "mduxwv7",
        "body": "Humans will never have the reliable consistency of a compiler. Going fast is pointless if you can't provide reliable results.",
        "author": "Ythio",
        "created_utc": 1740080914,
        "score": 7,
        "parent_id": "t3_1iu50p4",
        "depth": 0
      },
      {
        "id": "mdvn0cy",
        "body": "There’s a thing that a compiler can’t optimise for you, and that you don’t need assembly for.\n\nSomething thats most often disregarded, and that can impact performance over 50x.\n\nCache friendliness, or in other words keeping data used together, together. Avoiding indirection. Each cache miss in performance critical sections means your cpu is now waiting for your RAM to deliver the data. That takes insanely long compared to just having it in cache.\n\nApplications are mostly losing performance due to how they are designed, not because some fancy CPU instruction isn’t being utilised.",
        "author": "DescriptorTablesx86",
        "created_utc": 1740087901,
        "score": 8,
        "parent_id": "t3_1iu50p4",
        "depth": 0
      },
      {
        "id": "mdv1y5e",
        "body": "It depends what you mean, we do get significant performance boosts when we improve assembly. But this is a _very_ time consuming and difficult task.\n\nMore likely we’ll see more tools focussed into compilers and runtimes that end up generating better assembly in turn. Existing compilers do a good job, similarly why chromes V8 JS engine is so fast.\n\nI expect however programmer code to get more and more abstracted, but just have better performance when lowered to the machine.\n\nAnother interesting nuance of this approach is that certain software will get faster just if it’s recompiled.",
        "author": "cutebuttsowhat",
        "created_utc": 1740082024,
        "score": 7,
        "parent_id": "t3_1iu50p4",
        "depth": 0
      },
      {
        "id": "mdw60rj",
        "body": "nah.  The problem with assembly is it is not portable.  For example you run into the problem that you cannot run your program on both AMD and Intel CPU's.\n\nThe advantage of languages like C is that it relies less on the HW and leans heavily on the stack which is as portable as the concept of a stack.  Then you can optimize with assembly for any specific deviations in architectures and implement as a driver.  But you want these to be as small as possible for maintenance  and longevity.",
        "author": "OVSQ",
        "created_utc": 1740093484,
        "score": 5,
        "parent_id": "t3_1iu50p4",
        "depth": 0
      },
      {
        "id": "mdvgqcg",
        "body": "Some day you'll give plaintext descriptions of what you want an AI to make, and it will produce nearly-perfect binaries.  Not only will it be able to list any ambiguities, but it will be able to test different solutions and pick the best one.\n\nAn interesting side effect of the AI method is doing things in reverse; you'll be able to give it an exe from the nineties, and it will tell you what it does, how anything you ask about works, and even modify and port whatever you want.  Even abstract nonsense, like 'Quake IV but about catching butterflies, also features photorealistic racing elements' will give playable results.\n\nWe kinda have some of this already, but the tools I'm imagining would be like comparing the latest photoshop to MSPaint 3.11.",
        "author": "Ghosttwo",
        "created_utc": 1740086145,
        "score": 3,
        "parent_id": "t3_1iu50p4",
        "depth": 0
      },
      {
        "id": "mdvijxk",
        "body": "No.\n\nCompilers are getting smarter, because we can spend more compute at compile time.\n\nThat's why for example Rust produces faster programs than C. It's a higher level language, so you would expect it to be slower, but it is designed to give more flexibility to the compiler. As a result compiling Rust code is slower, but the produced binary is faster and better optimized.\n\nNote that AI is not yet used in compilers, but there is likely a significant gain to be had if we did. We just need hardware to run AI locally efficiently (aka. GPU). The AI wouldn't perform the optimization, it would simply choose the \"good\" combination of existing optimizations (aka. replace adhoc heuristics with AI).\n\nThis would allow for example to tell the compiler if you want to optimize a binary for bandwidth, for latency, for energy efficiency or for binary size. And train an AI with those metrics as reward.",
        "author": "surfmaths",
        "created_utc": 1740086653,
        "score": 3,
        "parent_id": "t3_1iu50p4",
        "depth": 0
      },
      {
        "id": "mdvlj0v",
        "body": "No chance.\n\nGetting performance out of assembly languages needs pretty deep knowledge that most developers don't have and are not capable of.",
        "author": "ToThePillory",
        "created_utc": 1740087487,
        "score": 3,
        "parent_id": "t3_1iu50p4",
        "depth": 0
      },
      {
        "id": "mdvlyg3",
        "body": "Your code can be fast or it can be legible. While processing architecture and Moore’s law is advancing, there isn’t much of a point except specialized fields. I think it will remain a specialized field while hardware is advancing.\n\nHowever, I use assembly and low level programming every day. I think companies like Microsoft will start doing the trade cost benefit of the cost of all the hardware they are using vs if they paid for engineers to optimize it. I doubt it will be mainstream for a while though.",
        "author": "TipsyPeanuts",
        "created_utc": 1740087606,
        "score": 2,
        "parent_id": "t3_1iu50p4",
        "depth": 0
      },
      {
        "id": "mdyal81",
        "body": "Sure, what you describe is one avenue of research. [This paper](https://arxiv.org/pdf/1804.06826) is an example that explains the process for doing so with the Volta GPU architecture.",
        "author": "ECHovirus",
        "created_utc": 1740122815,
        "score": 2,
        "parent_id": "t3_1iu50p4",
        "depth": 0
      }
    ],
    "1itqnyv": [
      {
        "id": "mdr6nhg",
        "body": "Patterson& Hennesy",
        "author": "Putrid_Soft_8692",
        "created_utc": 1740028724,
        "score": 9,
        "parent_id": "t3_1itqnyv",
        "depth": 0
      },
      {
        "id": "mds2k2t",
        "body": "P and h recommended to us  at university 30 years ago and still relevant. An excellent book though quite intense. I have my copy in my a level classroom.",
        "author": "Tough_Armadillo9528",
        "created_utc": 1740046516,
        "score": 5,
        "parent_id": "t3_1itqnyv",
        "depth": 0
      }
    ],
    "1itmxoy": [
      {
        "id": "mdqbnwq",
        "body": "Computer Systems - A Programmers Perspective",
        "author": "MasterSkillz",
        "created_utc": 1740017064,
        "score": 19,
        "parent_id": "t3_1itmxoy",
        "depth": 0
      },
      {
        "id": "mdr747t",
        "body": "_Code_ by Charles Petzold covers this really really well, going from a simple switch all the way up to cpu, storage, peripherals etc.",
        "author": "pollrobots",
        "created_utc": 1740028930,
        "score": 14,
        "parent_id": "t3_1itmxoy",
        "depth": 0
      },
      {
        "id": "mdqb7kj",
        "body": "I would think the building blocks would be universal NAND gates or universal NOR gates.  From there you need to mention touring completeness.  For example - it is kind of arbitrary to just assert the bombe was not a computer - if you say it was not a not a touring complete computer and modern computers are expected to be touring complete, then you at least have a good point.  So you could compare the bombe to the Z3 and the Eniac as an example.  Maybe the best example of a touring complete language is brainfuck - this gives the true foundations despite the rough name.\n\n[https://en.wikipedia.org/wiki/Brainfuck](https://en.wikipedia.org/wiki/Brainfuck)",
        "author": "OVSQ",
        "created_utc": 1740016910,
        "score": 5,
        "parent_id": "t3_1itmxoy",
        "depth": 0
      },
      {
        "id": "mek8x87",
        "body": "Have you seen [nand2tetris.org](https://www.nand2tetris.org/). It goes all the way from the basic logic gate nand up to a working program that plays Tetris.",
        "author": "MarcSetGo2",
        "created_utc": 1740422482,
        "score": 2,
        "parent_id": "t3_1itmxoy",
        "depth": 0
      }
    ],
    "1itbn7e": [
      {
        "id": "mdnpvsd",
        "body": "You’re right that O(1) is “kinda a myth” and requires a few assumptions to be technically correct. \n\nFirst is that it’s an amortized value, ie the average across many operations. The second is that the keys are of constant size (or at least we only read a constant portion of them) so the hash value itself can be computed in constant time. \n\nIn practice though this tends to be true or close enough to true for most applications.",
        "author": "beeskness420",
        "created_utc": 1739989893,
        "score": 26,
        "parent_id": "t3_1itbn7e",
        "depth": 0
      },
      {
        "id": "mdnjm8o",
        "body": "Well, hash tables is an array that has so called buckets. Each bucket translates to each array slot. \n\nBefore insertion of key, say `e`, the hash table computes the hash of `e`. It's some integer value that hash table uses to insert `e` into a proper bucket. \n\nFor element retrieving, you're doing the same thing - given a key `e` you compute its hash and you look up the given bucket as you computed before.\n\nAlthough, it may happen that you can have more than one element in the bucket (you need to fill `sqrt(n)` buckets to have at least 50% chance to get this situation). Then comparison is actually linear in the length of the chain in the bucket. But on average the complexity of looking up and inserting into a hash table is `O(1)`.",
        "author": "repaj",
        "created_utc": 1739988217,
        "score": 10,
        "parent_id": "t3_1itbn7e",
        "depth": 0
      },
      {
        "id": "mdnl4y1",
        "body": "Very very simplified explanation of a hashmap: A hashmap directly calculates the result or its address from the input. So let’s assume your hashing function is modulo(remainder after division) 5. When inserting element a at map[134560] we have a remainder of zero storing it at the address 0. For element c at map[203748261] we have a remainder of one so we store it at address 1. There are mechanisms to handle colisions but for the explanation assume they just don’t happen. When accessing map[203748261] we just need to apply the hash algorithm (%5 again) and we retrieve a from the address 0. While modulo 5 is a terrible hashing function, there are pretty efficient and reliable ones. You can even calculate optimal hashing functions for limited entries using gperf.",
        "author": "Old_Sky5170",
        "created_utc": 1739988626,
        "score": 2,
        "parent_id": "t3_1itbn7e",
        "depth": 0
      }
    ],
    "1isv352": [
      {
        "id": "mdkit61",
        "body": "What methodology are you using to measure this? I'd like to make sure that you're measuring what you expect to measure.",
        "author": "computerarchitect",
        "created_utc": 1739944166,
        "score": 37,
        "parent_id": "t3_1isv352",
        "depth": 0
      },
      {
        "id": "mdlazj8",
        "body": "I always preferred _[QueryPerformanceCounter](https://stackoverflow.com/questions/1739259/how-to-use-queryperformancecounter)_ before and after, since it saves any branching.  The test size looks big enough to do a single run instead of having to loop it 10,000 times between timer polling's or something (then dividing by 10,000).  Although in this case, I'd try multiple array sizes to suss out any cache issues.  The output would be a list of lengths and times that you could paste into excel to get a graph, with sizes being power of two stuff representing the size of the sorted structure (eg 16kb, 128kb, 4mb, etc).  Also a good way to find places where the [data alignment](https://en.wikipedia.org/wiki/Data_structure_alignment) is off.  If the resulting chart is well-behaved, you can do a regression and get a clean Big-O factor.",
        "author": "Ghosttwo",
        "created_utc": 1739960189,
        "score": 10,
        "parent_id": "t3_1isv352",
        "depth": 0
      },
      {
        "id": "mdkmnxd",
        "body": "This is great progress. Was it random input using the same seed? I'd love to see averages over different input distributions (uniform, ascending, normal, zipf, almost-sorted) and different sizes. Maybe JesseSort is particularly good at some of these setups.",
        "author": "rtheunissen",
        "created_utc": 1739946075,
        "score": 7,
        "parent_id": "t3_1isv352",
        "depth": 0
      },
      {
        "id": "mdqfwaa",
        "body": "What is the point if the std sort it twice as fast? Do you think you can beat it with better asymptotics at larger datasets?",
        "author": "ArtisticFox8",
        "created_utc": 1740018514,
        "score": 6,
        "parent_id": "t3_1isv352",
        "depth": 0
      },
      {
        "id": "mdmp7dw",
        "body": "Are all of these tests sorting integers? I’d like to see how it compares when, e.g. sorting structures with several fields.\n\nKeep in mind that if you’re sorting integers or strings, a comparison sort is not your competition, a bucket sort / radix sort is.\n\nOne idea would be to sort a smaller number of elements (like 5000) but make your comparison function do a lot of extra computation. The idea is to see which algorithm does the fewest comparisons.",
        "author": "dmazzoni",
        "created_utc": 1739979965,
        "score": 3,
        "parent_id": "t3_1isv352",
        "depth": 0
      },
      {
        "id": "mdn45rp",
        "body": "Which arrays are you measuring on? Where is the benchmarking code?\n\nAlso: To me this seems to essentially just prove that the benchmarking in your prior post was likely unfairly skewed towards Jesse Sort, specifically as you compared sorting an array of `int`s (which you took advantage of) vs. comparator-based sorting. A fairer comparison would perhaps be e.g. against numpy's sorting.\n\nBut really you get the best comparisons if you test C(++) or similarly low level versions as you're doing here.",
        "author": "appgurueu",
        "created_utc": 1739984073,
        "score": 3,
        "parent_id": "t3_1isv352",
        "depth": 0
      },
      {
        "id": "mdrchas",
        "body": "Does anyone know of a good video explaining the rainbow concept?",
        "author": "ReignAstro",
        "created_utc": 1740031456,
        "score": 2,
        "parent_id": "t3_1isv352",
        "depth": 0
      }
    ],
    "1iscvpp": [
      {
        "id": "mdffcrh",
        "body": "Deleting a file can come in many forms. The hard drive is physically encoded \"switches\" of \"on/off\". To truly delete something you have to overwrite those switches with new states. With enough technology systems, even that isn't enough and the switches recent states can still leave an \"echo\" let's call it. That's why security standard to really trulely delete something requires writing over and wiping and writing over and wiping those switches 7 times if you want to be hardcore about it.",
        "author": "Jareth000",
        "created_utc": 1739886552,
        "score": 26,
        "parent_id": "t3_1iscvpp",
        "depth": 0
      },
      {
        "id": "mdflj69",
        "body": "Some companies delete their hard drives by throwing them into a press and converting them to sand.\n\nThere are multiple points between just deleting the file pointer, and throwing the disk to Mount Doom. And it's all about how hard you want to make recovering that data",
        "author": "ivancea",
        "created_utc": 1739888707,
        "score": 12,
        "parent_id": "t3_1iscvpp",
        "depth": 0
      },
      {
        "id": "mdfew3j",
        "body": "What",
        "author": "Much-Tea-3049",
        "created_utc": 1739886388,
        "score": 6,
        "parent_id": "t3_1iscvpp",
        "depth": 0
      },
      {
        "id": "mdfhhow",
        "body": "There are many different types of file systems. Some behave the way you describe, some do things differently. You would have to include the particular filesystem you're talking about if you want to discuss they way developers chose to implement certain features",
        "author": "SirTwitchALot",
        "created_utc": 1739887306,
        "score": 4,
        "parent_id": "t3_1iscvpp",
        "depth": 0
      },
      {
        "id": "mdgdb6x",
        "body": "A file system can use things like the Fat Allocation Table (FAT). It's like a directory pointing to each file and tracks what space is used. When you delete a file, the directory entry is deleted. The next time space is needed, it will see that the space isn't allocated and thus create a new directory entry pointing to the space. The file then overwrites what was left behind of the old file.\n\nDeleting a directory entry is much faster than going into the allocated space and doing something to the space like resetting all the ones to zeroes. Imagine you have a huge movie file: it's faster to delete the directory entry than it is to go through gigabytes of space.\n\nIt's like you are the manager for an apartment complex. When the tenants in unit 50 move out, you mark 50 as vacant. Now you can either just point your new tenants to unit 50 and have them clean up and fix the unit when they move in, or you can go in and clean out unit 50 before giving it to the new tenants. In reality, we do the second option since new tenants would not like to clean up after the old tenants. In Computer Science, file systems do the first option since new files don't care about the state of the space (it just overwrites whatever is there).",
        "author": "SoCaliTrojan",
        "created_utc": 1739897125,
        "score": 3,
        "parent_id": "t3_1iscvpp",
        "depth": 0
      },
      {
        "id": "mdgq4yv",
        "body": "yes, the hard drive / storage device has special regions to store that kind of info.\n\nJust last week I recovered a 1.8TB partition I deleted while re-installing Windows 11",
        "author": "zaphod4th",
        "created_utc": 1739900718,
        "score": 2,
        "parent_id": "t3_1iscvpp",
        "depth": 0
      }
    ],
    "1irmz7k": [
      {
        "id": "md9k600",
        "body": "If he wants someone to do code reviews of certain code snippets, then [codereview.stackexchange.com](http://codereview.stackexchange.com) is a good forum. There's also r/gamedev, [gamedev.stackexchange.com](http://gamedev.stackexchange.com) and [stackoverflow.com](http://stackoverflow.com) which are good communities for developers.",
        "author": "kiner_shah",
        "created_utc": 1739808070,
        "score": 59,
        "parent_id": "t3_1irmz7k",
        "depth": 0
      },
      {
        "id": "md9l127",
        "body": "You might want to see if there's a club/team for the Informatics Olympiad (e.g. [BIO](https://www.olympiad.org.uk/) in the UK, [USACO](https://usaco.org/) in the US).  The people competing in those groups/the mentors for those teams would likely be good resources.",
        "author": "apnorton",
        "created_utc": 1739808330,
        "score": 31,
        "parent_id": "t3_1irmz7k",
        "depth": 0
      },
      {
        "id": "md9mghr",
        "body": "I’m a software engineer and tutor a people (kids and adults) online, so will be happy to help if you’re interested. DM me!",
        "author": "ProfessionalOrnery86",
        "created_utc": 1739808758,
        "score": 36,
        "parent_id": "t3_1irmz7k",
        "depth": 0
      },
      {
        "id": "mdcbf3i",
        "body": "Ensure he's mature enough to handle feedback.",
        "author": "crabby-owlbear",
        "created_utc": 1739836560,
        "score": 10,
        "parent_id": "t3_1irmz7k",
        "depth": 0
      },
      {
        "id": "md9l1g0",
        "body": "You will likely have to act as a go between. There may be paying resources and courses online, but most free resources don't cater to children, and getting tutoring as an adult is already complicated enough.\n\n\nBest thing I can suggest is that your son put his code up on some online repo, e.g. GitHub, and then you go around asking for constructive criticism from forums like this.",
        "author": "aprg",
        "created_utc": 1739808333,
        "score": 9,
        "parent_id": "t3_1irmz7k",
        "depth": 0
      },
      {
        "id": "mdao59p",
        "body": "One thing about code is that you don’t always need someone to check your work. Especially when you’re a) starting out, b) not needing to collaborate with others, and c) working on fun projects where money and safety aren’t at stake, if your code works and it’s fast enough for you, it’s fine. There’s plenty of time to add constraints to how you code in the future; learning to just build something that works in whatever way you imagine and without worrying about whether it’s the “right” way is a great way to build confidence and creativity.\n\nThat said, collaboration is an important skill to develop, and working with others is just a lot of fun. I’d suggest looking for a programming related club at school. Robotics clubs are popular in the US — maybe ask about that at school.",
        "author": "iOSCaleb",
        "created_utc": 1739819317,
        "score": 5,
        "parent_id": "t3_1irmz7k",
        "depth": 0
      },
      {
        "id": "mdc2c43",
        "body": "He should open source the project or somehow get users. Thats the best way to find out how functional it is.",
        "author": "United_Lifeguard_41",
        "created_utc": 1739833594,
        "score": 4,
        "parent_id": "t3_1irmz7k",
        "depth": 0
      },
      {
        "id": "mdcp14h",
        "body": "have him put his code on github, im curious about his game engine",
        "author": "swimfan72wasTaken",
        "created_utc": 1739841048,
        "score": 2,
        "parent_id": "t3_1irmz7k",
        "depth": 0
      }
    ],
    "1iqvj4n": [
      {
        "id": "md6nqev",
        "body": "\n\nAll of the theory is interesting to me before seeing empirical results. After formal proofs and optimization, I would spend my time implementing a reference version in C and run it against qsort on a matrix of different input sizes and data distributions. I was excited to see this update post.",
        "author": "Immediate-Country650",
        "created_utc": 1739760220,
        "score": 49,
        "parent_id": "t3_1iqvj4n",
        "depth": 0
      },
      {
        "id": "md5kegl",
        "body": "Ignore the other guy, I’m interested in this!",
        "author": "fangus",
        "created_utc": 1739746753,
        "score": 29,
        "parent_id": "t3_1iqvj4n",
        "depth": 0
      },
      {
        "id": "md7crti",
        "body": "Stoked you’re sharing the development as it happens!\n\nIt’s all been super interesting to read about: the theory, the related sorting algorithms, your own code, etc…\n\nI’m looking forward to more updates!\n\nThanks again! :D",
        "author": "Ok-Interaction-8891",
        "created_utc": 1739770411,
        "score": 7,
        "parent_id": "t3_1iqvj4n",
        "depth": 0
      },
      {
        "id": "md64ayl",
        "body": "Nice, this is really cool! I would remove any possessive pronouns for professionalism and plural pronouns because you're the only author on the paper in your repo (!!!)\n\nThe psuedocode could also be much more clear, such as with indexing instead of saying \"middle\". Comparing it with your Python code, it's small things like \"Insert at middle\" and \"Insert before middle\" being used synonymously",
        "author": "WhiteButStillAMonkey",
        "created_utc": 1739753392,
        "score": 4,
        "parent_id": "t3_1iqvj4n",
        "depth": 0
      },
      {
        "id": "md6gf2k",
        "body": "Cool update!",
        "author": "andrewsb8",
        "created_utc": 1739757631,
        "score": 2,
        "parent_id": "t3_1iqvj4n",
        "depth": 0
      }
    ],
    "1iqrg1u": [
      {
        "id": "md2cnv6",
        "body": "How are you doing crosswires?",
        "author": "Rude-Pangolin8823",
        "created_utc": 1739710319,
        "score": 11,
        "parent_id": "t3_1iqrg1u",
        "depth": 0
      },
      {
        "id": "md2hk64",
        "body": "Sorry, which ones are the outputs and inputs? It seems like some of the dominoes are already knocked over so was it already “run”?",
        "author": "a_cloud_moving_by",
        "created_utc": 1739712501,
        "score": 5,
        "parent_id": "t3_1iqrg1u",
        "depth": 0
      },
      {
        "id": "md6wsut",
        "body": "this deserves a gif or video demo!",
        "author": "nooobLOLxD",
        "created_utc": 1739763593,
        "score": 2,
        "parent_id": "t3_1iqrg1u",
        "depth": 0
      }
    ],
    "1iqlbex": [
      {
        "id": "md1d88g",
        "body": "Direct proofs are when you use your hypotheses in combination with logical axioms and deduction rules (and potentially other theorems that follow from the previously mentioned info) to conclude the result. Most statements (including non-simple statements) can be proven directly. \n\nDirect proof example: Prove a square is a rectangle\n1. If a shape has 4 sides and 4 right angles, it is a rectangle (definition of a rectangle)\n2.  A square has 4 sides and 4 right angles (definition of a square)\n3. A square is a rectangle (modus ponens, or the rule that knowing that A implies B and knowing that A is true proves that B is true )\n\nProof by Contrapositive is a proof that leverages the logical axiom (A => B) => (~B => ~A) (in words, this says “(A implies B) implies (not B) implies (not A)). In simple terms, to use this method, assume that the thing you are trying to prove is *not* true, then prove that your hypothesis is also *not* true.  \n\nAlso as a tip, when doing a proof by contrapositive, be careful that you negate the thing you’re trying to prove and not the hypothesis! This means that if you want to prove A implies B (meaning assuming A is true, show that B is true), you do so by assuming B is not true and proving that A is not true, and you did it wrong if you instead assume that A is not true and prove B is not true. \n\nProof by contrapositive example: Prove that if I went to the store, then I have a car\n1. To show the contrapositive, we must show that if I do not have a car, then I did not go to the store, so we may assume that I do not have a car and we want to show that I did not go to the store\n2. If I don’t have a car, then I cannot make it to the store as it is too far away from my home. Therefore, if I don’t have a car, I cannot have gone to the store, thus completing the proof. \n\nProof by Contradiction is a proof that leverages the (non-constructive) logical axiom (~(~A))=>A (or in words, “(not (not A)) implies A”. This means that if you show that the negation of a statement leads to a contradiction (therefore proving that the negation is false), then you have proven that the statement must be true. \n\nA famous example of a proof by contradiction is the proof that sqrt(2) is irrational. This proof begins by assuming the negation of the statement (i.e. that sqrt(2) is rational and can be written as p/q where p and q are relatively prime) and deriving a contradiction from this fact (showing that p and q must have a common prime factor of 2). I will not include the details of the proof here but I highly encourage you to look this up!\n\nA proof by induction is when you show that a statement p(n) is true for all natural numbers n by proving p(1) (aka showing the statement is true for n=1) and then showing p(n) => p(n+1) (i.e. assume the statement is true for n, and use that to prove its true for n+1). \n\nAn easy example of a proof by induction is the proof that the sum of the first n natural numbers is n(n+1)/2. As the base case, we know that 1 = 1(1+1)/2. Now, is the sum of the first n numbers is n(n+1)/2, then the sum of the first n+1 numbers is the sum of the first n numbers + n+1, so it is n(n+1)/2 + n+1 = (n/2 + 1)(n+1) = ((n+2)/2)(n+1) = (n+1)((n+1)+1)/2. \n\nExhaustion and existence are not really proof techniques and are actually just the definitions of the “for all” and “exists” operators from predicate logic. If a statement includes the words “for all” or “exists” (or synonyms for these terms), the statement is asking you to show that something is true either for every possible input or that there is some particular input that satisfies the statement’s condition.  As these aren’t really proof techniques, I will not include proofs for these. \n\nProof by Counterexample is a way of showing that a “for all” statement is not true. This works because the negation of a statement of the form “for all x, A is true” is the statement “there exists an x where A is not true”. \n\nAs an example, if you were asked whether or not the statement “every natural number is even” is true, you can conclude that it isn’t using the counterexample that 1 is not even.",
        "author": "JSerf02",
        "created_utc": 1739689470,
        "score": 17,
        "parent_id": "t3_1iqlbex",
        "depth": 0
      },
      {
        "id": "mdgmvzn",
        "body": "I can recommend the textbook I used: Rosen, Discrete Math which is useful for these topics",
        "author": "bobbsec",
        "created_utc": 1739899808,
        "score": 3,
        "parent_id": "t3_1iqlbex",
        "depth": 0
      }
    ],
    "1ipzggn": [
      {
        "id": "mcw09zk",
        "body": "You should see the spread for physics majors.",
        "author": "Zombie_Bait_56",
        "created_utc": 1739620604,
        "score": 315,
        "parent_id": "t3_1ipzggn",
        "depth": 0
      },
      {
        "id": "mcw19cv",
        "body": "What would you put under a curriculum dedicated to Computer Science? I would expect it to touch on the theory in each of the major subfields at least. \n\nStudying math *does* include wide ranging fields: Calculus, Linear Algebra, Abstract Algebra, Analysis, Stats, Number Theory, etc all fall under an undergraduate math curriculum as well.\n\nSomething to be cautious of as well is to not conflate Computer Science with Computer Engineering or Software Engineering.",
        "author": "BKrenz",
        "created_utc": 1739621155,
        "score": 129,
        "parent_id": "t3_1ipzggn",
        "depth": 0
      },
      {
        "id": "mcw35go",
        "body": "A bachelors degree in many areas of study tends to be really just a primer. Each of those applied courses serves as more concrete examples of how theoretical concepts actually apply. Learning about the CAP theorem is one thing, working with distributed systems and application domains where it’s important is a whole other level of understanding. \n\nI have a physics BS (with a CS minor), I had to take many lab courses where I replicated many fundamental-to-physics experiments like measuring the gravitational constant, electrostatic phenomena, observing quantum effects, estimating the radius of the earth, and for my final capstone project I had to engineer a way of measuring the differential conductance of a sample. Did I come away from those courses as an expert experimentalist in any of those subfields? Not at all. But it deepened my appreciation for the theoretical principles that they relied on. \n\nMy computer science MS and PhD were very different from my CS undergraduate courses. There was some general deeper level coursework but most of my efforts were invested in a single subfield of study and any application work served as just a proving ground to show that I actually understood the concepts I was studying. If I hadn’t done any of the rudimentary surface level CS undergraduate work to give me any of the skills necessary to be able to actually do anything, it would have been much harder than it already was to succeed in my graduate degrees.",
        "author": "terref",
        "created_utc": 1739622161,
        "score": 53,
        "parent_id": "t3_1ipzggn",
        "depth": 0
      },
      {
        "id": "mcw27a1",
        "body": "Computer Science is the youngest of the main scientific disciplines; indeed in most universities the splitting off of the Computer Science department from the Mathematics department is probably still in living memory. So that's one factor.\n\n\nThe other factor is that specialisation often comes in at the postgraduate level in many disciplines; you can still get a Bachelors in Mathematics, for example, but nobody would expect a BSc. to show expertise in any particular mathematical branch.",
        "author": "aprg",
        "created_utc": 1739621663,
        "score": 31,
        "parent_id": "t3_1ipzggn",
        "depth": 0
      },
      {
        "id": "mcw81il",
        "body": "I have had to use each of those fields in work.  \n\n\nSometimes you don't know what's going to be useful in 20 years and you just gotta teach of bit of each.",
        "author": "stewsters",
        "created_utc": 1739624530,
        "score": 10,
        "parent_id": "t3_1ipzggn",
        "depth": 0
      },
      {
        "id": "mcwuykp",
        "body": "\"Edit it would be similar to studying math would include every applief subject\"\n\nI think you have no clue about math then.\n\nYou think Analysis, Linear Algebra, Optimization  Statistic, Geometry, Graphtheory are all the same applied area?\n\n\nThe idea of a bachelors is to give you a broad fundation, and then give you the choice to specify during work or a masters in your topic on interest.\n\n\nWhy skip foundations? Since you need them for most things.\n\nIm more into signal processing, but i need database knowledge everywhere. Same for optimization/statistic",
        "author": "Icy-Trust-8563",
        "created_utc": 1739633065,
        "score": 9,
        "parent_id": "t3_1ipzggn",
        "depth": 0
      },
      {
        "id": "mcxwriw",
        "body": "Believe it or not, the fields are more related than you think.\n\nTake networks for example. A network is just a data bus extending over long distances. We were forced by the electrical requirements of such distances to figure out how to make such a bus reliable. The resulting packetization approach lead to a rework of busses inside of computers, with both PCIe and USB being packetized.\n\nSimilarly, there’s a massive overlap between databases and file systems. Technically a file system is just a type of database that allows variable length records. And modern file systems also include a hierarchical index into the data.\n\nBoth also have to concern themselves with the problem of memory allocation. Allocators of RAM and allocators of disk space are very similar in practice. Especially given the modern TLB look aside approaches which try to present each program with a memory structure that pretends it’s the only program running. Combined with unified paging systems and CPU caching layers, memory and storage really are just different levels of the same thing.\n\nGraphics, AI, SIMD, and other number crunching are really just computational problems. Most of the advancement is in trying to throw more computer power at Vector processing. Vector processing generically being computational flows without branching.\n\nYou’d be surprised how much the number crunching side overlaps with databases. Take a look at Oracle’s Star Transform query planner. They use fast vector processing on bitmaps to achieve logical Boolean operations using bitwise math for extremely high performance on filtering.\n\nOperating Systems touch on all of this because they’re jammed in the middle of trying to solve a resource sharing problem. i.e. There is a higher demand for computing resources than there are computing resources. It’s the job of the OS to provide mechanisms to fairly schedule programs and share resources between them.\n\nCertainly you will see specialization in certain areas within the commercial market. But at the end of the day, it’s all the same CompSci. CompSci ultimately concerns itself with mathematics, data processing, bussing of data, and storage of data.",
        "author": "thewiirocks",
        "created_utc": 1739644666,
        "score": 4,
        "parent_id": "t3_1ipzggn",
        "depth": 0
      },
      {
        "id": "mcx0hex",
        "body": "Every branch of knowledge has its subdiscplines that become more distinct from each other as they evolve.\n\nJust look at mathematics, for example. Topology is vastly different from Statistics other than the fact they both use numbers and variables.",
        "author": "NAHTHEHNRFS850",
        "created_utc": 1739634816,
        "score": 5,
        "parent_id": "t3_1ipzggn",
        "depth": 0
      },
      {
        "id": "md1o883",
        "body": "Bad news pal.  CS is a math subspecialty.  The programming and other stuff is just some nice vocational technology stuff they put in so industry is happy. \n\n\nThose sorting algorithm and data structures are the CS stuff, the rest is just application of the basics. ",
        "author": "SRART25",
        "created_utc": 1739696021,
        "score": 4,
        "parent_id": "t3_1ipzggn",
        "depth": 0
      },
      {
        "id": "mcwcllz",
        "body": "Computer science as a field is young but it is already branching. Look at all the different degrees. Computer Science, Computer Engineering, Software Engineering, Cyber Security, Data Science, Data Engineering, AI… and more.",
        "author": "MissinqLink",
        "created_utc": 1739626479,
        "score": 4,
        "parent_id": "t3_1ipzggn",
        "depth": 0
      },
      {
        "id": "mcxn1bv",
        "body": "Congratulations, you know more about a field than other field. Every single other field is like that, from education to biology. Now keep that in the back of your mind when you argue on the internet about stuff you don't know shit about, which is literally every field outside of computer science and math.\n\nThat includes political science, medecine and economics.",
        "author": "TheReservedList",
        "created_utc": 1739641745,
        "score": 3,
        "parent_id": "t3_1ipzggn",
        "depth": 0
      },
      {
        "id": "mcy167p",
        "body": "Steven Wolfram commented that CS probably will evolve into something where it’s mainly a tool/subfield used as a means to an end in other fields, which makes sense imo",
        "author": "tyngst",
        "created_utc": 1739645993,
        "score": 3,
        "parent_id": "t3_1ipzggn",
        "depth": 0
      },
      {
        "id": "mcyeunn",
        "body": "I honestly enjoy that it’s like this. You get to get a taste of all these possible career fields and once you graduate you can really get into whatever you like. Whereas if you got a Cybersecurity degree, you’re probably only getting cybersecurity job",
        "author": "Prismology",
        "created_utc": 1739650178,
        "score": 3,
        "parent_id": "t3_1ipzggn",
        "depth": 0
      },
      {
        "id": "md2z0yx",
        "body": "You have to understand a lot of history and that Computer Science is primarily a field of academic study and research.  \n  \nAll of those \"applied fields\" started out as theory and research within the field of CS, with academic researchers often producing the first proof of concept software.  \n \nTopics/Subjects like computer networks, databases, and graphics are all examples. Over time they grew to be specialized enough to demand it be a separate field of study.",
        "author": "istarian",
        "created_utc": 1739718967,
        "score": 3,
        "parent_id": "t3_1ipzggn",
        "depth": 0
      },
      {
        "id": "mcw2aq4",
        "body": "._. They have little in common with each other but when used together you can create many applications. Just with knowledge of the fields you mentioned you could develop and launch a simple multiplayer game. \n\nThat being said, I wouldn’t recommend someone trying to be a master in all of the fields. Instead I’d say focus on one or two fields and master them at both an applied level and theoretical level. You can still do great things with only mastery of two fields like operating systems and computer graphics would be a great pairing in trying to develop GUI applications. \n\nAt my University, the bachelor is a bit more focused and the only two fields mentioned that are required courses include; software engineering and operating systems. The rest of the electives are dependent on your focus. My focus is cyber security and more specifically cryptography and network security. The fields you’ve mentioned I know only at a surface level besides of operating systems and theoretical fields since they’re used heavily in cryptography. \n\nTo end I’ll say that computer science really isn’t one exclusive subject. It’s a multi disciplinary study which has overlap in other disciplines which is the reason why I believe it’s a great subject.",
        "author": "Humble_Wash5649",
        "created_utc": 1739621714,
        "score": 2,
        "parent_id": "t3_1ipzggn",
        "depth": 0
      },
      {
        "id": "mcwzb7y",
        "body": "You could say that about many engineering fields. For mechanical engineers, they have to study finite element analysis but also gear theory. But there’s applications that involve them together, so you are getting all these tools you need. Engineering fields are about practical applications and this might involve gluing several things together.\n\nScientific fields, say psychology, will focus on only psychology.",
        "author": "featheredsnake",
        "created_utc": 1739634449,
        "score": 2,
        "parent_id": "t3_1ipzggn",
        "depth": 0
      },
      {
        "id": "mcyeacx",
        "body": "This is the case for a lot of majors. Chemistry, history, psychology, IT, mathematics... all have subfields that could be complete programs on their own.\n\nIn the case of CS, web development, artificial intelligence, and perhaps operating systems are areas that could be their own areas of study IMO, especially AI. The material covered is so beyond the low level programming in most CS curriculums that it really can't be appreciated at all when it's shoved in as a fourth year elective.",
        "author": "ObjectBrilliant7592",
        "created_utc": 1739650007,
        "score": 2,
        "parent_id": "t3_1ipzggn",
        "depth": 0
      },
      {
        "id": "md0i1tx",
        "body": "What do you mean \"without really understanding\"\n\nThere are levels of depth \n\nIf you study one or two software engineering styles and some design patterns then you get a good level of understanding of the concepts without doing a software engineering degree \n\n\nIf you want to study just one of those subjects for three years then you could! \n\nComputers are broad. You should have realised that beforehand!\n\nIt'd get broader if it was IT or \"information systems\"\n\nThe fundamentalness of it keeps you from having to go even more all over the place. \n\nSome people do Computer Science and Maths. \n\nAnd there can always be modules you got into and others that you skimmed the surface of and never really got into.",
        "author": "bishtap",
        "created_utc": 1739675292,
        "score": 2,
        "parent_id": "t3_1ipzggn",
        "depth": 0
      },
      {
        "id": "md5oxcy",
        "body": "It trains your mind to think better. Not all of it will be applied, but helps you abstract the problems into calculable algorithms; which how the Universe really work; so your solutions will tend to be Efficient",
        "author": "fgiohariohgorg",
        "created_utc": 1739748270,
        "score": 2,
        "parent_id": "t3_1ipzggn",
        "depth": 0
      }
    ],
    "1iq9kh5": [
      {
        "id": "mcydoqq",
        "body": "So, what's they key difference between the Von Neumann and Harvard architectures? IIRC, Harvard has separate memories for instructions and data while Von Neumann uses a unified memory? It seems simple.\n\nBut there are a few ways we can think about varying this. First, while most modern CPUs are theoretically Von Neumann machines, in their implementation they have separate instruction and data caches. So, a while a modern CPU may technically be a Von Neumann machine, it runs faster if it's programmed as a Harvard machine.\n\nA second consideration, what differentiates instructions/code from data? Say your program is a Java bytecode interpreter\\*. The implementation of your interpreter might be machine code ran by the CPU. But the \"data\" for the interpreter, the Java bytecode, would be data to the from the CPU machine code.\n\nSo, when interpreting Java bytecode you have three classes of information - (1) Machine code for interpreting the byte code (2) the bytecode for the application program and (3) the data for the application program. Now we have several variations -\n\n* 1,2, & 3 unified - Von Neumann\n* 1 in instruction memory and 2 & 3 in data memory - ARM/x86/etc Harvard machine interpreting Java Bytecode\n* 2 & 3 in instruction cache and 3 in data cache -\n   * an ARM + Java bytecode CPU, Sun Microsystems experimented with some of these in the early 2000s, IIRC. They hard special hardware to run Java bytecode in CPU hardware instead of interpreting it.\n* A few other permutations that don't really make sense.\n\n  \n\\* I know 95% of the time Java byte code is JIT compiled to native code in 2025. But, let's assume we're using a bytecode interpreter late 90s style.",
        "author": "Beautiful-Parsley-24",
        "created_utc": 1739649821,
        "score": 11,
        "parent_id": "t3_1iq9kh5",
        "depth": 0
      },
      {
        "id": "mczqu7a",
        "body": "One critical point that might not be obvious is that modern CPUs are different from the original Harvard architecture. \n\nIn the original Harvard design there were 2 physically separate banks of memory. One for data and one for programs.\n\nToday’s CPUs use what’s called a “modified Harvard architecture.” Which is to say, the memory banks are shared between code and data. No bifurcation happens until we get to the L1 cache. Anything scheduled for execution is pulled by the code cache lines. Anything data used for processing is pulled by the data cache lines.\n\nWhat’s interesting is that the two caches might contain some of the same memory pages. So the memory is not truly separate.\n\nThe advantages of the modified architecture go beyond improved data rates and actually solve a practical cache eviction problem. If the L1 was shared between code and data, there is a very real chance that active code blocks would get evicted during processing, causing excessive wait states.\n\nKeeping the caches separate means that cache eviction of code is only affected by other code and eviction of data is only affected by other data.",
        "author": "thewiirocks",
        "created_utc": 1739665610,
        "score": 6,
        "parent_id": "t3_1iq9kh5",
        "depth": 0
      },
      {
        "id": "md0phax",
        "body": "There was the Texas Instruments TMS9900 family that had is registers stored in memory with just a register pointer within the CPU. Its purpose was to allow extra fast context switching .",
        "author": "smeyn",
        "created_utc": 1739678150,
        "score": 2,
        "parent_id": "t3_1iq9kh5",
        "depth": 0
      },
      {
        "id": "md0vp5x",
        "body": "I dont think they can be considered a simple variation from one or other. If I would point one, i'd probably talk about contemporary computers, its the same arch but the implementation is probably different.",
        "author": "Eumatio",
        "created_utc": 1739680715,
        "score": 2,
        "parent_id": "t3_1iq9kh5",
        "depth": 0
      },
      {
        "id": "md7jzd0",
        "body": "If a CPU enables you to lock a memory region and prevent execution of the data in it (as if it were code), then it cannot be a pure Von Neumann architecture, afaik.",
        "author": "istarian",
        "created_utc": 1739774069,
        "score": 2,
        "parent_id": "t3_1iq9kh5",
        "depth": 0
      }
    ],
    "1iq6768": [
      {
        "id": "mcxidj6",
        "body": "Sorry for the technical glitches! I’m online and ready to answer your questions. 😎👍",
        "author": "thewiirocks",
        "created_utc": 1739640346,
        "score": 3,
        "parent_id": "t3_1iq6768",
        "depth": 0
      },
      {
        "id": "mcyglqr",
        "body": "is there any use case where you would use orm instead of convirgance?",
        "author": "czeslaw_t",
        "created_utc": 1739650715,
        "score": 3,
        "parent_id": "t3_1iq6768",
        "depth": 0
      },
      {
        "id": "mcz13bt",
        "body": "It is very similar conceptually that I created like 15 years ago, exactly having the same problem with ORM. Your solution is obviously more modern and developed. Well done.",
        "author": "redikarus99",
        "created_utc": 1739657074,
        "score": 3,
        "parent_id": "t3_1iq6768",
        "depth": 0
      },
      {
        "id": "mcy4anz",
        "body": "I use orm, I have the impression that the problem is the lack of knowledge of what is the layer below. Do I understand correctly, in this solution there is no need for a model/dto in Java? Is it only for queries or also for saving data?",
        "author": "czeslaw_t",
        "created_utc": 1739646943,
        "score": 2,
        "parent_id": "t3_1iq6768",
        "depth": 0
      },
      {
        "id": "mczlsde",
        "body": "Just wanted to say a big Thank You to everyone who participated and a huge Thank You to the mods for all their help with the technical challenges. \n\nI’ll keep an eye out for any additional questions or comments. You can also reach out using any of the methods listed in the Convirgance documentation. I’m happy to answer any questions you might have. 😎👍",
        "author": "thewiirocks",
        "created_utc": 1739663898,
        "score": 2,
        "parent_id": "t3_1iq6768",
        "depth": 0
      }
    ],
    "1ion02s": [
      {
        "id": "mckp1cw",
        "body": "Cool. Nicely done!\n\nTo what are you attributing the increase in speed? Is there a novel aspect to the algorithm? Or is there a limitation that allows it work in some cases faster?",
        "author": "Magdaki",
        "created_utc": 1739464944,
        "score": 162,
        "parent_id": "t3_1ion02s",
        "depth": 0
      },
      {
        "id": "mcl0p25",
        "body": "Very impressive if true! If you want the published paper to be taken seriously, you definitely need a proof of correctness.",
        "author": "FriedGil",
        "created_utc": 1739468217,
        "score": 88,
        "parent_id": "t3_1ion02s",
        "depth": 0
      },
      {
        "id": "mcl8ehq",
        "body": "Nice to see original work being posted and polite, constructive feedback in the comments. Really shows what Reddit can be like when people are being good people. :)\n\nThanks for sharing, OP! I hope you’re able to keep working on it to the point that it gets published. Please keep us updated!",
        "author": "Ok-Interaction-8891",
        "created_utc": 1739470392,
        "score": 88,
        "parent_id": "t3_1ion02s",
        "depth": 0
      },
      {
        "id": "mcl8ri7",
        "body": "You would need to prove correctness of your algorithm and provide formal or universally accepted evidence of superior performance. If you are not a researcher and you don’t know how to do this, you might want to talk to someone that has more experience, only if you are serious and confident about your algorithm. \n\nSebastian (from the Powersort team) is a really nice guy, might want to drop him an email. Worst case, he does not reply 😁",
        "author": "Fresh_Meeting4571",
        "created_utc": 1739470496,
        "score": 46,
        "parent_id": "t3_1ion02s",
        "depth": 0
      },
      {
        "id": "mcl0s9s",
        "body": "The plot is suggestive, the log scale plot shows that it's only faster for more than 300,000 unsorted values. The lin space plot shows only the upper end of the log space plot.\n\nStill nicely done!",
        "author": "Kohlrabi82",
        "created_utc": 1739468242,
        "score": 27,
        "parent_id": "t3_1ion02s",
        "depth": 0
      },
      {
        "id": "mcl2z17",
        "body": "Neat; I didn't see it mentioned in your paper but is it stable?",
        "author": "campbellm",
        "created_utc": 1739468855,
        "score": 13,
        "parent_id": "t3_1ion02s",
        "depth": 0
      },
      {
        "id": "mcllnet",
        "body": "I did not see this mentioned in the paper:\n\nCould you share any cache profiling data? I'm particularly interested in how the algorithm performs with different CPU cache sizes and access patterns. Also, did you measure cache misses specifically?",
        "author": "jftuga",
        "created_utc": 1739474148,
        "score": 11,
        "parent_id": "t3_1ion02s",
        "depth": 0
      },
      {
        "id": "mcl4g4m",
        "body": "I would love to see this against standard qsort in C across many distributions and sizes.",
        "author": "rtheunissen",
        "created_utc": 1739469264,
        "score": 6,
        "parent_id": "t3_1ion02s",
        "depth": 0
      },
      {
        "id": "mcly5te",
        "body": "This was a very interesting read. Others have commented about technical improvements, but I just want to mention that on the bottom of page 10 of your paper, 2 \"new\"s is redundant.\n\n> Thus, we consider these variations rather than new completely new algorithms.",
        "author": "lkatz21",
        "created_utc": 1739477590,
        "score": 5,
        "parent_id": "t3_1ion02s",
        "depth": 0
      },
      {
        "id": "mcmo1ps",
        "body": "There's somewhat recently been some work on sorting algorithms \"for the real world\" that made it into rusts's stdlib (not just for pure sorting but also related tasks like [`select_nth_unstable`](https://doc.rust-lang.org/beta/std/primitive.slice.html#method.select_nth_unstable)) - might be interesting to compare against. There's some writeups here https://github.com/Voultapher/sort-research-rs/tree/main/writeup if you're interested.\n\nI've only skimmed your paper but I couldn't really find a discussion of the memory characteristics. There is at least one allocation for the base array, yes? But that's it?",
        "author": "SV-97",
        "created_utc": 1739484901,
        "score": 6,
        "parent_id": "t3_1ion02s",
        "depth": 0
      },
      {
        "id": "mco3prd",
        "body": "I was taking this seriously and then I saw “middle out” on page five and now I think you’re trolling and you’ve just replaced the word compression with sorting.",
        "author": "ArtOfWarfare",
        "created_utc": 1739502087,
        "score": 5,
        "parent_id": "t3_1ion02s",
        "depth": 0
      },
      {
        "id": "mcko468",
        "body": "Worth noting, I keep the index of the last inserted value to process (50% of) natural runs in roughly O(n) time.",
        "author": "booker388",
        "created_utc": 1739464685,
        "score": 4,
        "parent_id": "t3_1ion02s",
        "depth": 0
      },
      {
        "id": "mcn2g63",
        "body": "You should definitely compare it against different implementations of sorting algorithms. Python isn't exactly the language that prioritizes performance",
        "author": "ChadiusTheMighty",
        "created_utc": 1739489347,
        "score": 5,
        "parent_id": "t3_1ion02s",
        "depth": 0
      },
      {
        "id": "mcpjp16",
        "body": "It's great to see such enthusiasm in algorithmic research! You’ve clearly put a lot of thought into JesseSort and the Rainbow structure, and I think you could be onto something here.\n\nThat said, I’d encourage you to work with a mentor or an experienced researcher to refine the theory and methodology. As others have pointed out, the complexity claims would benefit from more formal proofs, and the empirical results need a stronger comparative baseline (e.g., different compilers, cache effects, and input distributions). You also likely need a more precise definition of the Rainbow data structure.\n\nImportantly, I’d be cautious about widely sharing a manuscript that still needs significant refinement. A sorting algorithm with fundamentally novel properties would require strong empirical and theoretical proof to be taken seriously after decades of work in the field. If major flaws are identified after the fact, it could make it harder for people to take your future work seriously, even if you later refine the ideas.\n\nThis depends a lot on your ambitions and goals, but I'd hate to see an interesting idea dismissed due to inexperience. So, taking the time to strengthen the theory and validate the results will only make your work more impactful. Good luck!",
        "author": "karius85",
        "created_utc": 1739528350,
        "score": 4,
        "parent_id": "t3_1ion02s",
        "depth": 0
      },
      {
        "id": "mcm1q5d",
        "body": "Wow, what a creative algorithm. Great job!",
        "author": "Legitimate-Wolf-6638",
        "created_utc": 1739478581,
        "score": 3,
        "parent_id": "t3_1ion02s",
        "depth": 0
      },
      {
        "id": "mcmkqnm",
        "body": "You should definitely send this to YT channel Computerphile, ask them to cover it. They have been covering sorting algorithms in the past. It could give you some exposure.",
        "author": "scarynut",
        "created_utc": 1739483935,
        "score": 4,
        "parent_id": "t3_1ion02s",
        "depth": 0
      },
      {
        "id": "mcnsvc1",
        "body": "Note when you’re discussing worst case complexity, there’s no need to put the log base as part of the big O analysis, as it doesn’t actually matter when analyzing big O. You can just say O(n*log(n))",
        "author": "Duh1000",
        "created_utc": 1739498224,
        "score": 3,
        "parent_id": "t3_1ion02s",
        "depth": 0
      },
      {
        "id": "mctbblv",
        "body": "Interesting idea, but I think the worst-case complexity is Omega(n\\^2). Consider the input \\[1, n, 2, n-1, ...\\]. Every element gets inserted into the middle of the base array.",
        "author": "UnstalkedCrinoid",
        "created_utc": 1739574280,
        "score": 3,
        "parent_id": "t3_1ion02s",
        "depth": 0
      },
      {
        "id": "mcmo7sy",
        "body": "Isn’t writing quicker sorting algos the kinda thing you win a prize for?",
        "author": "savva1995",
        "created_utc": 1739484951,
        "score": 2,
        "parent_id": "t3_1ion02s",
        "depth": 0
      },
      {
        "id": "mcqsxf9",
        "body": "I dont know much about python, can you actually write in raw python an algorithm lf this kind faster than the default? I would expect sort to be implemented as a C subroutine much faster than raw python? What am I missing here.",
        "author": "seriousthinking_4B",
        "created_utc": 1739547277,
        "score": 2,
        "parent_id": "t3_1ion02s",
        "depth": 0
      }
    ],
    "1ip1w63": [
      {
        "id": "mcoeouy",
        "body": "> How does one get into this field?\n\nGraduate school. PhD programs are entirely about training you to be a scientist who conducts research.\n\nBut as an undergraduate, there are two good options for getting your feet wet and seeing what research is like! First, talk to professors at your school. They all have websites describing their research interests, and if one sounds cool, start a conversation and see if they'll take you as a research assistant in their lab group. Second, look for Research Experience for Undergraduates, or REU programs. These are basically summer internships as a scientist at (typically) universities working in a lab group.",
        "author": "nuclear_splines",
        "created_utc": 1739506157,
        "score": 11,
        "parent_id": "t3_1ip1w63",
        "depth": 0
      },
      {
        "id": "mcqmhml",
        "body": "Others have provided you with answers, but I will add that getting a research position as an UG is difficult. The number of positions is low for two reasons: 1. there is very little funding for UG research, 2. UG researchers require a lot of supervision. It is helpful as it gives PhD students some supervisory experience, which is probably the biggest reason PIs bring UGs into the lab.\n\nSo temper your expectations. Research groups are rarely looking for more people, they're looking for specific skill sets to do detailed work. And these are skill sets that UG don't often have. That's what graduate school is for. \n\nTips:\n\n1. Do well. A higher GPA helps a lot.\n\n2. Get to know your professors.\n\n3. Get to know your professors research.\n\n4. Get to know the graduate students. If a graduate students \\*wants\\* to work for you and goes to bat for you with their professor, then this is the #1 way to get in.",
        "author": "Magdaki",
        "created_utc": 1739545267,
        "score": 5,
        "parent_id": "t3_1ip1w63",
        "depth": 0
      },
      {
        "id": "mcodpl8",
        "body": "This post will get taken down, you're looking for r/cscareerquestions, no career or school advice allowed on this sub. Im aware of the karma requirements for that sub, if you don't meet them browse Reddit, enjoy it, and then post when you have enough karma. To answer your question, there's a lot of different research related fields in CS, data science, algorithms, quantum computing, supercomputers, computer vision, self driving cars, robotics, machine learning and deep learning, generative design, theoretical computation (designing operating systems and programming languages, and compilers), engineering/simulation, materials Science, pharmaceutical computing, to get into these fields id suggest doing well in your courses and going to graduate school, this will give you the information, and opportunities to explore research fields while writing a thesis",
        "author": "burncushlikewood",
        "created_utc": 1739505770,
        "score": 2,
        "parent_id": "t3_1ip1w63",
        "depth": 0
      },
      {
        "id": "mcol9jp",
        "body": "> but I'm unable to find further on this topic in a language i understand\n\nTake more math courses at uni, so that then you can understand the research papers.",
        "author": "MathmoKiwi",
        "created_utc": 1739508920,
        "score": 2,
        "parent_id": "t3_1ip1w63",
        "depth": 0
      },
      {
        "id": "mcpgsym",
        "body": "If you are familiar with fundamentals of boolean algebra, data structures, algorithmic complexity and operating systems (as any serious cs student should understand these \"applied\" cs areas to make their life easier), you should be able to understand textbooks on theory of computation. \nThen take a look at cryptography, there is fascinating math there. Learning about randomized algorithms was also super fascinating. \nI think the key is to take a look at the contents of textbooks in the topic you like and then go to the papers cited from there.",
        "author": "agentzz9",
        "created_utc": 1739526507,
        "score": 2,
        "parent_id": "t3_1ip1w63",
        "depth": 0
      },
      {
        "id": "mcvc6tk",
        "body": "You can use Google scholar to look up the papers that your professors have published. You should be able to access the papers through your University library. Just read the abstracts and maybe the conclusions. This will give you an idea of the fields your professors are working in. (Sometimes this can be very different than the intro classes they teach)",
        "author": "horsegrrl",
        "created_utc": 1739605399,
        "score": 2,
        "parent_id": "t3_1ip1w63",
        "depth": 0
      },
      {
        "id": "mcvtetz",
        "body": "I just got into a masters program that is focused on research and academia, and as part of our \"training\" we constantly need to read papers and either make an essay or make a presentation about it. Here is a selection of the ones I have read last trimester, explained in the best layman terms I could come up:\n\n+ an implementation of the merge sort algorithm but with parallel computing, where one half of the array is sent to other process to be sorted concurrently with the other half\n+ Using gen AI to detect deadlocks in concurrent programs\n+ Doing an experiment on how well Netflix handles bad connections by watching some content while manually screwing around the connection and monitoring it.\n+ Using federated AI to make better DDoS attack detection systems\n+ A protocol where smart-cart-to-smart-car can tell to better manuver on bridges and tunnels, in the sense that cars can calculate if no more cars can get inside and keeping the distance while driving.\n+ A simulation and mathematical analysis to check how faster and how energy efficient is a microcontroller for IoT things is depending on how long the instruction pipeline is.\n\nLastly, here is a very famous article about how to read a paper: https://web.stanford.edu/class/cs114/reading-keshav.pdf",
        "author": "MasterGeekMX",
        "created_utc": 1739616433,
        "score": 2,
        "parent_id": "t3_1ip1w63",
        "depth": 0
      },
      {
        "id": "mdeon8g",
        "body": "I mean, like others have said, if you want \"research research,\" you’ve got to get into a Masters or PhD program.\n\nIn my lab, we actually hire undergraduate research assistants. It's merit-based, we are focused on robotics and computer vision, so our experiments and data collection can be very extensive (think thousands of robot demos, etc.). So this is the main area where UGs can help us.\n\nThe knowledge at the undergraduate level is sort f not enough to carry out or make a meaningful contribution to research that has been ongoing for a few years. Not saying this to discourage you, but just some food for thoughts and to help set expectations.\n\nSo, check out your university and see if they have any undergraduate research positions available",
        "author": "TopNotchNerds",
        "created_utc": 1739873996,
        "score": 2,
        "parent_id": "t3_1ip1w63",
        "depth": 0
      }
    ],
    "1io6mqp": [
      {
        "id": "mcgwq07",
        "body": "The trick is to work on a really fucking complicated product.  There at least you need to apply software engineering and architecture principles to make sure it doesn’t all fall apart.  True computer science is pretty rare in industry but definitely exists.",
        "author": "teddyone",
        "created_utc": 1739407885,
        "score": 643,
        "parent_id": "t3_1io6mqp",
        "depth": 0
      },
      {
        "id": "mcgx9w5",
        "body": "You’re not alone.\n\nIt’s sad how our curiosities are simply forcibly shaped into this utilitarian thing where we become money-printer-automators for companies.\n\nI have 11 yrs of tech experience and just recently realized that I was hating my career despite being financially successful.\n\nI decided to stop side projects to make money and to stop going overtime with work-related stuff to pursue things for the fun of it instead.\n\nFor example I just bought a FPGA board and am playing with it. This has absolutely nothing to do with how I make money in tech (and I have no interest in shifting my carreer to it as well), but I’m feeling happy again.\n\nDon’t let the curiosities of your younger self be killed by this soul-sucking system.",
        "author": "CapablePayment5550",
        "created_utc": 1739408064,
        "score": 173,
        "parent_id": "t3_1io6mqp",
        "depth": 0
      },
      {
        "id": "mch0yz6",
        "body": "come to game engineering where everythings hard, the deadlines are shorter and you get paid 30% less, also you get laid off every 2 years.",
        "author": "redditsuxandsodoyou",
        "created_utc": 1739409253,
        "score": 142,
        "parent_id": "t3_1io6mqp",
        "depth": 0
      },
      {
        "id": "mcgw7ca",
        "body": "I hear you. I'm working on a password manager with server syncing capabilities and it's so much more fun than what I do for work. I have to actually learn a ton of cryptography concepts and the other day I found myself needing to implement a queue using a singly linked list. Literally a homework problem from a data structures and algorithms class that I just organically ran into.",
        "author": "Queueue_",
        "created_utc": 1739407719,
        "score": 125,
        "parent_id": "t3_1io6mqp",
        "depth": 0
      },
      {
        "id": "mcgwvx4",
        "body": "The best time of my life was doing my PhD and my music degree. I'd never leave school if I could afford it.",
        "author": "Magdaki",
        "created_utc": 1739407938,
        "score": 91,
        "parent_id": "t3_1io6mqp",
        "depth": 0
      },
      {
        "id": "mcgygu7",
        "body": "Imagine how philosophy majors feel.",
        "author": "Kaelin",
        "created_utc": 1739408447,
        "score": 57,
        "parent_id": "t3_1io6mqp",
        "depth": 0
      },
      {
        "id": "mch25jz",
        "body": "A little off-topic, but I have this habit of thoroughly studying a topic, leaving no stone unturned. With the rise of GenAI, every time I do this, my friends ask, “Why bother? ChatGPT can give you the answer in seconds.”\n\nI get their point—AI tools are incredibly efficient. But I strongly believe that deep understanding isn’t going out of style anytime soon. Knowing why something works, not just what works, is still invaluable and fulfilling.",
        "author": "New_Computer3619",
        "created_utc": 1739409634,
        "score": 58,
        "parent_id": "t3_1io6mqp",
        "depth": 0
      },
      {
        "id": "mch6mzz",
        "body": "Have you considered going to R&D?",
        "author": "mordoboy54",
        "created_utc": 1739411082,
        "score": 20,
        "parent_id": "t3_1io6mqp",
        "depth": 0
      },
      {
        "id": "mchdd8m",
        "body": "I work in the kernel and firmware and I don’t find this to be very true. have you considered specializing in something that takes more skill like embedded systems or, god forbid I say it but, AI?",
        "author": "SecretaryFlaky4690",
        "created_utc": 1739413321,
        "score": 17,
        "parent_id": "t3_1io6mqp",
        "depth": 0
      },
      {
        "id": "mch1l91",
        "body": "In the movie Legend, The Darkness, essentially The Devil, said, “The dreams of youth are the regrets of maturity.”",
        "author": "JohnVonachen",
        "created_utc": 1739409454,
        "score": 17,
        "parent_id": "t3_1io6mqp",
        "depth": 0
      },
      {
        "id": "mch7h7s",
        "body": "Go into research?",
        "author": "myloyalsavant",
        "created_utc": 1739411356,
        "score": 14,
        "parent_id": "t3_1io6mqp",
        "depth": 0
      },
      {
        "id": "mchbb0e",
        "body": "Maybe you're in the wrong field, get into engineering or manufacturing, also robotics and research.  A lot of software jobs are in the fields of networking, or data management, front end or backend internet related jobs. My dream is to develop computer aided manufacturing software, do CNC machining with g code",
        "author": "burncushlikewood",
        "created_utc": 1739412633,
        "score": 15,
        "parent_id": "t3_1io6mqp",
        "depth": 0
      },
      {
        "id": "mchmq4s",
        "body": "Leetcode, DSA, Codeforces are some good short-term options for problems that require you to think.\n\nIf you want something longterm, pick up compilers like GCC, LLVM, DBMS like sqlite, postgresql, or kernel and start contributing to them.",
        "author": "SnooBeans1976",
        "created_utc": 1739416518,
        "score": 12,
        "parent_id": "t3_1io6mqp",
        "depth": 0
      },
      {
        "id": "mci8yne",
        "body": "Come work on graphics programming. Dynamic collision detection is incredibly hard: triangle-AABB sweep, triangle-capsule sweep, triangle-sphere sweep.",
        "author": "winterpeach355",
        "created_utc": 1739425502,
        "score": 12,
        "parent_id": "t3_1io6mqp",
        "depth": 0
      },
      {
        "id": "mch2d2h",
        "body": "From physics I went to math and from math to IT.\n\nI miss the challenge, been eying some interesting dev positions in my company, but I'm tired of changes, I want to stick to a career. I'm not 20 anymore, well beyond 30. Tired of being the new/junior guy all the time.\n\nThe options I have are to do the grind work to pay the bills and rent, challenge myself in my free time, and focus on family time.\n\nI've taken up chess for the first part, joined a club and been attending local competitions now and then; I'll probably have to sell my precious 2nd handed  math and TCS books, can't stand looking at them gathering dust. It's sad, but it is what it is.",
        "author": "DeGamiesaiKaiSy",
        "created_utc": 1739409700,
        "score": 11,
        "parent_id": "t3_1io6mqp",
        "depth": 0
      },
      {
        "id": "mch3hcg",
        "body": "IT in general has this issue for most roles. The most interesting part of the field is learning new technologies and concepts, then once you learn them and their limits, actual jobs barely present you problems that go beyond basic issues. \n\nNetworking especially has this issue. The concepts of networking is pretty much the same across the board, the only thing you ever might actually have to learn is when new technologies add new capabilities, which isn’t often. Once you understand subnetting, security, structure of networks, etc. you’re pretty much set, and unless you’re building a network on a massive scale, most that knowledge isn’t going to be really tested.",
        "author": "KiddBwe",
        "created_utc": 1739410054,
        "score": 10,
        "parent_id": "t3_1io6mqp",
        "depth": 0
      },
      {
        "id": "mcipgjo",
        "body": "try graphics programming, gpu shaders, simulations stuff, 3d. it's a lot of fun and challenging to make it run fast",
        "author": "etdeagle",
        "created_utc": 1739434783,
        "score": 9,
        "parent_id": "t3_1io6mqp",
        "depth": 0
      },
      {
        "id": "mchj649",
        "body": "Come to the aerospace, defense, or embedded world. Have to use real computer science practices in these fields.",
        "author": "AmanThebeast",
        "created_utc": 1739415294,
        "score": 6,
        "parent_id": "t3_1io6mqp",
        "depth": 0
      },
      {
        "id": "mcidmij",
        "body": "That's why I didn't choose web development. It looks boring to me.\nI working with firmware in R&D and I love it. I learning how things works and really using this knowledge",
        "author": "FoMiN12",
        "created_utc": 1739427879,
        "score": 7,
        "parent_id": "t3_1io6mqp",
        "depth": 0
      },
      {
        "id": "mchhfng",
        "body": "This is why I went back to do a PhD. Best decision",
        "author": "drcopus",
        "created_utc": 1739414698,
        "score": 5,
        "parent_id": "t3_1io6mqp",
        "depth": 0
      }
    ],
    "1ip3mw0": [
      {
        "id": "mcor8y7",
        "body": "You misunderstand what a bug is\n\nIt’s not a binary sequence that has erroneously flipped. Bugs instead arise when we write a program that emits a series of 1s and 0s that behaves differently than we intend. And while in theory you’re right that we could edit individual bits to correct our error, that is not very feasible because at such a low level it’s not clear what our intention was\n\nInstead we opt to edit programs written in a high level language that reflects our intentions, and we hope that our refactored programs are closer to correct than before",
        "author": "winniethezoo",
        "created_utc": 1739511677,
        "score": 115,
        "parent_id": "t3_1ip3mw0",
        "depth": 0
      },
      {
        "id": "mcorjuw",
        "body": ">If software is just 1s and 0s, why can't we just manually edit a program's binary to fix bugs?\n\nWe can; this is called a [binary patch](https://stackoverflow.com/questions/1945075/how-do-i-create-binary-patches).\n\n>Wouldn't that be easier than waiting for patches?\n\nNope.  \n\nAs an analogy, you know how all of our memories are stored --- physically --- in our brain?  In a concrete sense, if someone has a hard time remembering their multiplication tables, it's because some physical neurons in their brains aren't in the \"right\" state.  It'd be theoretically possible, then, to mess with those physical neurons to implant memories in people.\n\nSo, why don't we just physically change people's brains instead of sending them to school?  We don't know what neuron(s) correspond to what memories, and messing with them could break stuff.  Same thing for code; it's very difficult to figure out what 1s and 0s correspond to what part of the code, and messing with the wrong ones can break stuff.",
        "author": "apnorton",
        "created_utc": 1739511823,
        "score": 41,
        "parent_id": "t3_1ip3mw0",
        "depth": 0
      },
      {
        "id": "mcoqw4l",
        "body": "In theory you could, but that would be so ridiculously difficult ",
        "author": "Any-Illustrator-9808",
        "created_utc": 1739511508,
        "score": 24,
        "parent_id": "t3_1ip3mw0",
        "depth": 0
      },
      {
        "id": "mcoswjz",
        "body": ">find the part that's broken\n\nAnd how would you figure that out when looking at a series of (to a human) random 0s and 1s?",
        "author": "Triple96",
        "created_utc": 1739512491,
        "score": 16,
        "parent_id": "t3_1ip3mw0",
        "depth": 0
      },
      {
        "id": "mcosp1x",
        "body": "That's doable yes. It's called \"reverse engineering\" or \"cracking\".\n\nYou don't really edit binary code though, as that would be painful beyond measure.  \nInstead you woulld probably want to use a **disassembler** to convert that binary code to assembly code, which is much easier to read for humans.\n\nStill, editing a program in assembly is very complex.  \nEspecially because nowadays programs have protections and are very heavy.  \nThough if you are motivated, this beginner guide should get you started : [https://repository.root-me.org/Reverse%20Engineering/EN%20-%20Reverse%20Engineering%20for%20Beginners%20-%20Dennis%20Yurichev.pdf](https://repository.root-me.org/Reverse%20Engineering/EN%20-%20Reverse%20Engineering%20for%20Beginners%20-%20Dennis%20Yurichev.pdf)",
        "author": "Kmarad__",
        "created_utc": 1739512388,
        "score": 9,
        "parent_id": "t3_1ip3mw0",
        "depth": 0
      },
      {
        "id": "mcorgoe",
        "body": "You can do this. Many cracks actually work in this fashion. The issue is how do you know what bits(1&0's) to flip? Someone has to read and understand what is happening through possibly billions of 1's&0's to find the right spot. Literally you have millions of lines of instructions that are not human readable. \n\nThe patch is where the original writer of the code goes through the original source, i.e. human readable c++ to find the error and then recompile and send out a patch.",
        "author": "Top-Order-2878",
        "created_utc": 1739511780,
        "score": 5,
        "parent_id": "t3_1ip3mw0",
        "depth": 0
      },
      {
        "id": "mcotgok",
        "body": "The issue is that while you can patch the binary (that is how they often do cracks).\n\nIt's kinda difficult to edit large amounts of logic from the binary. And also waiting for a patch is often much better.\n\nBut there are cases where that is done. Oftentimes though it involves decompilation of the full thing first because again, it's difficult to purely imagine to edit large amounts of logic directly from the binary beside a simple jump.\n\nLook no further than the Mario64 decompilation project or even the lego Island decompilation project.",
        "author": "gabrielesilinic",
        "created_utc": 1739512774,
        "score": 5,
        "parent_id": "t3_1ip3mw0",
        "depth": 0
      },
      {
        "id": "mcotyev",
        "body": "That’s like trying to fix a plot hole by opening random pages in a book you’ve never read, written in a language you don’t speak.",
        "author": "fixminer",
        "created_utc": 1739513025,
        "score": 3,
        "parent_id": "t3_1ip3mw0",
        "depth": 0
      },
      {
        "id": "mcorjxi",
        "body": "A program might be a few hundred megabytes between all the used libraries and SDKs it uses. 100MB is 100 * 1024 * 1024 bytes or 100 * 1024 * 1024 * 8 bits (1s and 0s)\n\nGood luck finding the right bits out of those ~800,000,000",
        "author": "DaRadioman",
        "created_utc": 1739511824,
        "score": 3,
        "parent_id": "t3_1ip3mw0",
        "depth": 0
      },
      {
        "id": "mcosavs",
        "body": "How would you know what the 1s and 0s mean?",
        "author": "FantasticEmu",
        "created_utc": 1739512194,
        "score": 3,
        "parent_id": "t3_1ip3mw0",
        "depth": 0
      },
      {
        "id": "mcosss7",
        "body": "You can! And I have! I had a program that was compiled by a ppc tool chain for the correct version of the hardware that was crashing with a sigill because the compiler had a bug that caused it to generate the incorrect instruction. I read the documentation for the architecture realized the issue and found a suitable correction for the few places in the binary by looking up the correct assembly instruction and the binary/hex encoded and with a hex editor manually edited the program. And it totally worked! I was admittedly surprised it worked but if you’re careful and don’t make huge changes it totally will.\n\nFYI in case you don’t know hexadecimal is how people tend to choose to look at binary since 1 byte is encoded in 2 hex characters.",
        "author": "SecretaryFlaky4690",
        "created_utc": 1739512440,
        "score": 3,
        "parent_id": "t3_1ip3mw0",
        "depth": 0
      },
      {
        "id": "mcot5dv",
        "body": "That’s like trying to fix a car’s engine by staring at it with a microscope and then manipulating the molecules until the car works as intended. \n\nThere are some things we fix at the molecular level. Most things we fix with a wrench and knowing which bolt to turn. Sometimes we make entirely new tools to do the job.",
        "author": "fntdrmx",
        "created_utc": 1739512616,
        "score": 3,
        "parent_id": "t3_1ip3mw0",
        "depth": 0
      },
      {
        "id": "mcotlta",
        "body": "Yes.\n\nBut knowing exactly which ones to flip in the vast amount of bits that make program, is not that easy. Finding a needle in a haystack is much easier, as a program is a massive rube goldberg machine of instructions that follow each other, sometimes in cycles or complex interactions.\n\nIt's like saying that why don't trans people change gender by simply switching their XY genes to the other combination.\n\nI mean, it is an absurdly complex idea, that this comic strip makes fun of it by being the ultimate hard way of editing programs for bragging rights: https://xkcd.com/378/",
        "author": "MasterGeekMX",
        "created_utc": 1739512847,
        "score": 2,
        "parent_id": "t3_1ip3mw0",
        "depth": 0
      },
      {
        "id": "mcoub2o",
        "body": "If you can read and write binary code, go ahead and do it! I haven't met anyone who can though.",
        "author": "MagicalPizza21",
        "created_utc": 1739513202,
        "score": 2,
        "parent_id": "t3_1ip3mw0",
        "depth": 0
      },
      {
        "id": "mcovw1z",
        "body": "It is possible to do binary patching, but that's a lot more complex than you think it is.  \n  \nOne issue that may not be obvious is that the hardware architecture may require that data be aligned to multiples of the *word* size.\n  \nhttps://en.wikipedia.org/wiki/Data_structure_alignment  \n  \nAnother problem is that you can't just insert a bunch of new code in the middle of a program without screwing up the memory addresses for jumps/branches.",
        "author": "istarian",
        "created_utc": 1739514016,
        "score": 2,
        "parent_id": "t3_1ip3mw0",
        "depth": 0
      },
      {
        "id": "mcowm1s",
        "body": "Instead, why are there bugs in the first place? You can just write 0s and 1s and the program should just work. /s",
        "author": "Longjumping_Quail_40",
        "created_utc": 1739514394,
        "score": 2,
        "parent_id": "t3_1ip3mw0",
        "depth": 0
      },
      {
        "id": "mcozsfj",
        "body": "That’s like saying, “everything is just made of atoms and molecules. Why do we need to wait on a skilled person to repair things if we could just reach inside and change the atoms?”\n\nThe 1’s and 0’s, much like atoms/molecules, don’t mean a whole lot on their own when they’re arranged into something as complex as, say, a car",
        "author": "InstAndControl",
        "created_utc": 1739516121,
        "score": 2,
        "parent_id": "t3_1ip3mw0",
        "depth": 0
      },
      {
        "id": "md85jcf",
        "body": "I love this question, no idea why it has no upvotes",
        "author": "StubbiestPeak75",
        "created_utc": 1739786911,
        "score": 2,
        "parent_id": "t3_1ip3mw0",
        "depth": 0
      },
      {
        "id": "mdhevda",
        "body": "Almost all software these days is written in a \"high level\" programming language:\n\n    import std;\n    int main() { std::println(\"Hello, World!\"); }\n\nThis is placed in a text document - called source code, and is fed as input to a program called a \"compiler\". This program will interpret the text as a program and convert it into program instructions - the raw 1s and 0s. We call that a binary executable.\n\nWhen you run a program, the operating system has a program called the \"program loader\" whose job it is to open your binary executable and prepare it to run on the CPU. That binary executable isn't just machine instructions, it contains other data, too - things the program loader needs to know to set it up.\n\nUltimately, the binary is read from disk, put into system memory, and fed over the data bus (literally a bunch of physical wires over the circuit board) to the instruction cache (a little bit of memory) on the CPU, which the CPU will then interpret the bytes of binary as a sequence of instructions - the bytes have to be decoded inside the CPU and the correct electrical circuits have to be selected to execute the instruction.\n\nOther data, like the text in my message, will make a similar journey to the data cache, where it's loaded into data registers (the physical inputs and outputs of the CPU core, the instruction side also has instruction registers), and thus program and data are married.\n\nMy program above expresses a simple idea of writing a bit of text to some simple output - ostensibly we'd see it pop up on a virtualized text terminal (cool history about those things...), but in reality it's at the point of translation that we really need to consider how a computer is an electrical machine, and the program has to be reduced to step, by step, by step instructions at an electrical level.\n\nIf it helps, the first computer was designed by Charles Babbage, and it was both digital AND purely mechanical. It was all gears and shafts and a rotating assembly. It was digital because there were these interlocking decimal counting mechanisms for storing information. Charles Babbage's computer was never built, but it has been simulated, and proven to be as computationally complete as a modern electronic computer, just incredibly slow. Ada Lovelace, his contemporary, invented the concept of the computer program, and even wrote the first correct program for Charles Babbage's proposed machine - if memory serves...\n\nThis translation from text to program is not reversible, and the computing industry is almost entirely reliant upon it. A programming language is strict and unambiguous, rooted in mathematics. The compiler can analyze the program and make correct deductions so it can transform the program expressed in a more optimal form when translated to binary.\n\nIn short, it's extremely difficult to go from source code to binary and understand what the compiler deduced, why, and therefore what it generated. The binary form is alien to most engineers who have very little reason to know and examine the program at that level in that detail. Programs can EASILY be millions of lines of source code long.\n\nAnd it is the source code that is the authority of what the program is and how it functions. The thing to do, then, is trace the bug through the source code, fix it there, and run it through the translator again. We have software tools to aid us in doing this.",
        "author": "mredding",
        "created_utc": 1739907530,
        "score": 2,
        "parent_id": "t3_1ip3mw0",
        "depth": 0
      }
    ],
    "1iojekx": [
      {
        "id": "mcjrth9",
        "body": "Practice, practice, practice.",
        "author": "33498fff",
        "created_utc": 1739454735,
        "score": 95,
        "parent_id": "t3_1iojekx",
        "depth": 0
      },
      {
        "id": "mcjs1up",
        "body": "You need more practice solving these problems. There's no real substitute for the effort used in training your mind this way",
        "author": "apnorton",
        "created_utc": 1739454817,
        "score": 38,
        "parent_id": "t3_1iojekx",
        "depth": 0
      },
      {
        "id": "mck2io6",
        "body": "Discrete Meth",
        "author": "ZubriQ",
        "created_utc": 1739458348,
        "score": 11,
        "parent_id": "t3_1iojekx",
        "depth": 0
      },
      {
        "id": "mcjwpit",
        "body": "Make sure you are solid on your fundamentals . Try the problem, write a solution. Then compare with a good solution. Do you understand why every step is important? Try to rewrite your own version of it. Also, when proving a theorem, analyze why the conditions stated are necessary. What happens if you change them? Why does the theorem not hold anymore?",
        "author": "ahbonilapasdeprenom",
        "created_utc": 1739456431,
        "score": 11,
        "parent_id": "t3_1iojekx",
        "depth": 0
      },
      {
        "id": "mcl49n2",
        "body": "By doing engineering. That's about it. Contrive a project out of your reach, and just start. Finish it or don't. The point is, if you do this often enough, you'll notice patterns in the way you write code that naturally stonewall you later. This is the core engineering problem in software. Writing software that works today is easy. Writing software that continues working after 2 decades of commits reverts and merges, that's why we get the big bucks. \n\n\nMust Read:\n- Working effectively with legacy code - Feathers\n- Test driven development - Beck\n- Domain driven design - Evans\n- The DevOps Handbook \n\n- The Elements of Design.\n\n\nRemember. All code has two end users. The user, and the sociopath who will read your code next.",
        "author": "IUpvoteGME",
        "created_utc": 1739469214,
        "score": 8,
        "parent_id": "t3_1iojekx",
        "depth": 0
      },
      {
        "id": "mcjwych",
        "body": "Deliberate practice. You can search about it on Youtube “deliberate practice ted ed”. \nIn short, you actively evaluate yourself, find any topics you understand poorly, take time to study the topic thoroughly, constantly ask yourself questions about the topic and investigate. \n\nGradually, you will build a strong foundation. But be patient, it will take times.",
        "author": "New_Computer3619",
        "created_utc": 1739456514,
        "score": 5,
        "parent_id": "t3_1iojekx",
        "depth": 0
      },
      {
        "id": "mck4lm5",
        "body": "Break big problems down into smaller ones whenever possible, and make a mental note of what you can do (from your bag of tricks) that might get you going in the right direction.\n\nFor problems where you find a round-about solution, and find an optimized answer in your textbook or an example, analyze the optimized solution to get ideas on what approach they took to get to that answer. You can then try to iterate on your own solution to utilize the ‘trick’ you’ve learned to get a handle on how it works.\n\nThe best thing you can do now is iterate on solutions you’ve already come up with to figure out how you can improve them. As you refine your approach to problems and learn more about what to be on the look out for, you will find that problems are less and less daunting.",
        "author": "Mutex_CB",
        "created_utc": 1739459003,
        "score": 3,
        "parent_id": "t3_1iojekx",
        "depth": 0
      },
      {
        "id": "mcw9232",
        "body": "Advice 1)\nBefore joining the industry, I found a post listing the 20 most referenced books on stack overflow and read all of them cover to cover. Note I did this over the course of an entire year and wasn’t working. The thinking was “these are the books most engineers use to shape their thinking, if I read these I should be able to get in their mindset”.\n\nI’ve been in industry for about 7 years now and while it was time consuming and hard, the payoff of reading those books has been immense for “having an engineers brain”. Large majority of the time I have at least a framework or a foundation to start with, even when my colleagues are discussing something very new to me. It’s typically relatively easy to understand the lines of thought when discussing problems and solutions.\n\nAdvice 2)\nTo expand on the top comment about practice… \n\nNot sure if you play music, but long term if you want to be a great musician it’s better to learn fewer songs relatively perfectly than a lot of songs at an average level. The reason is, when you absolutely master certain aspects of a song, then when you see those aspects again when learning future songs, you’ll immediately grasp them and be able to do them perfectly. There’s a sense of exponential gains to it.\n\nSoftware engineering is the same way. When you work on a new problem, understand the problem deeply, understand possible solutions deeply, understand the tech that could be used deeply. If you do this most of the time you’re working, after a few years you’ll transition into being very good. That price you paid of thinking deeply about individual problems eventually coalesces into the ability to think deeply, quickly and easily in a lot of contexts.",
        "author": "ah2870",
        "created_utc": 1739624984,
        "score": 3,
        "parent_id": "t3_1iojekx",
        "depth": 0
      },
      {
        "id": "mcjxxc9",
        "body": "you dont need practice, practice is boring, you just need to do stuff more and then you get good at it",
        "author": "Immediate-Country650",
        "created_utc": 1739456837,
        "score": 2,
        "parent_id": "t3_1iojekx",
        "depth": 0
      },
      {
        "id": "mckijis",
        "body": "There is no silver bullet, bro. Try and fail, this is how you gain experience.",
        "author": "Mission-Comfort-1165",
        "created_utc": 1739463123,
        "score": 2,
        "parent_id": "t3_1iojekx",
        "depth": 0
      },
      {
        "id": "mckvl3y",
        "body": "You can't really turn your brain into a different one, at least not quickly.  \n  \nThe best you can do is learn to recognize when you're getting stuck and come up with a coping strategy to get back out of the corner.",
        "author": "istarian",
        "created_utc": 1739466777,
        "score": 2,
        "parent_id": "t3_1iojekx",
        "depth": 0
      },
      {
        "id": "mcnl73t",
        "body": "intuition. and breadth-first search\n\nEdit: basically A*",
        "author": "These-Maintenance250",
        "created_utc": 1739495591,
        "score": 2,
        "parent_id": "t3_1iojekx",
        "depth": 0
      },
      {
        "id": "me4dc67",
        "body": "like others have said not just with CS, I think with any STEM, practice practice practice, this is a skill that will develop over time like any sports any art,.... Learn the concept by reading or Youtubing etc but solve examples on your own.",
        "author": "TopNotchNerds",
        "created_utc": 1740204180,
        "score": 2,
        "parent_id": "t3_1iojekx",
        "depth": 0
      }
    ],
    "1ip1c8v": [
      {
        "id": "mcobt4t",
        "body": "Just from your description, it doesn’t sound like computer science is your thing.  No shame.  \n\nGet curious about natural sciences.  (computers will likely just be used as tools there)",
        "author": "airpipeline",
        "created_utc": 1739505037,
        "score": 62,
        "parent_id": "t3_1ip1c8v",
        "depth": 0
      },
      {
        "id": "mco81tj",
        "body": "Why force yourself to like it?",
        "author": "Any-Illustrator-9808",
        "created_utc": 1739503636,
        "score": 43,
        "parent_id": "t3_1ip1c8v",
        "depth": 0
      },
      {
        "id": "mco8ssg",
        "body": "I run simulations in supercomputers to accelerate the process at which we compute stuff. Stuff can be lots of things, from the structural analysis of a telescope to the distortion its lenses, can be the rate at which COVID propagates, or the trajectory of a spaceship. Things take months/years to compute, so we speed up this process.",
        "author": "SexyMuon",
        "created_utc": 1739503912,
        "score": 6,
        "parent_id": "t3_1ip1c8v",
        "depth": 0
      },
      {
        "id": "mcojuqh",
        "body": "3Blue1Brown (leans mathsy):\n\n[https://www.youtube.com/@3blue1brown](https://www.youtube.com/@3blue1brown)\n\nNumberphile (leans even more mathsy):\n\n[https://www.youtube.com/@numberphile](https://www.youtube.com/@numberphile) \n\nStatQuest (great for DS/ML):\n\n[https://www.youtube.com/channel/UCtYLUTtgS3k1Fg4y5tAhLbw](https://www.youtube.com/channel/UCtYLUTtgS3k1Fg4y5tAhLbw)\n\nAsianometry (leans towards the hardware / CPU / GPU / history / economics / side of things):\n\n[https://www.youtube.com/@Asianometry](https://www.youtube.com/@Asianometry) \n\nTwo Minute Papers:\n\n[https://www.youtube.com/@TwoMinutePapers](https://www.youtube.com/@TwoMinutePapers) \n\nComputerphile:\n\n[https://www.youtube.com/@Computerphile](https://www.youtube.com/@Computerphile)\n\nReducible:\n\n[https://www.youtube.com/@Reducible](https://www.youtube.com/@Reducible) \n\nQuanta Magazine (more general science): \n\n[https://www.youtube.com/@QuantaScienceChannel](https://www.youtube.com/@QuantaScienceChannel) \n\nFireship:\n\n[https://www.youtube.com/@Fireship](https://www.youtube.com/@Fireship) \n\nbyCloud: \n\n[https://www.youtube.com/@bycloudAI](https://www.youtube.com/@bycloudAI) \n\nThe Primeagen:\n\n[https://www.youtube.com/@ThePrimeagen](https://www.youtube.com/@ThePrimeagen)\n\nNeetcode (DS&A):\n\n[https://www.youtube.com/@NeetCode](https://www.youtube.com/@NeetCode) \n\nfreeCodeCamp:\n\n[https://www.youtube.com/@freecodecamp](https://www.youtube.com/@freecodecamp) \n\nLow Level:\n\n[https://www.youtube.com/@LowLevelTV](https://www.youtube.com/@LowLevelTV)\n\nJeff Geerling (Rasberry Pi etc):\n\n[https://www.youtube.com/@JeffGeerling](https://www.youtube.com/@JeffGeerling) \n\nEngineer Man:\n\n[https://www.youtube.com/@EngineerMan](https://www.youtube.com/@EngineerMan) \n\nIf you can't find ***something*** from this list that interests you and inspires you, then I feel you're a lost cause. Find another major instead?\n\n(edit: my bad, just saw your comment you're already doing a career in logistics, with no plans to change. And you want to do this for your husband, that's so sweet! My suggestion, watch some of Asianometry videos where they talk about the economics/history/logistics of the tech industry, I personally find them ***FASCINATING*** , and maybe you too will appreciate watching them and thinking about the logistic side of things? But along the way, pick up a bit of CS knowledge too by accident. Next look into ways you can see how CS knowledge can be applied to your own career. For instance read about the very famous travelling salesman problem, which is very important when it comes to logistics with route planning. And is a tough problem in CS. Just in general almost anything from Operations Research or Data Science or IoT could find applications to logistics, just to mention quickly three big areas of CS *ish*)",
        "author": "MathmoKiwi",
        "created_utc": 1739508295,
        "score": 6,
        "parent_id": "t3_1ip1c8v",
        "depth": 0
      },
      {
        "id": "mcobrrf",
        "body": "When I was younger I was always fascinated with electronics, I watched cool movies, hacking, video games, screens, I had an N64, a Gameboy, later an Xbox, always fascinated with my PC and computing, had a laptop in grade 9, was always interested in coding, I wanted to be a programmer or an anesthesiologist. I went on to study computer science and instantly fell in love with coding and software, challenging assignments and doing tests in pseudo code, I never knew how the software I made impacted the real world, I know more now, I just loved the process of building software applications and solving mathematical problems in code",
        "author": "burncushlikewood",
        "created_utc": 1739505022,
        "score": 5,
        "parent_id": "t3_1ip1c8v",
        "depth": 0
      },
      {
        "id": "mcodoyv",
        "body": "[https://www.youtube.com/@Computerphile](https://www.youtube.com/@Computerphile) might be what you're looking for.",
        "author": "Auxire",
        "created_utc": 1739505764,
        "score": 5,
        "parent_id": "t3_1ip1c8v",
        "depth": 0
      },
      {
        "id": "mcolkw8",
        "body": "Let me tell you my story.\n\nSee, since I was a kid, I always loved Sci Fi, with Star Wars being my favourite movie franchise. In my teens, I got into Star Trek and then Stargate, which became my favourite TV series. But all of those are about space. Take note of that.\n\nNow, I also wanted to be a scientist. But as scientists in pop culture are always chemists or physicists, I first thought I was going there. But as I also liked to build things and tinker with stuff, an engineering was also on consideration. I mean, my favorite toys were LEGO and Meccano, and I disassembled every device in my home at least once.\n\nBut then, Winter of 2010 came, and with it the release of the movie TRON: Legacy. If you don't know about it, it is a sequel to a 1982 film about a programmer that due an experimental laser thingamabob ends up inside the computer. The movie portrays a fantastic futuristic world that lives inside the computer, where programs are people that you talk to, and things are made out of code. No things found in other planets, but inside the device at your desk. The amazing visuals and the soundtrack made by Daft Punk, had me dazzled.\n\nHere is a video that in my opinion, captures the essence of the film: https://vimeo.com/86582795\n\nA thought came to my mind: \"By coding, You can do all of that?. Where I can learn that magic?\".\n\nIt was also back then that I started to get my first ever tech: a 2nd gen iPod Touch and a simple, small, and slow Netbook. In both I explored what you could do, and learned that the only barrier for doing things is to get the hardware, and from there, is is only what you know, as thanks to the open source community you have access to a ton of software and resources for free that you can do what you please. It was like unlocking creative mode on Minecraft.\n\nI saw my calling. The bits were luring me.\n\nFinally, here is a video about all what we do. Go ahead with the mind of \"I can do all of that\": https://youtu.be/SzJ46YA_RaA",
        "author": "MasterGeekMX",
        "created_utc": 1739509060,
        "score": 3,
        "parent_id": "t3_1ip1c8v",
        "depth": 0
      },
      {
        "id": "mcp98ks",
        "body": "Depending on which physical sciences you're comfortable with, you might enjoy learning this way: https://www.nand2tetris.org/",
        "author": "nderflow",
        "created_utc": 1739521688,
        "score": 3,
        "parent_id": "t3_1ip1c8v",
        "depth": 0
      },
      {
        "id": "mcodyjr",
        "body": "As with most things, you need will and time.  If you don’t have motivation you’re going to need a heck of a lot of discipline.  Maybe just forcing yourself into an attainable study routine to get past the initial hill will help you see enough of the field to find something that interests you?  Maybe like an hour a day or something?  It’s a marathon, not a sprint.\n\nI’m not sure what kind of science person you are, but maybe you could start with something related to your field?  Computers have revolutionized science so it shouldn’t be hard to find something.",
        "author": "arabidkoala",
        "created_utc": 1739505867,
        "score": 2,
        "parent_id": "t3_1ip1c8v",
        "depth": 0
      },
      {
        "id": "mczg7mh",
        "body": "The best way to succeed in anything you do, regardless if it's a job or life, is to continuously focus on improving your skills and being realistic with your goals. At this day and age, I have seen how easy to make anything marketable. Give yourself time to practice and practice your craft, and be crafty with what you currently have.",
        "author": "dashthegoat",
        "created_utc": 1739661996,
        "score": 2,
        "parent_id": "t3_1ip1c8v",
        "depth": 0
      }
    ],
    "1ion2gm": [
      {
        "id": "mcm8sa1",
        "body": "[RFC1436](https://www.rfc-editor.org/rfc/rfc1436). It's concise, detailed enough to implement a client or server from spec, also written with a particular flavor of informality and humor common to early RFCs.",
        "author": "nuclear_splines",
        "created_utc": 1739480558,
        "score": 6,
        "parent_id": "t3_1ion2gm",
        "depth": 0
      },
      {
        "id": "mclsiir",
        "body": "IP over avian carriers: https://tools.ietf.org/html/rfc2549",
        "author": "ertoes",
        "created_utc": 1739476030,
        "score": 5,
        "parent_id": "t3_1ion2gm",
        "depth": 0
      }
    ],
    "1inwzoo": [
      {
        "id": "mcejjc9",
        "body": "DFAs have endless applications, from building compilers to Regex processing. Aside from, studying theoretical models of computation helps you understand what computers can and cannot do. They also help you sharpen your logical thinking and optimisation skills.",
        "author": "Black_Bird00500",
        "created_utc": 1739383317,
        "score": 44,
        "parent_id": "t3_1inwzoo",
        "depth": 0
      },
      {
        "id": "mcejykv",
        "body": "Because transforming strings of characters from one state to another according to particular rules is the definition of compiling human-readable source code into machine code. \n\nIf you ever want to know how a programming language actually works (or even make your own one day) then you'll need a background in DFAs and NFAs.",
        "author": "LostInChrome",
        "created_utc": 1739383436,
        "score": 27,
        "parent_id": "t3_1inwzoo",
        "depth": 0
      },
      {
        "id": "mcel50p",
        "body": "DFAs (and converting NFAs to DFAs) is used in regex processing and by YACC and LEX to build compilers. (The input language in YACC is an NFA; internally a DFA is built and is used to convert a string of tokens into an internal representation that can then be turned into assembly language.)\n\nDFAs are also used in computer security for building systems that can rapidly pattern match for detecting viruses and malicious content.\n\nDFAs are basically one way to think of state machines--and those are used in hardware design of processors, or building interpreters that can interpret a language. (I once built my own LISP interpreter that was basically a state machine that drove the 'eval' process.)\n\nDFAs are used to control simple AIs in games for creating NPCs.\n\nDFAs are also used in the design of database query optimization.\n\nAnd, formally, behind the scenes, DFAs are constructed in computer languages like Kotlin for coroutines (and in writing suspend routines), and for languages like Swift with 'async/await' routines. Internally these functions are rewritten by the compiler into a state machine, and the internal state is what dictates where in the function execution continues when a wait point is reached during execution. \n\n----\n\nBasically if you need something that can do pattern matching quickly, to find patterns that can be matched quickly, or in creating a simulator or language interpreter--DFAs are the thing you should be reaching for to pull it off.",
        "author": "w3woody",
        "created_utc": 1739383766,
        "score": 15,
        "parent_id": "t3_1inwzoo",
        "depth": 0
      },
      {
        "id": "mcetk1m",
        "body": "Even if all you do is the simplest web dev, the screen the user is looking at is the state, and all the actions they can take are input to drive state transitions.\n\nMore than that though, computational models are frameworks for thinking, new kinds of ideas you are able to have, that will help you solve all manner of problems in computing.",
        "author": "joelangeway",
        "created_utc": 1739386085,
        "score": 5,
        "parent_id": "t3_1inwzoo",
        "depth": 0
      },
      {
        "id": "mch3zcu",
        "body": "The key is in the name computational **models**.  The point is to build up what exactly constitutes \"computation\" so that you can reason about what is possible for computers to do, and, more critically, what is *impossible* for computers to do.  An important thing to realise here is that \"computation\" is a very broad concept, it can range from the execution of a single program, to the running of a large integrated system.\n\nThe first concept you come across is the idea of a state machine - which is really just a more mathematical way of looking at a flow diagram.  If you've ever used/come across flow diagrams in CS before, then you should be able to appreciate how a state machine can \"model\" computation in a very simple way.  Well, it seems simple, but it can also prove to be surprisingly complex as it can cover many scenarios - Digital circuitry, SMTP protocol, Regular Expressions, Lexical parsers (as others have mentioned) to name a few.  In fact, DFAs are just \"computation with finite memory\" - which, if you think about it, actually covers all \"real-world\" computers (you can't download more RAM).   But I think the best application is learning to structure your programming \"by state\". This can be an incredibly powerful way of thinking about the flow of your program.\n\nDFAs (and NFAs) are pretty handy - they're structurally simple, algorithmically well behaved and lend themselves very well to constructive manipulation (e.g. constructing a regular expression that is the complement of another regular expression).  But before you try to structure all your programs in terms of finite state machines, it is important to realise what is and is not possible to do with them.\n\nSo what (standard \"computation processes\") can't they do?  [From a purely practical manner they cover all \"real-world\" computers - so to look for exceptions we have to move into a universe of unbounded resources].  Anyway, it turns out they can't deal with recursion.  This is a very powerful CS technique, it allows us to encode arbitrarily large structures/programs in a finite way, and we use it all the time (e.g. defining computer languages, data structures, programs).  If finite automata cover \"computation with finite memory\", then the first obvious step is to add some form of memory to cope with \"arbitrarily large, but recursively defined structures\".  We could just add \"memory\" - that takes us all the way to the end goal of models of computation (Turing Machines), but we can also ask can we add a more restrictive type of memory that keeps things simple (i.e. close to DFAs) but gives enough power to deal with (simple) recursion?  This leads to the next step - Pushdown Automata (which are NFAs with a \"stack-based\" memory).  This is another good model of computation - if you think about how a computer executes a program with subroutine/function/recursive calls - it has to \"push\" the current state onto a stack, so that when it returns from the subroutine it can \"pop\" the state and return to the original process.  Turns out these are also very useful for a lot of concepts defined with simple recursion - e.g. programming languages, parsing data structures (e.g. JSON).\n\nSo Pushdown automata are more powerful than DFAs/NFAs, but that power comes at a cost.  DFAs/NFAs are algorithmically very nice to work with and reason about.  PDAs are not so nice. Realising these differences are critical as it can help you make informed decisions about how you (and others) design computational systems.\n\nThe last step in the journey is the introduction of a Turing Machine.  Why is this the last step?  Well, philosophically, a Turing Machine is doing pretty much what we as humans do - write stuff down, and edit it as we discover new ideas, leading to new ideas, and so on.  So, at a philosophical level, Turing Machines capture what we consider to be \"humanly computable\".  In fact, a Turing Machine has the ability to \"model itself\".  If we are satisfied that we have defined the \"true\" model of computation [this is a problem that can never be solved], we can continue to ask - is there anything we cannot compute?  It turns out that the answer is \"yes\", and, more importantly, we can even come up with concrete things that are impossible to compute (e.g. a program that determines if a given program will stop).  It is only possible to answer this question once we have established a \"model of computation\".",
        "author": "_--__",
        "created_utc": 1739410214,
        "score": 4,
        "parent_id": "t3_1inwzoo",
        "depth": 0
      },
      {
        "id": "mchwwnr",
        "body": "Applications that are large and stateful like a network protocol parser or a compiler are implemented using this model.",
        "author": "SecretaryFlaky4690",
        "created_utc": 1739420232,
        "score": 2,
        "parent_id": "t3_1inwzoo",
        "depth": 0
      },
      {
        "id": "mcigyhl",
        "body": "There are other fascinating model that not commonly teach in the class (referring from my own experience), lambda calculus, cellular automata and rewriting system.\n\nHaving a model can tell you the property (of the model) like, what it can do and what it can not do, which is very useful.",
        "author": "recursion_is_love",
        "created_utc": 1739429698,
        "score": 2,
        "parent_id": "t3_1inwzoo",
        "depth": 0
      }
    ],
    "1indsbv": [
      {
        "id": "mcaw18s",
        "body": "My rough understanding is that the object/meta language distinction is a relationship in a particular context, not an absolute state. By this I mean, if you use language A to make statements about language B, then A is the meta language and B is the object language. If you use B to make statements about language C, then B is the meta language and C is the object language.\n\nI usually see this in the context of more powerful languages being used to make statements about less powerful ones. For instance, a sufficiently weak logic can be shown to be both sound and complete, but demonstrating this may require a proof in a more powerful system. The more powerful system (the metalanguage) can allow us to say things about the weaker system (the object language) which the object language may not be capable of saying about itself. ",
        "author": "josephjnk",
        "created_utc": 1739328507,
        "score": 6,
        "parent_id": "t3_1indsbv",
        "depth": 0
      }
    ],
    "1in9hjv": [
      {
        "id": "mc96nf6",
        "body": "Knn is well known problem with standard solutions (usually divide and conquer using something like a lazy splitting octree)\n\nThese guys are looking for ppl with lots of algo exp.\n\nEnjoy 😉",
        "author": "Revolutionalredstone",
        "created_utc": 1739309079,
        "score": 10,
        "parent_id": "t3_1in9hjv",
        "depth": 0
      }
    ],
    "1imdtxj": [
      {
        "id": "mc28g5q",
        "body": "I hate Quanta. They spend the entire article talking around the topic and never actually tell you what the optimization is.",
        "author": "c3534l",
        "created_utc": 1739214147,
        "score": 68,
        "parent_id": "t3_1imdtxj",
        "depth": 0
      },
      {
        "id": "mc385en",
        "body": "I watched his [presentation video](https://youtu.be/ArQNyOU1hyE) (I did not read the full paper), and the summary of his technique is that it's a pyramidal approach to the open hash space. Instead of a space of length `k`, the top level has `k`, the next has `k/2`, the next `k/4`, etc. For an insertion, the algorithm will do `c` hash retries to per level before it goes to the next level, tries `c` more times on that level, etc., until it finds an opening.\n\nNaively, it seems to me to be similar if he had just increased the size of the open addressing space to `2k-1` (the count of all items in all levels) without any retries, with the benefit that he would save time on retries. It also seems like his disproving Yao is really just the slight of hand of superficially keeping the space at `k`, when really it's `2k-1` pyramidally.\n\nI have to be missing something. Can someone point it out?",
        "author": "MrHanoixan",
        "created_utc": 1739228778,
        "score": 39,
        "parent_id": "t3_1imdtxj",
        "depth": 0
      },
      {
        "id": "mc59rmz",
        "body": "My understanding:\n\nWorst case with only 1 empty slot is the same.\n\nBrilliant idea:  instead of treating a hash table as 1 big memory block, treat it as several smaller memory blocks.\n\nOn average the first few blocks fill up.  When a hash algorithm is showing mostly full we swap algorithms.  This means on average we insert faster because we can sometimes skip “completely full” hash algorithms.  This spreads out “worser” cases running time.\n\nThe last few inserts still eat up a lot of time, but they won’t eat up more time than a normal hash function.",
        "author": "two_three_five_eigth",
        "created_utc": 1739257388,
        "score": 4,
        "parent_id": "t3_1imdtxj",
        "depth": 0
      }
    ]
  }
}